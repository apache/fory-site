"use strict";(self.webpackChunkfory_site=self.webpackChunkfory_site||[]).push([[90047],{66929:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>t,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var i=n(85893),s=n(11151);const a={slug:"fory_cpp_blazing_fast_serialization_framework",title:"Introducing Apache Fory\u2122 C++: Blazing-Fast, Type-Safe Serialization for Modern C++",authors:["chaokunyang"],tags:["fory","cpp","serialization","cross-language"]},t=void 0,o={permalink:"/blog/fory_cpp_blazing_fast_serialization_framework",editUrl:"https://github.com/apache/fory-site/tree/main/blog/2026-02-19-fory_cpp_modern_serialization_framework.md",source:"@site/blog/2026-02-19-fory_cpp_modern_serialization_framework.md",title:"Introducing Apache Fory\u2122 C++: Blazing-Fast, Type-Safe Serialization for Modern C++",description:"TL;DR: Apache Fory C++ is a blazing-fast, cross-language serialization framework delivering exceptional binary performance with support for polymorphic types, circular references, schema evolution, and seamless interoperability with Java, Python, Go, Rust, and JavaScript \u2014 all via modern C++17 with zero runtime reflection overhead.",date:"2026-02-19T00:00:00.000Z",formattedDate:"February 19, 2026",tags:[{label:"fory",permalink:"/blog/tags/fory"},{label:"cpp",permalink:"/blog/tags/cpp"},{label:"serialization",permalink:"/blog/tags/serialization"},{label:"cross-language",permalink:"/blog/tags/cross-language"}],readingTime:14.82,hasTruncateMarker:!1,authors:[{name:"Shawn Yang",title:"Apache Fory PMC Chair",url:"https://github.com/chaokunyang",imageURL:"/img/authors/chaokunyang.png",key:"chaokunyang"}],frontMatter:{slug:"fory_cpp_blazing_fast_serialization_framework",title:"Introducing Apache Fory\u2122 C++: Blazing-Fast, Type-Safe Serialization for Modern C++",authors:["chaokunyang"],tags:["fory","cpp","serialization","cross-language"]},unlisted:!1,nextItem:{title:"Fory v0.15.0 Released",permalink:"/blog/fory_0_15_0_release"}},l={authorsImageUrls:[void 0]},d=[{value:"The C++ Serialization Problem",id:"the-c-serialization-problem",level:2},{value:"What Makes Apache Fory C++ Different?",id:"what-makes-apache-fory-c-different",level:2},{value:"Compile-Time Code Generation",id:"compile-time-code-generation",level:3},{value:"Cross-Language Binary Protocol",id:"cross-language-binary-protocol",level:3},{value:"Polymorphism via Smart Pointers",id:"polymorphism-via-smart-pointers",level:3},{value:"Shared/Circular Reference Tracking",id:"sharedcircular-reference-tracking",level:3},{value:"Schema Evolution",id:"schema-evolution",level:3},{value:"Row Format: Zero-Copy Analytics",id:"row-format-zero-copy-analytics",level:3},{value:"Installation",id:"installation",level:2},{value:"CMake (FetchContent)",id:"cmake-fetchcontent",level:3},{value:"Bazel",id:"bazel",level:3},{value:"Native Serialization",id:"native-serialization",level:2},{value:"Error Handling",id:"error-handling",level:3},{value:"Thread Safety",id:"thread-safety",level:3},{value:"Cross-Language Serialization",id:"cross-language-serialization",level:2},{value:"Without IDL",id:"without-idl",level:3},{value:"With the Fory Schema IDL Compiler",id:"with-the-fory-schema-idl-compiler",level:3},{value:"1. Install the compiler",id:"1-install-the-compiler",level:4},{value:"2. Write a schema (<code>ecommerce.fdl</code>)",id:"2-write-a-schema-ecommercefdl",level:4},{value:"3. Generate code",id:"3-generate-code",level:4},{value:"4. Use the generated C++ code",id:"4-use-the-generated-c-code",level:4},{value:"Supported Types",id:"supported-types",level:2},{value:"Configuration Reference",id:"configuration-reference",level:2},{value:"Benchmarks",id:"benchmarks",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const r={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"TL;DR"}),": Apache Fory C++ is a blazing-fast, cross-language serialization framework delivering ",(0,i.jsx)(r.strong,{children:"exceptional binary performance"})," with support for ",(0,i.jsx)(r.strong,{children:"polymorphic types, circular references, schema evolution, and seamless interoperability"})," with Java, Python, Go, Rust, and JavaScript \u2014 all via modern C++17 with zero runtime reflection overhead."]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["\ud83d\udc19 GitHub: ",(0,i.jsx)(r.a,{href:"https://github.com/apache/fory",children:"https://github.com/apache/fory"})]}),"\n",(0,i.jsxs)(r.li,{children:["\ud83d\udcda Docs: ",(0,i.jsx)(r.a,{href:"https://fory.apache.org/docs/guide/cpp",children:"https://fory.apache.org/docs/guide/cpp"})]}),"\n"]}),"\n",(0,i.jsx)("img",{src:"/img/fory-logo-light.png",width:"50%"}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"the-c-serialization-problem",children:"The C++ Serialization Problem"}),"\n",(0,i.jsx)(r.p,{children:"Every C++ developer working in a polyglot environment eventually hits the same wall. Existing options force a painful choice:"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"IDL-first frameworks"})," (Protocol Buffers, FlatBuffers): Require upfront schema compilation, lose native C++ type expressiveness, and carry significant integration friction. Every type change means regenerating code across all languages in lock-step."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Reflection-based frameworks"})," (Boost.Serialization, cereal): Limited cross-language support, no circular reference handling, no polymorphism without boilerplate. They work well within a single language but break down at system boundaries."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Hand-rolled binary formats"}),": Fast but brittle \u2014 any schema change risks silent corruption, and every new type requires manual encode/decode logic."]}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["Apache Fory C++ eliminates this trade-off. It delivers performance competitive with the fastest C++ serialization libraries while providing first-class support for polymorphism, shared/circular references, schema evolution, and ",(0,i.jsx)(r.strong,{children:"binary compatibility with Java, Python, Go, Rust, and JavaScript"})," \u2014 through a clean C++17 API."]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"what-makes-apache-fory-c-different",children:"What Makes Apache Fory C++ Different?"}),"\n",(0,i.jsx)(r.h3,{id:"compile-time-code-generation",children:"Compile-Time Code Generation"}),"\n",(0,i.jsxs)(r.p,{children:["Most serialization frameworks pay a runtime cost for flexibility \u2014 inspecting type information through virtual dispatch or hash maps at every call. Apache Fory takes a different approach: the ",(0,i.jsx)(r.code,{children:"FORY_STRUCT"})," macro uses C++ template metaprogramming to generate all serialization logic at compile time. The result is inlined, type-specific code with no virtual dispatch, no reflection, and no runtime overhead:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:'#include "fory/serialization/fory.h"\nusing namespace fory::serialization;\n\nstruct Person {\n  std::string name;\n  int32_t age;\n  std::vector<std::string> hobbies;\n  std::map<std::string, std::string> metadata;\n  std::optional<std::string> nickname;\n};\nFORY_STRUCT(Person, name, age, hobbies, metadata, nickname);\n'})}),"\n",(0,i.jsx)(r.p,{children:"That single macro generates compile-time field metadata, efficient serialization/deserialization code via ADL (Argument-Dependent Lookup), and type registration hooks. The macro can be placed inside the class body to access private fields, or at namespace scope for third-party types."}),"\n",(0,i.jsx)(r.h3,{id:"cross-language-binary-protocol",children:"Cross-Language Binary Protocol"}),"\n",(0,i.jsx)(r.p,{children:"Apache Fory C++ speaks the same binary wire format as Java, Python, Go, Rust, and JavaScript. Serialize a struct in C++, deserialize it in Python \u2014 no adaptation layer, no schema translation, no version negotiation needed. This is especially powerful for microservice architectures where different teams own different services in different languages:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:"// C++: Serialize\nauto fory = Fory::builder().xlang(true).build();\nfory.register_struct<Person>(100);\nauto bytes = fory.serialize(person).value();\n"})}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:"# Python: Deserialize (same binary format, same type ID)\nfory = pyfory.Fory(xlang=True)\nfory.register(Person, type_id=100)  # Same ID as C++\nperson = fory.deserialize(data)\n"})}),"\n",(0,i.jsx)(r.p,{children:"The core requirements for cross-language interoperability are consistent type IDs/Names across participating runtimes, matching canonical field names, and compatible field types for those names."}),"\n",(0,i.jsx)(r.h3,{id:"polymorphism-via-smart-pointers",children:"Polymorphism via Smart Pointers"}),"\n",(0,i.jsxs)(r.p,{children:["Serializing polymorphic objects is notoriously difficult in C++. Most frameworks require manual type tagging or generate large amounts of boilerplate. Apache Fory handles it automatically: it detects polymorphic types via ",(0,i.jsx)(r.code,{children:"std::is_polymorphic<T>"})," and preserves the full runtime type identity through ",(0,i.jsx)(r.code,{children:"std::shared_ptr"})," and ",(0,i.jsx)(r.code,{children:"std::unique_ptr"}),". When you deserialize a ",(0,i.jsx)(r.code,{children:"shared_ptr<Animal>"})," that holds a ",(0,i.jsx)(r.code,{children:"Dog"}),", you get a ",(0,i.jsx)(r.code,{children:"Dog"})," back \u2014 no extra code required:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:"struct Animal { virtual ~Animal() = default; int32_t age = 0; };\nFORY_STRUCT(Animal, age);\nstruct Dog : Animal { std::string breed; };\nFORY_STRUCT(Dog, FORY_BASE(Animal), breed);\nstruct Cat : Animal { std::string color; };\nFORY_STRUCT(Cat, FORY_BASE(Animal), color);\n\nstruct Shelter { std::vector<std::shared_ptr<Animal>> animals; };\nFORY_STRUCT(Shelter, animals);\n\nauto fory = Fory::builder().track_ref(true).build();\nfory.register_struct<Shelter>(10); fory.register_struct<Dog>(11); fory.register_struct<Cat>(12);\n\nShelter s;\ns.animals.push_back(std::make_shared<Dog>()); // Dog at runtime\ns.animals.push_back(std::make_shared<Cat>()); // Cat at runtime\n\nauto decoded = fory.deserialize<Shelter>(fory.serialize(s).value()).value();\nassert(dynamic_cast<Dog*>(decoded.animals[0].get()) != nullptr); // Runtime type preserved!\n"})}),"\n",(0,i.jsxs)(r.p,{children:["Fory also supports ",(0,i.jsx)(r.code,{children:"std::unique_ptr"})," for exclusive-ownership polymorphic fields, and collections of smart pointers (",(0,i.jsx)(r.code,{children:"std::vector<std::shared_ptr<Base>>"}),", ",(0,i.jsx)(r.code,{children:"std::map<K, std::unique_ptr<Base>>"}),")."]}),"\n",(0,i.jsx)(r.h3,{id:"sharedcircular-reference-tracking",children:"Shared/Circular Reference Tracking"}),"\n",(0,i.jsx)(r.p,{children:"Many real-world data models contain shared objects or cycles: a parent node pointing to its children, which point back to the parent; an order referencing a customer who appears in multiple orders. Standard serialization frameworks either duplicate the data (wasting space) or crash with a stack overflow when they encounter a cycle."}),"\n",(0,i.jsxs)(r.p,{children:["With ",(0,i.jsx)(r.code,{children:"track_ref(true)"}),", Fory tracks object identity across the entire graph. Shared objects are serialized exactly once; every subsequent reference is encoded as a back-reference. Cycles terminate naturally:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:"struct Node {\n  virtual ~Node() = default;\n  int32_t id = 0;\n  std::vector<std::shared_ptr<Node>> neighbors;\n};\nFORY_STRUCT(Node, id, neighbors);\n\nauto fory = Fory::builder().track_ref(true).build();\nfory.register_struct<Node>(200);\n\nauto node1 = std::make_shared<Node>(); node1->id = 1;\nauto node2 = std::make_shared<Node>(); node2->id = 2;\nnode1->neighbors.push_back(node2);\nnode2->neighbors.push_back(node1);  // Cycle \u2014 handled correctly!\n\nauto bytes = fory.serialize(node1).value();\n// No stack overflow, no duplicate data \u2014 the cycle is preserved faithfully\nauto decoded = fory.deserialize<std::shared_ptr<Node>>(bytes).value();\n"})}),"\n",(0,i.jsx)(r.p,{children:"This makes Fory a natural fit for graph databases, entity-component systems, and any domain model with bidirectional relationships."}),"\n",(0,i.jsx)(r.h3,{id:"schema-evolution",children:"Schema Evolution"}),"\n",(0,i.jsxs)(r.p,{children:["In a microservice deployment, services update independently. A new version of the user service may add a ",(0,i.jsx)(r.code,{children:"phone"})," field while old consumers are still running. Without schema evolution support, this forces a coordinated, big-bang deployment. Apache Fory's ",(0,i.jsx)(r.strong,{children:"compatible mode"})," removes this constraint entirely:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:'// Version 1\nstruct UserV1 { std::string name; int32_t age; };\nFORY_STRUCT(UserV1, name, age);\n\n// Version 2 \u2014 new fields added independently\nstruct UserV2 { std::string name; int32_t age; std::string email; };\nFORY_STRUCT(UserV2, name, age, email);\n\nauto fory_v1 = Fory::builder().compatible(true).xlang(true).build();\nauto fory_v2 = Fory::builder().compatible(true).xlang(true).build();\nfory_v1.register_struct<UserV1>(100);\nfory_v2.register_struct<UserV2>(100);  // Same type ID enables evolution\n\nauto bytes = fory_v1.serialize(UserV1{"Alice", 30}).value();\nauto v2 = fory_v2.deserialize<UserV2>(bytes).value();\nassert(v2.name == "Alice" && v2.email == "");  // Default for missing field\n'})}),"\n",(0,i.jsx)(r.p,{children:"In compatible mode, fields are matched by name rather than position. New fields receive C++ default values when missing; removed fields are safely skipped. This enables rolling upgrades and independent service deployments without any serialization errors."}),"\n",(0,i.jsx)(r.h3,{id:"row-format-zero-copy-analytics",children:"Row Format: Zero-Copy Analytics"}),"\n",(0,i.jsxs)(r.p,{children:["Beyond object graph serialization, Apache Fory C++ implements a ",(0,i.jsx)(r.strong,{children:"row-based binary format"})," designed for analytics workloads. The row format stores data in a contiguous memory layout with a null bitmap, fixed-size slots for primitives, and a variable-length section for strings and nested objects. This enables ",(0,i.jsx)(r.strong,{children:"O(1) random field access by index"})," \u2014 you can read a single field from a large struct without touching the rest of the data."]}),"\n",(0,i.jsx)(r.p,{children:"This is particularly valuable in data pipelines and OLAP workloads where only a small subset of fields are queried per record:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:'#include "fory/encoder/row_encoder.h"\nusing namespace fory::row::encoder;\n\nstruct SensorReading {\n  int32_t sensor_id; double temperature; std::string location;\n  FORY_STRUCT(SensorReading, sensor_id, temperature, location);\n};\n\nRowEncoder<SensorReading> encoder;\nencoder.encode({42, 23.5, "rack-B"});\nauto row = encoder.get_writer().to_row();\n\n// Read any field in O(1) \u2014 no deserialization of unused fields\nint32_t id    = row->get_int32(0);\ndouble  temp  = row->get_double(1);\nauto    loc   = row->get_string(2);\n'})}),"\n",(0,i.jsxs)(r.p,{children:["For zero-copy access into an existing buffer (e.g., from a memory-mapped file or network receive buffer), Fory can point a ",(0,i.jsx)(r.code,{children:"Row"})," directly at the memory without copying:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:"auto src = encoder.get_writer().to_row();\nfory::row::Row view(src->schema());\nview.point_to(src->buffer(), src->base_offset(), src->size_bytes());  // Zero-copy view\nint32_t id = view.get_int32(0);  // Reads directly from the original buffer\n"})}),"\n",(0,i.jsx)(r.p,{children:"Use the row format for analytics, OLAP-style workloads, and partial field access. Use object graph serialization for full object round-trips with references and polymorphism."}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"installation",children:"Installation"}),"\n",(0,i.jsx)(r.p,{children:"Fory C++ requires a C++17-compatible compiler (GCC 7+, Clang 5+, MSVC 2017+) and supports both CMake and Bazel build systems."}),"\n",(0,i.jsx)(r.h3,{id:"cmake-fetchcontent",children:"CMake (FetchContent)"}),"\n",(0,i.jsxs)(r.p,{children:["The simplest integration is via CMake's ",(0,i.jsx)(r.code,{children:"FetchContent"})," module, which fetches and builds Fory as part of your project:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cmake",children:"cmake_minimum_required(VERSION 3.16)\nproject(my_project LANGUAGES CXX)\nset(CMAKE_CXX_STANDARD 17)\n\ninclude(FetchContent)\nFetchContent_Declare(fory\n    GIT_REPOSITORY https://github.com/apache/fory.git\n    GIT_TAG v0.15.0\n    SOURCE_SUBDIR cpp)\nFetchContent_MakeAvailable(fory)\n\nadd_executable(my_app main.cc)\ntarget_link_libraries(my_app PRIVATE fory::serialization)\n"})}),"\n",(0,i.jsx)(r.h3,{id:"bazel",children:"Bazel"}),"\n",(0,i.jsx)(r.p,{children:"For Bazel-based projects, add Fory as a module dependency:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-bazel",children:'bazel_dep(name = "fory", version = "0.15.0")\ngit_override(module_name = "fory",\n    remote = "https://github.com/apache/fory.git",\n    commit = "v0.15.0")\n'})}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-bazel",children:'cc_binary(name = "my_app", srcs = ["main.cc"],\n    deps = ["@fory//cpp/fory/serialization:fory_serialization"])\n'})}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"native-serialization",children:"Native Serialization"}),"\n",(0,i.jsxs)(r.p,{children:["For pure C++ applications without cross-language requirements, disabling ",(0,i.jsx)(r.code,{children:"xlang"})," produces a more compact binary encoding because no cross-language type metadata is emitted. This is the fastest possible path:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:"auto fory = Fory::builder()\n    .xlang(false)      // Native C++ mode \u2014 tighter encoding\n    .track_ref(false)  // Disable if no shared/circular refs\n    .build();\n\nfory.register_struct<Address>(1);\nfory.register_struct<Person>(2);\n\n// Serialize\nauto result = fory.serialize(person);\nif (!result.ok()) { std::cerr << result.error().to_string(); return 1; }\nstd::vector<uint8_t> bytes = std::move(result).value();\n\n// Deserialize\nauto decoded = fory.deserialize<Person>(bytes);\nassert(decoded.ok() && person == decoded.value());\n"})}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.code,{children:"FORY_STRUCT"})," handles several important C++ patterns that commonly arise in production codebases:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:"// Private fields \u2014 place macro in public: section\nclass Secure {\n  int32_t secret_; std::string token_;\npublic:\n  FORY_STRUCT(Secure, secret_, token_);\n};\n\n// Inheritance \u2014 FORY_BASE includes base class fields\nstruct Derived : Base {\n  std::string extra;\n  FORY_STRUCT(Derived, FORY_BASE(Base), extra);\n};\n\n// External/third-party types \u2014 use at namespace scope (public fields only)\nnamespace ext { struct Coord { double lat, lon; }; }\nFORY_STRUCT(ext::Coord, lat, lon);\n"})}),"\n",(0,i.jsx)(r.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsxs)(r.p,{children:["All Fory operations return ",(0,i.jsx)(r.code,{children:"Result<T, Error>"}),", making error handling explicit and composable. The ",(0,i.jsx)(r.code,{children:"FORY_TRY"})," macro provides a concise early-return pattern for functions that propagate errors:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:"// Option 1: Conditional check\nauto r = fory.serialize(obj);\nif (r.ok()) { auto bytes = std::move(r).value(); }\nelse { std::cerr << r.error().to_string(); }\n\n// Option 2: FORY_TRY macro for early return\nFORY_TRY(bytes, fory.serialize(obj));\n// Use bytes directly \u2014 any error propagates automatically\n"})}),"\n",(0,i.jsx)(r.h3,{id:"thread-safety",children:"Thread Safety"}),"\n",(0,i.jsx)(r.p,{children:"Fory provides two variants with different threading guarantees. Choose based on whether your serialization is centralized (shared instance) or distributed across threads:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:"// Single-threaded (fastest) \u2014 one instance per thread, no synchronization overhead\nauto fory = Fory::builder().build();\n\n// Thread-safe \u2014 shared across threads via an internal instance pool\nauto fory = Fory::builder().build_thread_safe();\nfory.register_struct<MyType>(1);  // Register all types before sharing\nstd::thread t([&]() { fory.serialize(obj); });  // Safe to call concurrently\n"})}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"cross-language-serialization",children:"Cross-Language Serialization"}),"\n",(0,i.jsx)(r.h3,{id:"without-idl",children:"Without IDL"}),"\n",(0,i.jsx)(r.p,{children:"When you control both sides of the wire and can coordinate type definitions manually, the simplest approach is to register types with matching numeric IDs in each language. This requires no additional tooling and works well for small, stable schemas:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:"// C++\nauto fory = Fory::builder().xlang(true).build();\nfory.register_struct<Order>(201);\nauto bytes = fory.serialize(order).value();\n"})}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-java",children:"// Java \u2014 same binary format, same type ID\nFory fory = Fory.builder().withLanguage(Language.XLANG).build();\nfory.register(Order.class, 201);\nOrder order = (Order) fory.deserialize(bytes);\n"})}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:"# Python \u2014 same binary format, same type ID\nfory = pyfory.Fory(xlang=True)\nfory.register(Order, type_id=201)\norder = fory.deserialize(data)\n"})}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Field matching"}),": In cross-language mode, field names are normalized to snake_case and matched by that canonical name. Ordering follows Fory's xlang field-order rules (not simple alphabetical ordering), so keep names semantically consistent across languages."]}),"\n",(0,i.jsx)(r.h3,{id:"with-the-fory-schema-idl-compiler",children:"With the Fory Schema IDL Compiler"}),"\n",(0,i.jsxs)(r.p,{children:["As schemas grow and span more services and teams, manually maintaining consistent field names, type IDs, and type definitions across five languages becomes error-prone. The ",(0,i.jsx)(r.strong,{children:"Fory Schema IDL Compiler"})," (",(0,i.jsx)(r.code,{children:"foryc"}),") solves this by letting you define types once in a ",(0,i.jsx)(r.code,{children:".fdl"})," file and generating idiomatic, production-ready code for every target language. The generated code includes typed accessors, serialization macros, registration helpers, and ",(0,i.jsx)(r.code,{children:"to_bytes()"}),"/",(0,i.jsx)(r.code,{children:"from_bytes()"})," helpers \u2014 so you never write serialization plumbing by hand."]}),"\n",(0,i.jsx)(r.h4,{id:"1-install-the-compiler",children:"1. Install the compiler"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-bash",children:"pip install fory-compiler\nforyc --help\n"})}),"\n",(0,i.jsxs)(r.h4,{id:"2-write-a-schema-ecommercefdl",children:["2. Write a schema (",(0,i.jsx)(r.code,{children:"ecommerce.fdl"}),")"]}),"\n",(0,i.jsxs)(r.p,{children:["Fory IDL syntax is concise and deliberately close to protobuf, so it is easy to pick up. Field modifiers like ",(0,i.jsx)(r.code,{children:"optional"}),", ",(0,i.jsx)(r.code,{children:"ref"}),", and ",(0,i.jsx)(r.code,{children:"list"})," map directly to idiomatic C++ types:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-protobuf",children:"package ecommerce;\n\nenum OrderStatus {\n    PENDING = 0; CONFIRMED = 1; SHIPPED = 2; DELIVERED = 3;\n}\n\nmessage Address {\n    string street = 1; string city = 2; string country = 3;\n}\n\nmessage Customer {\n    string           id      = 1;\n    string           name    = 2;\n    optional string  email   = 3;   // Nullable: maps to std::optional<std::string>\n    optional Address address = 4;\n}\n\nmessage OrderItem {\n    string  sku        = 1;\n    int32   quantity   = 2;\n    float64 unit_price = 3;\n}\n\n// Discount can be either a fixed amount or a percentage \u2014 modelled as a union\nmessage FixedDiscount   { float64 amount     = 1; }\nmessage PercentDiscount { float64 percentage = 1; }\n\n// union maps to std::variant<FixedDiscount, PercentDiscount> in C++\nunion Discount {\n    FixedDiscount   fixed   = 1;\n    PercentDiscount percent = 2;\n}\n\nmessage Order {\n    string            order_id   = 1;\n    ref Customer      customer   = 2;  // ref: std::shared_ptr + reference tracking\n    list<OrderItem>   items      = 3;  // list: std::vector<OrderItem>\n    OrderStatus       status     = 4;\n    float64           total      = 5;\n    optional string   notes      = 6;\n    timestamp         created_at = 7;\n    optional Discount discount   = 8;  // optional union field\n}\n"})}),"\n",(0,i.jsxs)(r.p,{children:["The IDL type system maps cleanly to native C++ constructs. ",(0,i.jsx)(r.code,{children:"union"})," is a first-class IDL construct that generates a ",(0,i.jsx)(r.code,{children:"std::variant"}),"-based wrapper class in C++, with typed case accessors (",(0,i.jsx)(r.code,{children:"is_fixed()"}),", ",(0,i.jsx)(r.code,{children:"as_fixed()"}),", etc.) and a ",(0,i.jsx)(r.code,{children:"visit()"})," method. Here is the full set of field modifiers and their C++ equivalents:"]}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Modifier"}),(0,i.jsx)(r.th,{children:"C++ type"}),(0,i.jsx)(r.th,{children:"Purpose"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"optional T"})}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"std::optional<T>"})}),(0,i.jsx)(r.td,{children:"Nullable field"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"ref T"})}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"std::shared_ptr<T>"})}),(0,i.jsx)(r.td,{children:"Shared / circular reference"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"ref(weak=true) T"})}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"fory::serialization::SharedWeak<T>"})}),(0,i.jsx)(r.td,{children:"Weak reference (breaks cycles)"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"list<T>"})}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"std::vector<T>"})}),(0,i.jsx)(r.td,{children:"Ordered list"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"map<K,V>"})}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"std::map<K,V>"})}),(0,i.jsx)(r.td,{children:"Key-value map"})]})]})]}),"\n",(0,i.jsx)(r.h4,{id:"3-generate-code",children:"3. Generate code"}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.code,{children:"foryc"})," generates a single header file per schema for C++, and equivalent files for every other target language. All generated files use the same type IDs derived from the package and type names, guaranteeing binary compatibility without any manual coordination:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-bash",children:"# Generate C++ header directly under ./generated\nforyc ecommerce.fdl --cpp_out ./generated\n\n# Generate multiple languages with explicit output directories\nforyc ecommerce.fdl --cpp_out ./generated --java_out ./java/src/main/java --python_out ./python/gen --go_out ./go/gen --rust_out ./rust/gen\n"})}),"\n",(0,i.jsxs)(r.p,{children:["The output structure for C++ is one header per schema file under the directory passed to ",(0,i.jsx)(r.code,{children:"--cpp_out"}),". For example, ",(0,i.jsx)(r.code,{children:"--cpp_out ./generated"})," produces ",(0,i.jsx)(r.code,{children:"generated/ecommerce.h"}),". The header contains all types under the ",(0,i.jsx)(r.code,{children:"ecommerce::"})," namespace, with ",(0,i.jsx)(r.code,{children:"FORY_STRUCT"})," macros and a ",(0,i.jsx)(r.code,{children:"register_types()"})," helper already wired up."]}),"\n",(0,i.jsx)(r.h4,{id:"4-use-the-generated-c-code",children:"4. Use the generated C++ code"}),"\n",(0,i.jsxs)(r.p,{children:["The generated header provides ",(0,i.jsx)(r.code,{children:"final"})," classes with typed accessors and ",(0,i.jsx)(r.code,{children:"to_bytes()"}),"/",(0,i.jsx)(r.code,{children:"from_bytes()"})," helpers. There is no manual Fory instance setup required \u2014 the helpers manage it internally:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:'#include "generated/ecommerce.h"\n\necommerce::Order order;\norder.set_order_id("ORD-2025-001");\norder.mutable_customer()->set_name("Alice");\norder.set_status(ecommerce::OrderStatus::CONFIRMED);\norder.set_total(159.98);\n\n// to_bytes()/from_bytes() are generated \u2014 no Fory boilerplate needed\nauto bytes = order.to_bytes().value();\nauto restored = ecommerce::Order::from_bytes(bytes).value();\nassert(restored.order_id() == "ORD-2025-001");\n'})}),"\n",(0,i.jsxs)(r.p,{children:["Because the generated Java, Python, and Go code uses the same type IDs, bytes serialized by the C++ ",(0,i.jsx)(r.code,{children:"to_bytes()"})," helper can be deserialized by the Java ",(0,i.jsx)(r.code,{children:"fromBytes()"})," or Python ",(0,i.jsx)(r.code,{children:"from_bytes()"})," helpers out of the box \u2014 no extra configuration required."]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"supported-types",children:"Supported Types"}),"\n",(0,i.jsx)(r.p,{children:"Apache Fory C++ supports a comprehensive set of types covering all common C++ data structures and cross-language primitives:"}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Category"}),(0,i.jsx)(r.th,{children:"C++ Types"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Primitives"}),(0,i.jsxs)(r.td,{children:[(0,i.jsx)(r.code,{children:"bool"}),", ",(0,i.jsx)(r.code,{children:"int8_t"}),"\u2026",(0,i.jsx)(r.code,{children:"int64_t"}),", ",(0,i.jsx)(r.code,{children:"uint8_t"}),"\u2026",(0,i.jsx)(r.code,{children:"uint64_t"}),", ",(0,i.jsx)(r.code,{children:"float"}),", ",(0,i.jsx)(r.code,{children:"double"})]})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Strings"}),(0,i.jsxs)(r.td,{children:[(0,i.jsx)(r.code,{children:"std::string"}),", ",(0,i.jsx)(r.code,{children:"std::string_view"}),", ",(0,i.jsx)(r.code,{children:"std::u16string"})]})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Collections"}),(0,i.jsxs)(r.td,{children:[(0,i.jsx)(r.code,{children:"std::vector<T>"}),", ",(0,i.jsx)(r.code,{children:"std::set<T>"}),", ",(0,i.jsx)(r.code,{children:"std::unordered_set<T>"}),", ",(0,i.jsx)(r.code,{children:"std::map<K,V>"}),", ",(0,i.jsx)(r.code,{children:"std::unordered_map<K,V>"})]})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Optional/Union"}),(0,i.jsxs)(r.td,{children:[(0,i.jsx)(r.code,{children:"std::optional<T>"}),", ",(0,i.jsx)(r.code,{children:"std::variant<Ts...>"})]})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Smart Pointers"}),(0,i.jsxs)(r.td,{children:[(0,i.jsx)(r.code,{children:"std::shared_ptr<T>"})," (ref tracking + polymorphism), ",(0,i.jsx)(r.code,{children:"std::unique_ptr<T>"}),", ",(0,i.jsx)(r.code,{children:"fory::serialization::SharedWeak<T>"})]})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Temporal"}),(0,i.jsxs)(r.td,{children:[(0,i.jsx)(r.code,{children:"std::chrono::nanoseconds"}),", ",(0,i.jsx)(r.code,{children:"fory::serialization::Timestamp"}),", ",(0,i.jsx)(r.code,{children:"fory::serialization::Date"})]})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Enums"}),(0,i.jsxs)(r.td,{children:["Scoped/unscoped enums; use ",(0,i.jsx)(r.code,{children:"FORY_ENUM"})," for non-continuous values"]})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"User structs"}),(0,i.jsxs)(r.td,{children:["Any type annotated with ",(0,i.jsx)(r.code,{children:"FORY_STRUCT"})]})]})]})]}),"\n",(0,i.jsxs)(r.p,{children:["All collection element and map value types can be arbitrarily nested, including structs, smart pointers, and ",(0,i.jsx)(r.code,{children:"std::optional"}),"."]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"configuration-reference",children:"Configuration Reference"}),"\n",(0,i.jsx)(r.p,{children:"Fory instances are constructed through a fluent builder API. All options have sensible defaults, so most applications only need to set one or two:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-cpp",children:"auto fory = Fory::builder()\n    .xlang(true)                // Cross-language binary protocol (default: true)\n    .compatible(true)           // Schema evolution / compatible mode (default: false)\n    .track_ref(true)            // Shared/circular reference tracking (default: true)\n    .max_dyn_depth(10)          // Max polymorphic nesting depth (default: 5)\n    .check_struct_version(true) // Validate struct hash on deserialization (default: false)\n    .build();                   // Single-threaded; use build_thread_safe() for multi-thread\n"})}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Tuning guide"}),": Disable ",(0,i.jsx)(r.code,{children:"compatible"})," for maximum throughput when schema changes are coordinated (same binary deployed together). Disable ",(0,i.jsx)(r.code,{children:"track_ref"})," for pure value types with no sharing or cycles \u2014 it eliminates per-object reference bookkeeping. Use ",(0,i.jsx)(r.code,{children:"xlang(false)"})," for C++-only deployments to get a more compact binary encoding."]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"benchmarks",children:"Benchmarks"}),"\n",(0,i.jsxs)(r.p,{children:["Apache Fory delivers exceptional performance across diverse data shapes. The combination of compile-time code generation, variable-length integer encoding, and a carefully designed binary protocol yields major gains versus text formats and strong results versus Protocol Buffers. In the current C++ benchmark report, Fory throughput vs Protobuf ranges from about ",(0,i.jsx)(r.strong,{children:"1.1x to 12.2x"})," depending on workload and operation:"]}),"\n",(0,i.jsx)("img",{src:"/img/benchmarks/cpp/throughput.png",width:"90%"}),"\n",(0,i.jsx)(r.p,{children:"The C++ implementation achieves similar relative speedups to the Java implementation. Because both share the same binary protocol design, and C++ serialization code is generated at compile time (eliminating the JIT warm-up cost), C++ performance is competitive or superior for latency-sensitive workloads."}),"\n",(0,i.jsx)(r.p,{children:"Serialized Data Sizes (bytes)"}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Datatype"}),(0,i.jsx)(r.th,{children:"Fory"}),(0,i.jsx)(r.th,{children:"Protobuf"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Struct"}),(0,i.jsx)(r.td,{children:"58"}),(0,i.jsx)(r.td,{children:"61"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Sample"}),(0,i.jsx)(r.td,{children:"446"}),(0,i.jsx)(r.td,{children:"375"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"MediaContent"}),(0,i.jsx)(r.td,{children:"365"}),(0,i.jsx)(r.td,{children:"301"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"StructList"}),(0,i.jsx)(r.td,{children:"184"}),(0,i.jsx)(r.td,{children:"315"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"SampleList"}),(0,i.jsx)(r.td,{children:"1980"}),(0,i.jsx)(r.td,{children:"1890"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"MediaContentList"}),(0,i.jsx)(r.td,{children:"1535"}),(0,i.jsx)(r.td,{children:"1520"})]})]})]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(r.p,{children:"Apache Fory C++ brings together a set of capabilities that no other C++ serialization library delivers as a cohesive package:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Performance"}),": Template-based compile-time codegen eliminates all runtime reflection overhead; a highly efficient binary protocol minimizes both serialized size and CPU cycles"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Cross-language"}),": The same binary format works natively with Java, Python, Go, Rust, and JavaScript"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Native C++ idioms"}),": ",(0,i.jsx)(r.code,{children:"std::shared_ptr"}),", ",(0,i.jsx)(r.code,{children:"std::optional"}),", ",(0,i.jsx)(r.code,{children:"std::variant"}),", ",(0,i.jsx)(r.code,{children:"fory::serialization::SharedWeak"})," \u2014 all handled naturally"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Production-ready features"}),": Polymorphism, circular references, schema evolution, thread safety out of the box"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Schema-first option"}),": The Fory IDL Compiler generates consistent, idiomatic code across all languages from a single ",(0,i.jsx)(r.code,{children:".fdl"})," definition \u2014 no more manually synchronizing type IDs across codebases"]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"Whether you are building a high-performance game server, a polyglot microservice backend, a real-time analytics pipeline, or an embedded system serializing complex domain models, Apache Fory C++ has you covered."}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Get started:"})}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-bash",children:"git clone https://github.com/apache/fory.git\ncd fory/examples/cpp/hello_world\ncmake -B build -DCMAKE_BUILD_TYPE=Release && cmake --build build\n./build/hello_world\n"})}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Documentation:"})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["C++ Serialization Guide: ",(0,i.jsx)(r.a,{href:"https://fory.apache.org/docs/guide/cpp",children:"fory.apache.org/docs/guide/cpp"})]}),"\n",(0,i.jsxs)(r.li,{children:["Fory Schema IDL Compiler: ",(0,i.jsx)(r.a,{href:"https://fory.apache.org/docs/compiler",children:"fory.apache.org/docs/compiler"})]}),"\n",(0,i.jsxs)(r.li,{children:["Xlang Serialization Spec: ",(0,i.jsx)(r.a,{href:"https://fory.apache.org/docs/specification/xlang_serialization_spec/",children:"fory.apache.org/docs/specification"})]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Community:"})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["GitHub: ",(0,i.jsx)(r.a,{href:"https://github.com/apache/fory",children:"apache/fory"})]}),"\n",(0,i.jsxs)(r.li,{children:["Slack: ",(0,i.jsx)(r.a,{href:"https://join.slack.com/t/fory-project/shared_invite/zt-1u8soj4qc-ieYEu7ciHOqA2mo47llS8A",children:"Join our community"})]}),"\n",(0,i.jsx)(r.li,{children:"License: Apache License 2.0"}),"\n"]})]})}function h(e={}){const{wrapper:r}={...(0,s.a)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},11151:(e,r,n)=>{n.d(r,{Z:()=>o,a:()=>t});var i=n(67294);const s={},a=i.createContext(s);function t(e){const r=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),i.createElement(a.Provider,{value:r},e.children)}}}]);