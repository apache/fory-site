"use strict";(self.webpackChunkfory_site=self.webpackChunkfory_site||[]).push([[36442],{16659:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>a,toc:()=>d});var i=r(85893),s=r(11151);const t={title:"Rust Serialization",sidebar_position:2,id:"serialization",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},l=void 0,a={id:"guide/serialization",title:"Rust Serialization",description:"Apache Fory\u2122 Rust",source:"@site/versioned_docs/version-0.13/guide/rust_guide.md",sourceDirName:"guide",slug:"/guide/serialization",permalink:"/docs/0.13/guide/serialization",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/fory-site/tree/main/docs/guide/rust_guide.md",tags:[],version:"0.13",sidebarPosition:2,frontMatter:{title:"Rust Serialization",sidebar_position:2,id:"serialization",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},sidebar:"docsSidebar",previous:{title:"Usage",permalink:"/docs/0.13/start/usage"},next:{title:"Scala Serialization",permalink:"/docs/0.13/guide/serialization"}},c={},d=[{value:"Apache Fory\u2122 Rust",id:"apache-fory-rust",level:2},{value:"\ud83d\ude80 Why Apache Fory\u2122 Rust?",id:"-why-apache-fory-rust",level:2},{value:"\ud83d\udce6 Crates",id:"-crates",level:2},{value:"\ud83c\udfc3 Quick Start",id:"-quick-start",level:2},{value:"Basic Example",id:"basic-example",level:3},{value:"\ud83d\udcda Core Features",id:"-core-features",level:2},{value:"1. Object Graph Serialization",id:"1-object-graph-serialization",level:3},{value:"2. Shared and Circular References",id:"2-shared-and-circular-references",level:3},{value:"Shared References with Rc/Arc",id:"shared-references-with-rcarc",level:4},{value:"Circular References with Weak Pointers",id:"circular-references-with-weak-pointers",level:4},{value:"3. Trait Object Serialization",id:"3-trait-object-serialization",level:3},{value:"Basic Trait Object Serialization",id:"basic-trait-object-serialization",level:4},{value:"Serializing <code>dyn Any</code> Trait Objects",id:"serializing-dyn-any-trait-objects",level:4},{value:"Rc/Arc-Based Trait Objects in Structs",id:"rcarc-based-trait-objects-in-structs",level:4},{value:"Standalone Trait Object Serialization",id:"standalone-trait-object-serialization",level:4},{value:"4. Schema Evolution",id:"4-schema-evolution",level:3},{value:"5. Enum Support",id:"5-enum-support",level:3},{value:"Schema Evolution",id:"schema-evolution",level:4},{value:"6. Tuple Support",id:"6-tuple-support",level:3},{value:"7. Custom Serializers",id:"7-custom-serializers",level:3},{value:"7. Row-Based Serialization",id:"7-row-based-serialization",level:3},{value:"8. Thread-Safe Serialization",id:"8-thread-safe-serialization",level:3},{value:"\ud83d\udd27 Supported Types",id:"-supported-types",level:2},{value:"Primitive Types",id:"primitive-types",level:3},{value:"Collections",id:"collections",level:3},{value:"Smart Pointers",id:"smart-pointers",level:3},{value:"Date and Time",id:"date-and-time",level:3},{value:"Custom Types",id:"custom-types",level:3},{value:"\ud83c\udf0d Cross-Language Serialization",id:"-cross-language-serialization",level:2},{value:"\u26a1 Performance",id:"-performance",level:2},{value:"\ud83d\udcd6 Documentation",id:"-documentation",level:2},{value:"\ud83c\udfaf Use Cases",id:"-use-cases",level:2},{value:"Object Serialization",id:"object-serialization",level:3},{value:"Row-Based Serialization",id:"row-based-serialization",level:3},{value:"\ud83c\udfd7\ufe0f Architecture",id:"\ufe0f-architecture",level:2},{value:"\ud83d\udd04 Serialization Modes",id:"-serialization-modes",level:2},{value:"SchemaConsistent Mode (Default)",id:"schemaconsistent-mode-default",level:3},{value:"Compatible Mode",id:"compatible-mode",level:3},{value:"\u2699\ufe0f Configuration",id:"\ufe0f-configuration",level:2},{value:"Maximum Dynamic Object Nesting Depth",id:"maximum-dynamic-object-nesting-depth",level:3},{value:"\ud83e\uddea Troubleshooting",id:"-troubleshooting",level:2},{value:"\ud83d\udee0\ufe0f Development",id:"\ufe0f-development",level:2},{value:"Building",id:"building",level:3},{value:"Testing",id:"testing",level:3},{value:"Code Quality",id:"code-quality",level:3},{value:"\ud83d\uddfa\ufe0f Roadmap",id:"\ufe0f-roadmap",level:2},{value:"\ud83d\udcc4 License",id:"-license",level:2},{value:"\ud83e\udd1d Contributing",id:"-contributing",level:2},{value:"\ud83d\udcde Support",id:"-support",level:2}];function o(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",hr:"hr",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"apache-fory-rust",children:"Apache Fory\u2122 Rust"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Apache Fory\u2122"})," is a blazing fast multi-language serialization framework powered by ",(0,i.jsx)(n.strong,{children:"JIT compilation"})," and ",(0,i.jsx)(n.strong,{children:"zero-copy"})," techniques, providing up to ",(0,i.jsx)(n.strong,{children:"ultra-fast performance"})," while maintaining ease of use and safety."]}),"\n",(0,i.jsx)(n.p,{children:"The Rust implementation provides versatile and high-performance serialization with automatic memory management and compile-time type safety."}),"\n",(0,i.jsx)(n.h2,{id:"-why-apache-fory-rust",children:"\ud83d\ude80 Why Apache Fory\u2122 Rust?"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"\ud83d\udd25 Blazingly Fast"}),": Zero-copy deserialization and optimized binary protocols"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"\ud83c\udf0d Cross-Language"}),": Seamlessly serialize/deserialize data across Java, Python, C++, Go, JavaScript, and Rust"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"\ud83c\udfaf Type-Safe"}),": Compile-time type checking with derive macros"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"\ud83d\udd04 Circular References"}),": Automatic tracking of shared and circular references with ",(0,i.jsx)(n.code,{children:"Rc"}),"/",(0,i.jsx)(n.code,{children:"Arc"})," and weak pointers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"\ud83e\uddec Polymorphic"}),": Serialize trait objects with ",(0,i.jsx)(n.code,{children:"Box<dyn Trait>"}),", ",(0,i.jsx)(n.code,{children:"Rc<dyn Trait>"}),", and ",(0,i.jsx)(n.code,{children:"Arc<dyn Trait>"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"\ud83d\udce6 Schema Evolution"}),": Compatible mode for independent schema changes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"\u26a1 Two Modes"}),": Object graph serialization and zero-copy row-based format"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"-crates",children:"\ud83d\udce6 Crates"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Crate"}),(0,i.jsx)(n.th,{children:"Description"}),(0,i.jsx)(n.th,{children:"Version"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"https://github.com/apache/fory/blob/main/rust/fory",children:(0,i.jsx)(n.code,{children:"fory"})})}),(0,i.jsx)(n.td,{children:"High-level API with derive macros"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"https://crates.io/crates/fory",children:"https://crates.io/crates/fory"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"https://github.com/apache/fory/blob/main/rust/fory-core/",children:(0,i.jsx)(n.code,{children:"fory-core"})})}),(0,i.jsx)(n.td,{children:"Core serialization engine"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"https://crates.io/crates/fory-core",children:"https://crates.io/crates/fory-core"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"https://github.com/apache/fory/blob/main/rust/fory-derive/",children:(0,i.jsx)(n.code,{children:"fory-derive"})})}),(0,i.jsx)(n.td,{children:"Procedural macros"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"https://crates.io/crates/fory-derive",children:"https://crates.io/crates/fory-derive"})})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"-quick-start",children:"\ud83c\udfc3 Quick Start"}),"\n",(0,i.jsxs)(n.p,{children:["Add Apache Fory\u2122 to your ",(0,i.jsx)(n.code,{children:"Cargo.toml"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-toml",children:'[dependencies]\nfory = "0.14"\n'})}),"\n",(0,i.jsx)(n.h3,{id:"basic-example",children:"Basic Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use fory::{Fory, Error, Reader};\nuse fory::ForyObject;\n\n#[derive(ForyObject, Debug, PartialEq)]\nstruct User {\n    name: String,\n    age: i32,\n    email: String,\n}\n\nfn main() -> Result<(), Error> {\n    let mut fory = Fory::default();\n    fory.register::<User>(1)?;\n\n    let user = User {\n        name: "Alice".to_string(),\n        age: 30,\n        email: "alice@example.com".to_string(),\n    };\n\n    // Serialize\n    let bytes = fory.serialize(&user)?;\n    // Deserialize\n    let decoded: User = fory.deserialize(&bytes)?;\n    assert_eq!(user, decoded);\n\n    // Serialize to specified buffer\n    let mut buf: Vec<u8> = vec![];\n    fory.serialize_to(&user, &mut buf)?;\n    // Deserialize from specified buffer\n    let mut reader = Reader::new(&buf);\n    let decoded: User = fory.deserialize_from(&mut reader)?;\n    assert_eq!(user, decoded);\n    Ok(())\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"-core-features",children:"\ud83d\udcda Core Features"}),"\n",(0,i.jsx)(n.h3,{id:"1-object-graph-serialization",children:"1. Object Graph Serialization"}),"\n",(0,i.jsxs)(n.p,{children:["Apache Fory\u2122 provides automatic serialization of complex object graphs, preserving the structure and relationships between objects. The ",(0,i.jsx)(n.code,{children:"#[derive(ForyObject)]"})," macro generates efficient serialization code at compile time, eliminating runtime overhead."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key capabilities:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Nested struct serialization with arbitrary depth"}),"\n",(0,i.jsx)(n.li,{children:"Collection types (Vec, HashMap, HashSet, BTreeMap)"}),"\n",(0,i.jsxs)(n.li,{children:["Optional fields with ",(0,i.jsx)(n.code,{children:"Option<T>"})]}),"\n",(0,i.jsx)(n.li,{children:"Automatic handling of primitive types and strings"}),"\n",(0,i.jsx)(n.li,{children:"Efficient binary encoding with variable-length integers"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use fory::{Fory, Error};\nuse fory::ForyObject;\nuse std::collections::HashMap;\n\n#[derive(ForyObject, Debug, PartialEq)]\nstruct Person {\n    name: String,\n    age: i32,\n    address: Address,\n    hobbies: Vec<String>,\n    metadata: HashMap<String, String>,\n}\n\n#[derive(ForyObject, Debug, PartialEq)]\nstruct Address {\n    street: String,\n    city: String,\n    country: String,\n}\n\nlet mut fory = Fory::default();\nfory.register::<Address>(100);\nfory.register::<Person>(200);\n\nlet person = Person {\n    name: "John Doe".to_string(),\n    age: 30,\n    address: Address {\n        street: "123 Main St".to_string(),\n        city: "New York".to_string(),\n        country: "USA".to_string(),\n    },\n    hobbies: vec!["reading".to_string(), "coding".to_string()],\n    metadata: HashMap::from([\n        ("role".to_string(), "developer".to_string()),\n    ]),\n};\n\nlet bytes = fory.serialize(&person);\nlet decoded: Person = fory.deserialize(&bytes)?;\nassert_eq!(person, decoded);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"2-shared-and-circular-references",children:"2. Shared and Circular References"}),"\n",(0,i.jsxs)(n.p,{children:["Apache Fory\u2122 automatically tracks and preserves reference identity for shared objects using ",(0,i.jsx)(n.code,{children:"Rc<T>"})," and ",(0,i.jsx)(n.code,{children:"Arc<T>"}),". When the same object is referenced multiple times, Fory serializes it only once and uses reference IDs for subsequent occurrences. This ensures:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Space efficiency"}),": No data duplication in serialized output"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reference identity preservation"}),": Deserialized objects maintain the same sharing relationships"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Circular reference support"}),": Use ",(0,i.jsx)(n.code,{children:"RcWeak<T>"})," and ",(0,i.jsx)(n.code,{children:"ArcWeak<T>"})," to break cycles"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"shared-references-with-rcarc",children:"Shared References with Rc/Arc"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use fory::Fory;\nuse std::rc::Rc;\n\nlet fory = Fory::default();\n\n// Create a shared value\nlet shared = Rc::new(String::from("shared_value"));\n\n// Reference it multiple times\nlet data = vec![shared.clone(), shared.clone(), shared.clone()];\n\n// The shared value is serialized only once\nlet bytes = fory.serialize(&data);\nlet decoded: Vec<Rc<String>> = fory.deserialize(&bytes)?;\n\n// Verify reference identity is preserved\nassert_eq!(decoded.len(), 3);\nassert_eq!(*decoded[0], "shared_value");\n\n// All three Rc pointers point to the same object\nassert!(Rc::ptr_eq(&decoded[0], &decoded[1]));\nassert!(Rc::ptr_eq(&decoded[1], &decoded[2]));\n'})}),"\n",(0,i.jsxs)(n.p,{children:["For thread-safe shared references, use ",(0,i.jsx)(n.code,{children:"Arc<T>"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"circular-references-with-weak-pointers",children:"Circular References with Weak Pointers"}),"\n",(0,i.jsxs)(n.p,{children:["To serialize circular references like parent-child relationships or doubly-linked structures, use ",(0,i.jsx)(n.code,{children:"RcWeak<T>"})," or ",(0,i.jsx)(n.code,{children:"ArcWeak<T>"})," to break the cycle. These weak pointers are serialized as references to their strong counterparts, preserving the graph structure without causing memory leaks or infinite recursion."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"How it works:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Weak pointers serialize as references to their target objects"}),"\n",(0,i.jsxs)(n.li,{children:["If the strong pointer has been dropped, weak serializes as ",(0,i.jsx)(n.code,{children:"Null"})]}),"\n",(0,i.jsx)(n.li,{children:"Forward references (weak appearing before target) are resolved via callbacks"}),"\n",(0,i.jsx)(n.li,{children:"All clones of a weak pointer share the same internal cell for automatic updates"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use fory::{Fory, Error};\nuse fory::ForyObject;\nuse fory::RcWeak;\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(ForyObject, Debug)]\nstruct Node {\n    value: i32,\n    parent: RcWeak<RefCell<Node>>,\n    children: Vec<Rc<RefCell<Node>>>,\n}\n\nlet mut fory = Fory::default();\nfory.register::<Node>(2000);\n\n// Build a parent-child tree\nlet parent = Rc::new(RefCell::new(Node {\n    value: 1,\n    parent: RcWeak::new(),\n    children: vec![],\n}));\n\nlet child1 = Rc::new(RefCell::new(Node {\n    value: 2,\n    parent: RcWeak::from(&parent),\n    children: vec![],\n}));\n\nlet child2 = Rc::new(RefCell::new(Node {\n    value: 3,\n    parent: RcWeak::from(&parent),\n    children: vec![],\n}));\n\nparent.borrow_mut().children.push(child1.clone());\nparent.borrow_mut().children.push(child2.clone());\n\n// Serialize and deserialize the circular structure\nlet bytes = fory.serialize(&parent);\nlet decoded: Rc<RefCell<Node>> = fory.deserialize(&bytes)?;\n\n// Verify the circular relationship\nassert_eq!(decoded.borrow().children.len(), 2);\nfor child in &decoded.borrow().children {\n    let upgraded_parent = child.borrow().parent.upgrade().unwrap();\n    assert!(Rc::ptr_eq(&decoded, &upgraded_parent));\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Thread-Safe Circular Graphs with Arc:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use fory::{Fory, Error};\nuse fory::ForyObject;\nuse fory::ArcWeak;\nuse std::sync::{Arc, Mutex};\n\n#[derive(ForyObject)]\nstruct Node {\n    val: i32,\n    parent: ArcWeak<Mutex<Node>>,\n    children: Vec<Arc<Mutex<Node>>>,\n}\n\nlet mut fory = Fory::default();\nfory.register::<Node>(6000);\n\nlet parent = Arc::new(Mutex::new(Node {\n    val: 10,\n    parent: ArcWeak::new(),\n    children: vec![],\n}));\n\nlet child1 = Arc::new(Mutex::new(Node {\n    val: 20,\n    parent: ArcWeak::from(&parent),\n    children: vec![],\n}));\n\nlet child2 = Arc::new(Mutex::new(Node {\n    val: 30,\n    parent: ArcWeak::from(&parent),\n    children: vec![],\n}));\n\nparent.lock().unwrap().children.push(child1.clone());\nparent.lock().unwrap().children.push(child2.clone());\n\nlet bytes = fory.serialize(&parent);\nlet decoded: Arc<Mutex<Node>> = fory.deserialize(&bytes)?;\n\nassert_eq!(decoded.lock().unwrap().children.len(), 2);\nfor child in &decoded.lock().unwrap().children {\n    let upgraded_parent = child.lock().unwrap().parent.upgrade().unwrap();\n    assert!(Arc::ptr_eq(&decoded, &upgraded_parent));\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-trait-object-serialization",children:"3. Trait Object Serialization"}),"\n",(0,i.jsx)(n.p,{children:"Apache Fory\u2122 supports polymorphic serialization through trait objects, enabling dynamic dispatch and type flexibility. This is essential for plugin systems, heterogeneous collections, and extensible architectures."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Supported trait object types:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Box<dyn Trait>"})," - Owned trait objects"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Rc<dyn Trait>"})," - Reference-counted trait objects"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Arc<dyn Trait>"})," - Thread-safe reference-counted trait objects"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Vec<Box<dyn Trait>>"}),", ",(0,i.jsx)(n.code,{children:"HashMap<K, Box<dyn Trait>>"})," - Collections of trait objects"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"basic-trait-object-serialization",children:"Basic Trait Object Serialization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use fory::{Fory, register_trait_type};\nuse fory::Serializer;\nuse fory::ForyObject;\n\ntrait Animal: Serializer {\n    fn speak(&self) -> String;\n    fn name(&self) -> &str;\n}\n\n#[derive(ForyObject)]\nstruct Dog { name: String, breed: String }\n\nimpl Animal for Dog {\n    fn speak(&self) -> String { "Woof!".to_string() }\n    fn name(&self) -> &str { &self.name }\n}\n\n#[derive(ForyObject)]\nstruct Cat { name: String, color: String }\n\nimpl Animal for Cat {\n    fn speak(&self) -> String { "Meow!".to_string() }\n    fn name(&self) -> &str { &self.name }\n}\n\n// Register trait implementations\nregister_trait_type!(Animal, Dog, Cat);\n\n#[derive(ForyObject)]\nstruct Zoo {\n    star_animal: Box<dyn Animal>,\n}\n\nlet mut fory = Fory::default().compatible(true);\nfory.register::<Dog>(100);\nfory.register::<Cat>(101);\nfory.register::<Zoo>(102);\n\nlet zoo = Zoo {\n    star_animal: Box::new(Dog {\n        name: "Buddy".to_string(),\n        breed: "Labrador".to_string(),\n    }),\n};\n\nlet bytes = fory.serialize(&zoo);\nlet decoded: Zoo = fory.deserialize(&bytes)?;\n\nassert_eq!(decoded.star_animal.name(), "Buddy");\nassert_eq!(decoded.star_animal.speak(), "Woof!");\n'})}),"\n",(0,i.jsxs)(n.h4,{id:"serializing-dyn-any-trait-objects",children:["Serializing ",(0,i.jsx)(n.code,{children:"dyn Any"})," Trait Objects"]}),"\n",(0,i.jsxs)(n.p,{children:["Apache Fory\u2122 supports serializing ",(0,i.jsx)(n.code,{children:"Rc<dyn Any>"})," and ",(0,i.jsx)(n.code,{children:"Arc<dyn Any>"})," for runtime type dispatch. This is useful when you need maximum flexibility and don't want to define a custom trait."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key points:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Works with any type that implements ",(0,i.jsx)(n.code,{children:"Serializer"})]}),"\n",(0,i.jsx)(n.li,{children:"Requires downcasting after deserialization to access the concrete type"}),"\n",(0,i.jsx)(n.li,{children:"Type information is preserved during serialization"}),"\n",(0,i.jsx)(n.li,{children:"Useful for plugin systems and dynamic type handling"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use std::rc::Rc;\nuse std::any::Any;\n\nlet dog_rc: Rc<dyn Animal> = Rc::new(Dog {\n    name: "Rex".to_string(),\n    breed: "Golden".to_string()\n});\n\n// Convert to Rc<dyn Any> for serialization\nlet dog_any: Rc<dyn Any> = dog_rc.clone();\n\n// Serialize the Any wrapper\nlet bytes = fory.serialize(&dog_any);\nlet decoded: Rc<dyn Any> = fory.deserialize(&bytes)?;\n\n// Downcast back to the concrete type\nlet unwrapped = decoded.downcast_ref::<Dog>().unwrap();\nassert_eq!(unwrapped.name, "Rex");\n'})}),"\n",(0,i.jsxs)(n.p,{children:["For thread-safe scenarios, use ",(0,i.jsx)(n.code,{children:"Arc<dyn Any>"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use std::sync::Arc;\nuse std::any::Any;\n\nlet dog_arc: Arc<dyn Animal> = Arc::new(Dog {\n    name: "Buddy".to_string(),\n    breed: "Labrador".to_string()\n});\n\n// Convert to Arc<dyn Any>\nlet dog_any: Arc<dyn Any> = dog_arc.clone();\n\nlet bytes = fory.serialize(&dog_any);\nlet decoded: Arc<dyn Any> = fory.deserialize(&bytes)?;\n\n// Downcast to concrete type\nlet unwrapped = decoded.downcast_ref::<Dog>().unwrap();\nassert_eq!(unwrapped.name, "Buddy");\n'})}),"\n",(0,i.jsx)(n.h4,{id:"rcarc-based-trait-objects-in-structs",children:"Rc/Arc-Based Trait Objects in Structs"}),"\n",(0,i.jsxs)(n.p,{children:["For fields with ",(0,i.jsx)(n.code,{children:"Rc<dyn Trait>"})," or ",(0,i.jsx)(n.code,{children:"Arc<dyn Trait>"}),", Fory automatically handles the conversion:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use std::sync::Arc;\nuse std::rc::Rc;\nuse std::collections::HashMap;\n\n#[derive(ForyObject)]\nstruct AnimalShelter {\n    animals_rc: Vec<Rc<dyn Animal>>,\n    animals_arc: Vec<Arc<dyn Animal>>,\n    registry: HashMap<String, Arc<dyn Animal>>,\n}\n\nlet mut fory = Fory::default().compatible(true);\nfory.register::<Dog>(100);\nfory.register::<Cat>(101);\nfory.register::<AnimalShelter>(102);\n\nlet shelter = AnimalShelter {\n    animals_rc: vec![\n        Rc::new(Dog { name: "Rex".to_string(), breed: "Golden".to_string() }),\n        Rc::new(Cat { name: "Mittens".to_string(), color: "Gray".to_string() }),\n    ],\n    animals_arc: vec![\n        Arc::new(Dog { name: "Buddy".to_string(), breed: "Labrador".to_string() }),\n    ],\n    registry: HashMap::from([\n        ("pet1".to_string(), Arc::new(Dog {\n            name: "Max".to_string(),\n            breed: "Shepherd".to_string()\n        }) as Arc<dyn Animal>),\n    ]),\n};\n\nlet bytes = fory.serialize(&shelter);\nlet decoded: AnimalShelter = fory.deserialize(&bytes)?;\n\nassert_eq!(decoded.animals_rc[0].name(), "Rex");\nassert_eq!(decoded.animals_arc[0].speak(), "Woof!");\n'})}),"\n",(0,i.jsx)(n.h4,{id:"standalone-trait-object-serialization",children:"Standalone Trait Object Serialization"}),"\n",(0,i.jsxs)(n.p,{children:["Due to Rust's orphan rule, ",(0,i.jsx)(n.code,{children:"Rc<dyn Trait>"})," and ",(0,i.jsx)(n.code,{children:"Arc<dyn Trait>"})," cannot implement ",(0,i.jsx)(n.code,{children:"Serializer"})," directly. For standalone serialization (not inside struct fields), the ",(0,i.jsx)(n.code,{children:"register_trait_type!"})," macro generates wrapper types."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," If you don't want to use wrapper types, you can serialize as ",(0,i.jsx)(n.code,{children:"Rc<dyn Any>"})," or ",(0,i.jsx)(n.code,{children:"Arc<dyn Any>"})," instead (see the ",(0,i.jsx)(n.code,{children:"dyn Any"})," section above)."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"register_trait_type!"})," macro generates ",(0,i.jsx)(n.code,{children:"AnimalRc"})," and ",(0,i.jsx)(n.code,{children:"AnimalArc"})," wrapper types:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// For Rc<dyn Trait>\nlet dog_rc: Rc<dyn Animal> = Rc::new(Dog {\n    name: "Rex".to_string(),\n    breed: "Golden".to_string()\n});\nlet wrapper = AnimalRc::from(dog_rc);\n\nlet bytes = fory.serialize(&wrapper);\nlet decoded: AnimalRc = fory.deserialize(&bytes)?;\n\n// Unwrap back to Rc<dyn Animal>\nlet unwrapped: Rc<dyn Animal> = decoded.unwrap();\nassert_eq!(unwrapped.name(), "Rex");\n\n// For Arc<dyn Trait>\nlet dog_arc: Arc<dyn Animal> = Arc::new(Dog {\n    name: "Buddy".to_string(),\n    breed: "Labrador".to_string()\n});\nlet wrapper = AnimalArc::from(dog_arc);\n\nlet bytes = fory.serialize(&wrapper);\nlet decoded: AnimalArc = fory.deserialize(&bytes)?;\n\nlet unwrapped: Arc<dyn Animal> = decoded.unwrap();\nassert_eq!(unwrapped.name(), "Buddy");\n'})}),"\n",(0,i.jsx)(n.h3,{id:"4-schema-evolution",children:"4. Schema Evolution"}),"\n",(0,i.jsxs)(n.p,{children:["Apache Fory\u2122 supports schema evolution in ",(0,i.jsx)(n.strong,{children:"Compatible mode"}),", allowing serialization and deserialization peers to have different type definitions. This enables independent evolution of services in distributed systems without breaking compatibility."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Features:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Add new fields with default values"}),"\n",(0,i.jsx)(n.li,{children:"Remove obsolete fields (skipped during deserialization)"}),"\n",(0,i.jsxs)(n.li,{children:["Change field nullability (",(0,i.jsx)(n.code,{children:"T"})," \u2194 ",(0,i.jsx)(n.code,{children:"Option<T>"}),")"]}),"\n",(0,i.jsx)(n.li,{children:"Reorder fields (matched by name, not position)"}),"\n",(0,i.jsx)(n.li,{children:"Type-safe fallback to default values for missing fields"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Compatibility rules:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Field names must match (case-sensitive)"}),"\n",(0,i.jsx)(n.li,{children:"Type changes are not supported (except nullable/non-nullable)"}),"\n",(0,i.jsx)(n.li,{children:"Nested struct types must be registered on both sides"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use fory::Fory;\nuse fory::ForyObject;\nuse std::collections::HashMap;\n\n#[derive(ForyObject, Debug)]\nstruct PersonV1 {\n    name: String,\n    age: i32,\n    address: String,\n}\n\n#[derive(ForyObject, Debug)]\nstruct PersonV2 {\n    name: String,\n    age: i32,\n    // address removed\n    // phone added\n    phone: Option<String>,\n    metadata: HashMap<String, String>,\n}\n\nlet mut fory1 = Fory::default().compatible(true);\nfory1.register::<PersonV1>(1);\n\nlet mut fory2 = Fory::default().compatible(true);\nfory2.register::<PersonV2>(1);\n\nlet person_v1 = PersonV1 {\n    name: "Alice".to_string(),\n    age: 30,\n    address: "123 Main St".to_string(),\n};\n\n// Serialize with V1\nlet bytes = fory1.serialize(&person_v1);\n\n// Deserialize with V2 - missing fields get default values\nlet person_v2: PersonV2 = fory2.deserialize(&bytes)?;\nassert_eq!(person_v2.name, "Alice");\nassert_eq!(person_v2.age, 30);\nassert_eq!(person_v2.phone, None);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"5-enum-support",children:"5. Enum Support"}),"\n",(0,i.jsx)(n.p,{children:"Apache Fory\u2122 supports three types of enum variants with full schema evolution in Compatible mode:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Variant Types:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Unit"}),": C-style enums (",(0,i.jsx)(n.code,{children:"Status::Active"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Unnamed"}),": Tuple-like variants (",(0,i.jsx)(n.code,{children:"Message::Pair(String, i32)"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Named"}),": Struct-like variants (",(0,i.jsx)(n.code,{children:"Event::Click { x: i32, y: i32 }"}),")"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Features:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Efficient varint encoding for variant ordinals"}),"\n",(0,i.jsx)(n.li,{children:"Schema evolution support (add/remove variants, add/remove fields)"}),"\n",(0,i.jsxs)(n.li,{children:["Default variant support with ",(0,i.jsx)(n.code,{children:"#[default]"})]}),"\n",(0,i.jsx)(n.li,{children:"Automatic type mismatch handling"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use fory::{Fory, ForyObject};\n\n#[derive(Default, ForyObject, Debug, PartialEq)]\nenum Value {\n    #[default]\n    Null,\n    Bool(bool),\n    Number(f64),\n    Text(String),\n    Object { name: String, value: i32 },\n}\n\nlet mut fory = Fory::default();\nfory.register::<Value>(1)?;\n\nlet value = Value::Object { name: "score".to_string(), value: 100 };\nlet bytes = fory.serialize(&value)?;\nlet decoded: Value = fory.deserialize(&bytes)?;\nassert_eq!(value, decoded);\n'})}),"\n",(0,i.jsx)(n.h4,{id:"schema-evolution",children:"Schema Evolution"}),"\n",(0,i.jsx)(n.p,{children:"Compatible mode enables robust schema evolution with variant type encoding (2 bits):"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"0b0"})," = Unit, ",(0,i.jsx)(n.code,{children:"0b1"})," = Unnamed, ",(0,i.jsx)(n.code,{children:"0b10"})," = Named"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use fory::{Fory, ForyObject};\n\n// Old version\n#[derive(ForyObject)]\nenum OldEvent {\n    Click { x: i32, y: i32 },\n    Scroll { delta: f64 },\n}\n\n// New version - added field and variant\n#[derive(Default, ForyObject)]\nenum NewEvent {\n    #[default]\n    Unknown,\n    Click { x: i32, y: i32, timestamp: u64 },  // Added field\n    Scroll { delta: f64 },\n    KeyPress(String),  // New variant\n}\n\nlet mut fory = Fory::builder().compatible().build();\n\n// Serialize with old schema\nlet old_bytes = fory.serialize(&OldEvent::Click { x: 100, y: 200 })?;\n\n// Deserialize with new schema - timestamp gets default value (0)\nlet new_event: NewEvent = fory.deserialize(&old_bytes)?;\nassert!(matches!(new_event, NewEvent::Click { x: 100, y: 200, timestamp: 0 }));\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Evolution capabilities:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Unknown variants"})," \u2192 Falls back to default variant"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Named variant fields"})," \u2192 Add/remove fields (missing fields use defaults)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Unnamed variant elements"})," \u2192 Add/remove elements (extras skipped, missing use defaults)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Variant type mismatches"})," \u2192 Automatically uses default value for current variant"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Best practices:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Always mark a default variant with ",(0,i.jsx)(n.code,{children:"#[default]"})]}),"\n",(0,i.jsx)(n.li,{children:"Named variants provide better evolution than unnamed"}),"\n",(0,i.jsx)(n.li,{children:"Use compatible mode for cross-version communication"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"6-tuple-support",children:"6. Tuple Support"}),"\n",(0,i.jsx)(n.p,{children:"Apache Fory\u2122 supports tuples up to 22 elements out of the box with efficient serialization in both compatible and non-compatible modes."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Features:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Automatic serialization for tuples from 1 to 22 elements"}),"\n",(0,i.jsx)(n.li,{children:"Heterogeneous type support (each element can be a different type)"}),"\n",(0,i.jsx)(n.li,{children:"Schema evolution in Compatible mode (handles missing/extra elements)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Serialization modes:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Non-compatible mode"}),": Serializes elements sequentially without collection headers for minimal overhead"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compatible mode"}),": Uses collection protocol with type metadata for schema evolution"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use fory::{Fory, Error};\n\nlet mut fory = Fory::default();\n\n// Tuple with heterogeneous types\nlet data: (i32, String, bool, Vec<i32>) = (\n    42,\n    "hello".to_string(),\n    true,\n    vec![1, 2, 3],\n);\n\nlet bytes = fory.serialize(&data)?;\nlet decoded: (i32, String, bool, Vec<i32>) = fory.deserialize(&bytes)?;\nassert_eq!(data, decoded);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"7-custom-serializers",children:"7. Custom Serializers"}),"\n",(0,i.jsxs)(n.p,{children:["For types that don't support ",(0,i.jsx)(n.code,{children:"#[derive(ForyObject)]"}),", implement the ",(0,i.jsx)(n.code,{children:"Serializer"})," trait manually. This is useful for:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"External types from other crates"}),"\n",(0,i.jsx)(n.li,{children:"Types with special serialization requirements"}),"\n",(0,i.jsx)(n.li,{children:"Legacy data format compatibility"}),"\n",(0,i.jsx)(n.li,{children:"Performance-critical custom encoding"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use fory::{Fory, ReadContext, WriteContext, Serializer, ForyDefault, Error};\nuse std::any::Any;\n\n#[derive(Debug, PartialEq)]\nstruct CustomType {\n    value: i32,\n    name: String,\n}\n\nimpl Serializer for CustomType {\n    fn fory_write_data(&self, context: &mut WriteContext, is_field: bool) {\n        context.writer.write_i32(self.value);\n        context.writer.write_varuint32(self.name.len() as u32);\n        context.writer.write_utf8_string(&self.name);\n    }\n\n    fn fory_read_data(context: &mut ReadContext, is_field: bool) -> Result<Self, Error> {\n        let value = context.reader.read_i32();\n        let len = context.reader.read_varuint32() as usize;\n        let name = context.reader.read_utf8_string(len);\n        Ok(Self { value, name })\n    }\n\n    fn fory_type_id_dyn(&self, type_resolver: &TypeResolver) -> u32 {\n        Self::fory_get_type_id(type_resolver)\n    }\n\n    fn as_any(&self) -> &dyn Any {\n        self\n    }\n}\n\nimpl ForyDefault for CustomType {\n    fn fory_default() -> Self {\n        Self::default()\n    }\n}\n\nlet mut fory = Fory::default();\nfory.register_serializer::<CustomType>(100);\n\nlet custom = CustomType {\n    value: 42,\n    name: "test".to_string(),\n};\nlet bytes = fory.serialize(&custom);\nlet decoded: CustomType = fory.deserialize(&bytes)?;\nassert_eq!(custom, decoded);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"7-row-based-serialization",children:"7. Row-Based Serialization"}),"\n",(0,i.jsxs)(n.p,{children:["Apache Fory\u2122 provides a high-performance ",(0,i.jsx)(n.strong,{children:"row format"})," for zero-copy deserialization. Unlike traditional object serialization that reconstructs entire objects in memory, row format enables ",(0,i.jsx)(n.strong,{children:"random access"})," to fields directly from binary data without full deserialization."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key benefits:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Zero-copy access"}),": Read fields without allocating or copying data"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Partial deserialization"}),": Access only the fields you need"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Memory-mapped files"}),": Work with data larger than RAM"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cache-friendly"}),": Sequential memory layout for better CPU cache utilization"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Lazy evaluation"}),": Defer expensive operations until field access"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"When to use row format:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Analytics workloads with selective field access"}),"\n",(0,i.jsx)(n.li,{children:"Large datasets where only a subset of fields is needed"}),"\n",(0,i.jsx)(n.li,{children:"Memory-constrained environments"}),"\n",(0,i.jsx)(n.li,{children:"High-throughput data pipelines"}),"\n",(0,i.jsx)(n.li,{children:"Reading from memory-mapped files or shared memory"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"How it works:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Fields are encoded in a binary row with fixed offsets for primitives"}),"\n",(0,i.jsx)(n.li,{children:"Variable-length data (strings, collections) stored with offset pointers"}),"\n",(0,i.jsx)(n.li,{children:"Null bitmap tracks which fields are present"}),"\n",(0,i.jsx)(n.li,{children:"Nested structures supported through recursive row encoding"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use fory::{to_row, from_row};\nuse fory::ForyRow;\nuse std::collections::BTreeMap;\n\n#[derive(ForyRow)]\nstruct UserProfile {\n    id: i64,\n    username: String,\n    email: String,\n    scores: Vec<i32>,\n    preferences: BTreeMap<String, String>,\n    is_active: bool,\n}\n\nlet profile = UserProfile {\n    id: 12345,\n    username: "alice".to_string(),\n    email: "alice@example.com".to_string(),\n    scores: vec![95, 87, 92, 88],\n    preferences: BTreeMap::from([\n        ("theme".to_string(), "dark".to_string()),\n        ("language".to_string(), "en".to_string()),\n    ]),\n    is_active: true,\n};\n\n// Serialize to row format\nlet row_data = to_row(&profile);\n\n// Zero-copy deserialization - no object allocation!\nlet row = from_row::<UserProfile>(&row_data);\n\n// Access fields directly from binary data\nassert_eq!(row.id(), 12345);\nassert_eq!(row.username(), "alice");\nassert_eq!(row.email(), "alice@example.com");\nassert_eq!(row.is_active(), true);\n\n// Access collections efficiently\nlet scores = row.scores();\nassert_eq!(scores.size(), 4);\nassert_eq!(scores.get(0), 95);\nassert_eq!(scores.get(1), 87);\n\nlet prefs = row.preferences();\nassert_eq!(prefs.keys().size(), 2);\nassert_eq!(prefs.keys().get(0), "language");\nassert_eq!(prefs.values().get(0), "en");\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Performance comparison:"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Operation"}),(0,i.jsx)(n.th,{children:"Object Format"}),(0,i.jsx)(n.th,{children:"Row Format"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Full deserialization"}),(0,i.jsx)(n.td,{children:"Allocates all objects"}),(0,i.jsx)(n.td,{children:"Zero allocation"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Single field access"}),(0,i.jsx)(n.td,{children:"Full deserialization required"}),(0,i.jsx)(n.td,{children:"Direct offset read"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Memory usage"}),(0,i.jsx)(n.td,{children:"Full object graph in memory"}),(0,i.jsx)(n.td,{children:"Only accessed fields in memory"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Suitable for"}),(0,i.jsx)(n.td,{children:"Small objects, full access"}),(0,i.jsx)(n.td,{children:"Large objects, selective access"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"8-thread-safe-serialization",children:"8. Thread-Safe Serialization"}),"\n",(0,i.jsxs)(n.p,{children:["Apache Fory\u2122 Rust is fully thread-safe: ",(0,i.jsx)(n.code,{children:"Fory"})," implements both ",(0,i.jsx)(n.code,{children:"Send"})," and ",(0,i.jsx)(n.code,{children:"Sync"}),", so one configured instance can be shared across threads for concurrent work. The internal read/write context pools are lazily initialized with thread-safe primitives, letting worker threads reuse buffers without coordination."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use fory::{Fory, Error};\nuse fory::ForyObject;\nuse std::sync::Arc;\nuse std::thread;\n\n#[derive(ForyObject, Clone, Copy, Debug, PartialEq)]\nstruct Item {\n    value: i32,\n}\n\nfn main() -> Result<(), Error> {\n    let mut fory = Fory::default();\n    fory.register::<Item>(1000)?;\n\n    let fory = Arc::new(fory);\n    let handles: Vec<_> = (0..8)\n        .map(|i| {\n            let shared = Arc::clone(&fory);\n            thread::spawn(move || {\n                let item = Item { value: i };\n                shared.serialize(&item)\n            })\n        })\n        .collect();\n\n    for handle in handles {\n        let bytes = handle.join().unwrap()?;\n        let item: Item = fory.deserialize(&bytes)?;\n        assert!(item.value >= 0);\n    }\n\n    Ok(())\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Tip:"})," Perform registrations (such as ",(0,i.jsx)(n.code,{children:"fory.register::<T>(id)"}),") before spawning threads so every worker sees the same metadata. Once configured, wrapping the instance in ",(0,i.jsx)(n.code,{children:"Arc"})," is enough to fan out serialization and deserialization tasks safely."]}),"\n",(0,i.jsx)(n.h2,{id:"-supported-types",children:"\ud83d\udd27 Supported Types"}),"\n",(0,i.jsx)(n.h3,{id:"primitive-types",children:"Primitive Types"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Rust Type"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"bool"})}),(0,i.jsx)(n.td,{children:"Boolean"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"i8"}),", ",(0,i.jsx)(n.code,{children:"i16"}),", ",(0,i.jsx)(n.code,{children:"i32"}),", ",(0,i.jsx)(n.code,{children:"i64"})]}),(0,i.jsx)(n.td,{children:"Signed integers"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"f32"}),", ",(0,i.jsx)(n.code,{children:"f64"})]}),(0,i.jsx)(n.td,{children:"Floating point"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"String"})}),(0,i.jsx)(n.td,{children:"UTF-8 string"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"collections",children:"Collections"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Rust Type"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Vec<T>"})}),(0,i.jsx)(n.td,{children:"Dynamic array"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"VecDeque<T>"})}),(0,i.jsx)(n.td,{children:"Double-ended queue"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"LinkedList<T>"})}),(0,i.jsx)(n.td,{children:"Doubly-linked list"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"HashMap<K, V>"})}),(0,i.jsx)(n.td,{children:"Hash map"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"BTreeMap<K, V>"})}),(0,i.jsx)(n.td,{children:"Ordered map"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"HashSet<T>"})}),(0,i.jsx)(n.td,{children:"Hash set"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"BTreeSet<T>"})}),(0,i.jsx)(n.td,{children:"Ordered set"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"BinaryHeap<T>"})}),(0,i.jsx)(n.td,{children:"Binary heap"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Option<T>"})}),(0,i.jsx)(n.td,{children:"Optional value"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"smart-pointers",children:"Smart Pointers"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Rust Type"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Box<T>"})}),(0,i.jsx)(n.td,{children:"Heap allocation"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Rc<T>"})}),(0,i.jsx)(n.td,{children:"Reference counting (shared refs tracked)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Arc<T>"})}),(0,i.jsx)(n.td,{children:"Thread-safe reference counting (shared refs tracked)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"RcWeak<T>"})}),(0,i.jsxs)(n.td,{children:["Weak reference to ",(0,i.jsx)(n.code,{children:"Rc<T>"})," (breaks circular refs)"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ArcWeak<T>"})}),(0,i.jsxs)(n.td,{children:["Weak reference to ",(0,i.jsx)(n.code,{children:"Arc<T>"})," (breaks circular refs)"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"RefCell<T>"})}),(0,i.jsx)(n.td,{children:"Interior mutability (runtime borrow checking)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Mutex<T>"})}),(0,i.jsx)(n.td,{children:"Thread-safe interior mutability"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"date-and-time",children:"Date and Time"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Rust Type"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"chrono::NaiveDate"})}),(0,i.jsx)(n.td,{children:"Date without timezone"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"chrono::NaiveDateTime"})}),(0,i.jsx)(n.td,{children:"Timestamp without timezone"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"custom-types",children:"Custom Types"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Macro"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"#[derive(ForyObject)]"})}),(0,i.jsx)(n.td,{children:"Object graph serialization"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"#[derive(ForyRow)]"})}),(0,i.jsx)(n.td,{children:"Row-based serialization"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"-cross-language-serialization",children:"\ud83c\udf0d Cross-Language Serialization"}),"\n",(0,i.jsx)(n.p,{children:"Apache Fory\u2122 supports seamless data exchange across multiple languages:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use fory::Fory;\n\n// Enable cross-language mode\nlet mut fory = Fory::default()\n    .compatible(true)\n    .xlang(true);\n\n// Register types with consistent IDs across languages\nfory.register::<MyStruct>(100);\n\n// Or use namespace-based registration\nfory.register_by_namespace::<MyStruct>("com.example", "MyStruct");\n'})}),"\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.a,{href:"https://fory.apache.org/docs/specification/xlang_type_mapping",children:"xlang_type_mapping.md"})," for type mapping across languages."]}),"\n",(0,i.jsx)(n.h2,{id:"-performance",children:"\u26a1 Performance"}),"\n",(0,i.jsx)(n.p,{children:"Apache Fory\u2122 Rust is designed for maximum performance:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Zero-Copy Deserialization"}),": Row format enables direct memory access without copying"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Buffer Pre-allocation"}),": Minimizes memory allocations during serialization"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compact Encoding"}),": Variable-length encoding for space efficiency"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Little-Endian"}),": Optimized for modern CPU architectures"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reference Deduplication"}),": Shared objects serialized only once"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Run benchmarks:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cd benchmarks/rust_benchmark\ncargo bench\n"})}),"\n",(0,i.jsx)(n.h2,{id:"-documentation",children:"\ud83d\udcd6 Documentation"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://docs.rs/fory",children:"API Documentation"})})," - Complete API reference"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://fory.apache.org/docs/specification/fory_xlang_serialization_spec",children:"Protocol Specification"})})," - Serialization protocol details"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://fory.apache.org/docs/guide/xlang_type_mapping",children:"Type Mapping"})})," - Cross-language type mappings"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"-use-cases",children:"\ud83c\udfaf Use Cases"}),"\n",(0,i.jsx)(n.h3,{id:"object-serialization",children:"Object Serialization"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Complex data structures with nested objects and references"}),"\n",(0,i.jsx)(n.li,{children:"Cross-language communication in microservices"}),"\n",(0,i.jsx)(n.li,{children:"General-purpose serialization with full type safety"}),"\n",(0,i.jsx)(n.li,{children:"Schema evolution with compatible mode"}),"\n",(0,i.jsx)(n.li,{children:"Graph-like data structures with circular references"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"row-based-serialization",children:"Row-Based Serialization"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"High-throughput data processing"}),"\n",(0,i.jsx)(n.li,{children:"Analytics workloads requiring fast field access"}),"\n",(0,i.jsx)(n.li,{children:"Memory-constrained environments"}),"\n",(0,i.jsx)(n.li,{children:"Real-time data streaming applications"}),"\n",(0,i.jsx)(n.li,{children:"Zero-copy scenarios"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"\ufe0f-architecture",children:"\ud83c\udfd7\ufe0f Architecture"}),"\n",(0,i.jsx)(n.p,{children:"The Rust implementation consists of three main crates:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"fory/                   # High-level API\n\u251c\u2500\u2500 src/lib.rs         # Public API exports\n\nfory-core/             # Core serialization engine\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 fory.rs       # Main serialization entry point\n\u2502   \u251c\u2500\u2500 buffer.rs     # Binary buffer management\n\u2502   \u251c\u2500\u2500 serializer/   # Type-specific serializers\n\u2502   \u251c\u2500\u2500 resolver/     # Type resolution and metadata\n\u2502   \u251c\u2500\u2500 meta/         # Meta string compression\n\u2502   \u251c\u2500\u2500 row/          # Row format implementation\n\u2502   \u2514\u2500\u2500 types.rs      # Type definitions\n\nfory-derive/           # Procedural macros\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 object/       # ForyObject macro\n\u2502   \u2514\u2500\u2500 fory_row.rs  # ForyRow macro\n"})}),"\n",(0,i.jsx)(n.h2,{id:"-serialization-modes",children:"\ud83d\udd04 Serialization Modes"}),"\n",(0,i.jsx)(n.p,{children:"Apache Fory\u2122 supports two serialization modes:"}),"\n",(0,i.jsx)(n.h3,{id:"schemaconsistent-mode-default",children:"SchemaConsistent Mode (Default)"}),"\n",(0,i.jsx)(n.p,{children:"Type declarations must match exactly between peers:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let fory = Fory::default(); // SchemaConsistent by default\n"})}),"\n",(0,i.jsx)(n.h3,{id:"compatible-mode",children:"Compatible Mode"}),"\n",(0,i.jsx)(n.p,{children:"Allows independent schema evolution:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let fory = Fory::default().compatible(true);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"\ufe0f-configuration",children:"\u2699\ufe0f Configuration"}),"\n",(0,i.jsx)(n.h3,{id:"maximum-dynamic-object-nesting-depth",children:"Maximum Dynamic Object Nesting Depth"}),"\n",(0,i.jsx)(n.p,{children:"Apache Fory\u2122 provides protection against stack overflow from deeply nested dynamic objects during deserialization. By default, the maximum nesting depth is set to 5 levels for trait objects and containers."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Default configuration:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let fory = Fory::default(); // max_dyn_depth = 5\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Custom depth limit:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let fory = Fory::default().max_dyn_depth(10); // Allow up to 10 levels\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"When to adjust:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Increase"}),": For legitimate deeply nested data structures"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Decrease"}),": For stricter security requirements or shallow data structures"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Protected types:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Box<dyn Any>"}),", ",(0,i.jsx)(n.code,{children:"Rc<dyn Any>"}),", ",(0,i.jsx)(n.code,{children:"Arc<dyn Any>"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Box<dyn Trait>"}),", ",(0,i.jsx)(n.code,{children:"Rc<dyn Trait>"}),", ",(0,i.jsx)(n.code,{children:"Arc<dyn Trait>"})," (trait objects)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"RcWeak<T>"}),", ",(0,i.jsx)(n.code,{children:"ArcWeak<T>"})]}),"\n",(0,i.jsx)(n.li,{children:"Collection types (Vec, HashMap, HashSet)"}),"\n",(0,i.jsx)(n.li,{children:"Nested struct types in Compatible mode"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Note: Static data types (non-dynamic types) are secure by nature and not subject to depth limits, as their structure is known at compile time."}),"\n",(0,i.jsx)(n.h2,{id:"-troubleshooting",children:"\ud83e\uddea Troubleshooting"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type registry errors"}),": An error like ",(0,i.jsx)(n.code,{children:"TypeId ... not found in type_info registry"})," means the type was never registered with the current ",(0,i.jsx)(n.code,{children:"Fory"})," instance. Confirm that every serializable struct or trait implementation calls ",(0,i.jsx)(n.code,{children:"fory.register::<T>(type_id)"})," before serialization and that the same IDs are reused on the deserialize side."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Quick error lookup"}),": Prefer the static constructors on ",(0,i.jsx)(n.code,{children:"fory_core::error::Error"})," (",(0,i.jsx)(n.code,{children:"Error::type_mismatch"}),", ",(0,i.jsx)(n.code,{children:"Error::invalid_data"}),", ",(0,i.jsx)(n.code,{children:"Error::unknown"}),", etc.) rather than instantiating variants manually. This keeps diagnostics consistent and makes opt-in panics work."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Panic on error for backtraces"}),": Toggle ",(0,i.jsx)(n.code,{children:"FORY_PANIC_ON_ERROR=1"})," (or ",(0,i.jsx)(n.code,{children:"true"}),") alongside ",(0,i.jsx)(n.code,{children:"RUST_BACKTRACE=1"})," when running tests or binaries to panic at the exact site an error is constructed. Reset the variable afterwards to avoid aborting user-facing code paths."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Struct field tracing"}),": Add the ",(0,i.jsx)(n.code,{children:"#[fory_debug]"})," attribute alongside ",(0,i.jsx)(n.code,{children:"#[derive(ForyObject)]"})," to tell the macro to emit hook invocations for that type. Once compiled with debug hooks, call ",(0,i.jsx)(n.code,{children:"set_before_write_field_func"}),", ",(0,i.jsx)(n.code,{children:"set_after_write_field_func"}),", ",(0,i.jsx)(n.code,{children:"set_before_read_field_func"}),", or ",(0,i.jsx)(n.code,{children:"set_after_read_field_func"})," (from ",(0,i.jsx)(n.code,{children:"fory-core/src/serializer/struct_.rs"}),") to plug in custom callbacks, and use ",(0,i.jsx)(n.code,{children:"reset_struct_debug_hooks()"})," when you want the defaults back."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Lightweight logging"}),": Without custom hooks, enable ",(0,i.jsx)(n.code,{children:"ENABLE_FORY_DEBUG_OUTPUT=1"})," to print field-level read/write events emitted by the default hook functions. This is especially useful when investigating alignment or cursor mismatches."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Test-time hygiene"}),": Some integration tests expect ",(0,i.jsx)(n.code,{children:"FORY_PANIC_ON_ERROR"})," to remain unset. Export it only for focused debugging sessions, and prefer ",(0,i.jsx)(n.code,{children:"cargo test --features tests -p tests --test <case>"})," when isolating failing scenarios."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"\ufe0f-development",children:"\ud83d\udee0\ufe0f Development"}),"\n",(0,i.jsx)(n.h3,{id:"building",children:"Building"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cd rust\ncargo build\n"})}),"\n",(0,i.jsx)(n.h3,{id:"testing",children:"Testing"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Run all tests\ncargo test --features tests\n\n# Run specific test\ncargo test -p tests --test test_complex_struct\n"})}),"\n",(0,i.jsx)(n.h3,{id:"code-quality",children:"Code Quality"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Format code\ncargo fmt\n\n# Check formatting\ncargo fmt --check\n\n# Run linter\ncargo clippy --all-targets --all-features -- -D warnings\n"})}),"\n",(0,i.jsx)(n.h2,{id:"\ufe0f-roadmap",children:"\ud83d\uddfa\ufe0f Roadmap"}),"\n",(0,i.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","Static codegen based on rust macro"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","Row format serialization"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","Cross-language object graph serialization"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","Shared and circular reference tracking"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","Weak pointer support"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","Trait object serialization with polymorphism"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","Schema evolution in compatible mode"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","SIMD optimizations for string encoding"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Cross-language support for shared and circular reference tracking"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Cross-language support for trait objects"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Performance optimizations"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","More comprehensive benchmarks"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"-license",children:"\ud83d\udcc4 License"}),"\n",(0,i.jsxs)(n.p,{children:["Licensed under the Apache License, Version 2.0. See ",(0,i.jsx)(n.a,{href:"https://github.com/apache/fory/blob/main/LICENSE",children:"LICENSE"})," for details."]}),"\n",(0,i.jsx)(n.h2,{id:"-contributing",children:"\ud83e\udd1d Contributing"}),"\n",(0,i.jsxs)(n.p,{children:["We welcome contributions! Please see our ",(0,i.jsx)(n.a,{href:"https://github.com/apache/fory/blob/main/CONTRIBUTING.md",children:"Contributing Guide"})," for details."]}),"\n",(0,i.jsx)(n.h2,{id:"-support",children:"\ud83d\udcde Support"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Documentation"}),": ",(0,i.jsx)(n.a,{href:"https://docs.rs/fory",children:"docs.rs/fory"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Issues"}),": ",(0,i.jsx)(n.a,{href:"https://github.com/apache/fory/issues",children:"GitHub Issues"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Discussions"}),": ",(0,i.jsx)(n.a,{href:"https://github.com/apache/fory/discussions",children:"GitHub Discussions"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Slack"}),": ",(0,i.jsx)(n.a,{href:"https://join.slack.com/t/fory-project/shared_invite/zt-1u8soj4qc-ieYEu7ciHOqA2mo47llS8A",children:"Apache Fory Slack"})]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Apache Fory\u2122"})," - Blazingly fast multi-language serialization framework."]})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},11151:(e,n,r)=>{r.d(n,{Z:()=>a,a:()=>l});var i=r(67294);const s={},t=i.createContext(s);function l(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);