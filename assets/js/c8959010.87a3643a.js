"use strict";(self.webpackChunkfory_site=self.webpackChunkfory_site||[]).push([[79298],{17456:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>d,metadata:()=>l,toc:()=>o});var t=s(85893),i=s(11151);const d={title:"Supported Types",sidebar_position:5,id:"supported_types",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},r=void 0,l={id:"guide/cpp/supported_types",title:"Supported Types",description:"This page documents all types supported by Fory C++ serialization.",source:"@site/versioned_docs/version-0.14/guide/cpp/supported-types.md",sourceDirName:"guide/cpp",slug:"/guide/cpp/supported_types",permalink:"/docs/0.14/guide/cpp/supported_types",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/fory-site/tree/main/docs/guide/cpp/supported-types.md",tags:[],version:"0.14",sidebarPosition:5,frontMatter:{title:"Supported Types",sidebar_position:5,id:"supported_types",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},sidebar:"docsSidebar",previous:{title:"Type Registration",permalink:"/docs/0.14/guide/cpp/type_registration"},next:{title:"Cross-Language Serialization",permalink:"/docs/0.14/guide/cpp/cross_language"}},c={},o=[{value:"Primitive Types",id:"primitive-types",level:2},{value:"String Types",id:"string-types",level:2},{value:"Collection Types",id:"collection-types",level:2},{value:"Vector / List",id:"vector--list",level:3},{value:"Set",id:"set",level:3},{value:"Map",id:"map",level:3},{value:"Smart Pointers",id:"smart-pointers",level:2},{value:"std::optional",id:"stdoptional",level:3},{value:"std::shared_ptr",id:"stdshared_ptr",level:3},{value:"std::unique_ptr",id:"stdunique_ptr",level:3},{value:"Variant Type",id:"variant-type",level:2},{value:"std::monostate",id:"stdmonostate",level:3},{value:"Temporal Types",id:"temporal-types",level:2},{value:"Duration",id:"duration",level:3},{value:"Timestamp",id:"timestamp",level:3},{value:"LocalDate",id:"localdate",level:3},{value:"User-Defined Structs",id:"user-defined-structs",level:2},{value:"Enum Types",id:"enum-types",level:2},{value:"Unsupported Types",id:"unsupported-types",level:2},{value:"Related Topics",id:"related-topics",level:2}];function a(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"This page documents all types supported by Fory C++ serialization."}),"\n",(0,t.jsx)(n.h2,{id:"primitive-types",children:"Primitive Types"}),"\n",(0,t.jsx)(n.p,{children:"All C++ primitive types are supported with efficient binary encoding:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Size"}),(0,t.jsx)(n.th,{children:"Fory TypeId"}),(0,t.jsx)(n.th,{children:"Notes"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"bool"})}),(0,t.jsx)(n.td,{children:"1 byte"}),(0,t.jsx)(n.td,{children:"BOOL"}),(0,t.jsx)(n.td,{children:"True/false"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"int8_t"})}),(0,t.jsx)(n.td,{children:"1 byte"}),(0,t.jsx)(n.td,{children:"INT8"}),(0,t.jsx)(n.td,{children:"Signed byte"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint8_t"})}),(0,t.jsx)(n.td,{children:"1 byte"}),(0,t.jsx)(n.td,{children:"INT8"}),(0,t.jsx)(n.td,{children:"Unsigned byte"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"int16_t"})}),(0,t.jsx)(n.td,{children:"2 byte"}),(0,t.jsx)(n.td,{children:"INT16"}),(0,t.jsx)(n.td,{children:"Signed short"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint16_t"})}),(0,t.jsx)(n.td,{children:"2 byte"}),(0,t.jsx)(n.td,{children:"INT16"}),(0,t.jsx)(n.td,{children:"Unsigned short"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"int32_t"})}),(0,t.jsx)(n.td,{children:"4 byte"}),(0,t.jsx)(n.td,{children:"INT32"}),(0,t.jsx)(n.td,{children:"Signed integer"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint32_t"})}),(0,t.jsx)(n.td,{children:"4 byte"}),(0,t.jsx)(n.td,{children:"INT32"}),(0,t.jsx)(n.td,{children:"Unsigned integer"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"int64_t"})}),(0,t.jsx)(n.td,{children:"8 byte"}),(0,t.jsx)(n.td,{children:"INT64"}),(0,t.jsx)(n.td,{children:"Signed long"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint64_t"})}),(0,t.jsx)(n.td,{children:"8 byte"}),(0,t.jsx)(n.td,{children:"INT64"}),(0,t.jsx)(n.td,{children:"Unsigned long"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"float"})}),(0,t.jsx)(n.td,{children:"4 byte"}),(0,t.jsx)(n.td,{children:"FLOAT32"}),(0,t.jsx)(n.td,{children:"IEEE 754 single"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"double"})}),(0,t.jsx)(n.td,{children:"8 byte"}),(0,t.jsx)(n.td,{children:"FLOAT64"}),(0,t.jsx)(n.td,{children:"IEEE 754 double"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"char"})}),(0,t.jsx)(n.td,{children:"1 byte"}),(0,t.jsx)(n.td,{children:"INT8"}),(0,t.jsx)(n.td,{children:"Character (as signed)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"char16_t"})}),(0,t.jsx)(n.td,{children:"2 byte"}),(0,t.jsx)(n.td,{children:"INT16"}),(0,t.jsx)(n.td,{children:"16-bits characters"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"char32_t"})}),(0,t.jsx)(n.td,{children:"4 byte"}),(0,t.jsx)(n.td,{children:"INT32"}),(0,t.jsx)(n.td,{children:"32-bits characters"})]})]})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"int32_t value = 42;\nauto bytes = fory.serialize(value).value();\nauto decoded = fory.deserialize<int32_t>(bytes).value();\nassert(value == decoded);\n"})}),"\n",(0,t.jsx)(n.h2,{id:"string-types",children:"String Types"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Fory TypeId"}),(0,t.jsx)(n.th,{children:"Notes"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"std::string"})}),(0,t.jsx)(n.td,{children:"STRING"}),(0,t.jsx)(n.td,{children:"UTF-8 encoded"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"std::string_view"})}),(0,t.jsx)(n.td,{children:"STRING"}),(0,t.jsx)(n.td,{children:"Zero-copy view (read)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"std::u16string"})}),(0,t.jsx)(n.td,{children:"STRING"}),(0,t.jsx)(n.td,{children:"UTF-16 (converted)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"binary"})}),(0,t.jsx)(n.td,{children:"BINARY"}),(0,t.jsx)(n.td,{children:"Raw bytes without length"})]})]})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'std::string text = "Hello, World!";\nauto bytes = fory.serialize(text).value();\nauto decoded = fory.deserialize<std::string>(bytes).value();\nassert(text == decoded);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"collection-types",children:"Collection Types"}),"\n",(0,t.jsx)(n.h3,{id:"vector--list",children:"Vector / List"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"std::vector<T>"})," for any serializable element type:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'std::vector<int32_t> numbers{1, 2, 3, 4, 5};\nauto bytes = fory.serialize(numbers).value();\nauto decoded = fory.deserialize<std::vector<int32_t>>(bytes).value();\n\n// Nested vectors\nstd::vector<std::vector<std::string>> nested{\n    {"a", "b"},\n    {"c", "d", "e"}\n};\n'})}),"\n",(0,t.jsx)(n.h3,{id:"set",children:"Set"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"std::set<T>"})," and ",(0,t.jsx)(n.code,{children:"std::unordered_set<T>"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'std::set<std::string> tags{"cpp", "serialization", "fory"};\nauto bytes = fory.serialize(tags).value();\nauto decoded = fory.deserialize<std::set<std::string>>(bytes).value();\n\nstd::unordered_set<int32_t> ids{1, 2, 3};\n'})}),"\n",(0,t.jsx)(n.h3,{id:"map",children:"Map"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"std::map<K, V>"})," and ",(0,t.jsx)(n.code,{children:"std::unordered_map<K, V>"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'std::map<std::string, int32_t> scores{\n    {"Alice", 100},\n    {"Bob", 95}\n};\nauto bytes = fory.serialize(scores).value();\nauto decoded = fory.deserialize<std::map<std::string, int32_t>>(bytes).value();\n\n// Unordered map\nstd::unordered_map<int32_t, std::string> lookup{\n    {1, "one"},\n    {2, "two"}\n};\n'})}),"\n",(0,t.jsx)(n.h2,{id:"smart-pointers",children:"Smart Pointers"}),"\n",(0,t.jsx)(n.h3,{id:"stdoptional",children:"std::optional"}),"\n",(0,t.jsx)(n.p,{children:"Nullable wrapper for any type:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"std::optional<int32_t> maybe_value = 42;\nstd::optional<int32_t> empty_value = std::nullopt;\n\nauto bytes = fory.serialize(maybe_value).value();\nauto decoded = fory.deserialize<std::optional<int32_t>>(bytes).value();\nassert(decoded.has_value() && *decoded == 42);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"stdshared_ptr",children:"std::shared_ptr"}),"\n",(0,t.jsx)(n.p,{children:"Shared ownership with reference tracking:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'auto shared = std::make_shared<Person>("Alice", 30);\n\nauto bytes = fory.serialize(shared).value();\nauto decoded = fory.deserialize<std::shared_ptr<Person>>(bytes).value();\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["With reference tracking enabled (",(0,t.jsx)(n.code,{children:"track_ref(true)"}),"):"]})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Shared objects are serialized once"}),"\n",(0,t.jsx)(n.li,{children:"References to the same object are preserved"}),"\n",(0,t.jsx)(n.li,{children:"Circular references are handled automatically"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"stdunique_ptr",children:"std::unique_ptr"}),"\n",(0,t.jsx)(n.p,{children:"Exclusive ownership:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'auto unique = std::make_unique<Person>("Bob", 25);\n\nauto bytes = fory.serialize(unique).value();\nauto decoded = fory.deserialize<std::unique_ptr<Person>>(bytes).value();\n'})}),"\n",(0,t.jsx)(n.h2,{id:"variant-type",children:"Variant Type"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"std::variant<Ts...>"})," for type-safe unions:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'using MyVariant = std::variant<int32_t, std::string, double>;\n\nMyVariant v1 = 42;\nMyVariant v2 = std::string("hello");\nMyVariant v3 = 3.14;\n\nauto bytes = fory.serialize(v1).value();\nauto decoded = fory.deserialize<MyVariant>(bytes).value();\nassert(std::get<int32_t>(decoded) == 42);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"stdmonostate",children:"std::monostate"}),"\n",(0,t.jsx)(n.p,{children:"Empty variant alternative:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"using OptionalInt = std::variant<std::monostate, int32_t>;\n\nOptionalInt empty = std::monostate{};\nOptionalInt value = 42;\n"})}),"\n",(0,t.jsx)(n.h2,{id:"temporal-types",children:"Temporal Types"}),"\n",(0,t.jsx)(n.h3,{id:"duration",children:"Duration"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"std::chrono::nanoseconds"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"using Duration = std::chrono::nanoseconds;\n\nDuration d = std::chrono::seconds(30);\nauto bytes = fory.serialize(d).value();\nauto decoded = fory.deserialize<Duration>(bytes).value();\n"})}),"\n",(0,t.jsx)(n.h3,{id:"timestamp",children:"Timestamp"}),"\n",(0,t.jsx)(n.p,{children:"Point in time since Unix epoch:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"using Timestamp = std::chrono::time_point<std::chrono::system_clock,\n                                          std::chrono::nanoseconds>;\n\nTimestamp now = std::chrono::system_clock::now();\nauto bytes = fory.serialize(now).value();\nauto decoded = fory.deserialize<Timestamp>(bytes).value();\n"})}),"\n",(0,t.jsx)(n.h3,{id:"localdate",children:"LocalDate"}),"\n",(0,t.jsx)(n.p,{children:"Days since Unix epoch:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"LocalDate date{18628};  // Days since 1970-01-01\n\nauto bytes = fory.serialize(date).value();\nauto decoded = fory.deserialize<LocalDate>(bytes).value();\n"})}),"\n",(0,t.jsx)(n.h2,{id:"user-defined-structs",children:"User-Defined Structs"}),"\n",(0,t.jsxs)(n.p,{children:["Any struct can be made serializable with ",(0,t.jsx)(n.code,{children:"FORY_STRUCT"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"struct Point {\n  double x;\n  double y;\n  double z;\n};\nFORY_STRUCT(Point, x, y, z);\n\nstruct Line {\n  Point start;\n  Point end;\n  std::string label;\n};\nFORY_STRUCT(Line, start, end, label);\n"})}),"\n",(0,t.jsx)(n.h2,{id:"enum-types",children:"Enum Types"}),"\n",(0,t.jsxs)(n.p,{children:["Both scoped and unscoped enums are supported with ",(0,t.jsx)(n.code,{children:"FORY_ENUM"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// Scoped enum (C++11 enum class)\nenum class Color { RED = 0, GREEN = 1, BLUE = 2 };\n\n// Unscoped enum with incontinuous values\nenum Priority : int32_t { LOW = -10, NORMAL = 0, HIGH = 10 };\nFORY_ENUM(Priority, LOW, NORMAL, HIGH);\n\n// Usage\nColor c = Color::GREEN;\nauto bytes = fory.serialize(c).value();\nauto decoded = fory.deserialize<Color>(bytes).value();\n"})}),"\n",(0,t.jsx)(n.h2,{id:"unsupported-types",children:"Unsupported Types"}),"\n",(0,t.jsx)(n.p,{children:"Currently not supported:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Raw pointers (",(0,t.jsx)(n.code,{children:"T*"}),") - use smart pointers instead"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"std::tuple<Ts...>"})," - use structs instead"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"std::array<T, N>"})," - use ",(0,t.jsx)(n.code,{children:"std::vector<T>"})," instead"]}),"\n",(0,t.jsx)(n.li,{children:"Function pointers"}),"\n",(0,t.jsxs)(n.li,{children:["References (",(0,t.jsx)(n.code,{children:"T&"}),", ",(0,t.jsx)(n.code,{children:"const T&"}),") - by value only"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/0.14/guide/cpp/basic_serialization",children:"Basic Serialization"})," - Using these types"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/0.14/guide/cpp/type_registration",children:"Type Registration"})," - Registering types"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/0.14/guide/cpp/cross_language",children:"Cross-Language"})," - Cross-language compatibility"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},11151:(e,n,s)=>{s.d(n,{Z:()=>l,a:()=>r});var t=s(67294);const i={},d=t.createContext(i);function r(e){const n=t.useContext(d);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(d.Provider,{value:n},e.children)}}}]);