"use strict";(self.webpackChunkfory_site=self.webpackChunkfory_site||[]).push([[38329],{72695:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>t,default:()=>o,frontMatter:()=>r,metadata:()=>d,toc:()=>c});var s=i(85893),l=i(11151);const r={title:"Java Serialization Format",sidebar_position:1,id:"java_serialization_spec",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance\nwith the License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},t=void 0,d={id:"specification/java_serialization_spec",title:"Java Serialization Format",description:"Spec overview",source:"@site/docs/specification/java_serialization_spec.md",sourceDirName:"specification",slug:"/specification/java_serialization_spec",permalink:"/docs/next/specification/java_serialization_spec",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/fory-site/tree/main/docs/specification/java_serialization_spec.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Java Serialization Format",sidebar_position:1,id:"java_serialization_spec",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance\nwith the License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},sidebar:"specificationSidebar",previous:{title:"Xlang Serialization Format",permalink:"/docs/next/specification/xlang_serialization_spec"},next:{title:"Row Format",permalink:"/docs/next/specification/row_format_spec"}},a={},c=[{value:"Spec overview",id:"spec-overview",level:2},{value:"Fory header",id:"fory-header",level:2},{value:"Reference meta",id:"reference-meta",level:2},{value:"Type system and type IDs",id:"type-system-and-type-ids",level:2},{value:"Shared internal type IDs (0-63)",id:"shared-internal-type-ids-0-63",level:3},{value:"Java native built-in type IDs",id:"java-native-built-in-type-ids",level:3},{value:"Registration and named types",id:"registration-and-named-types",level:3},{value:"Type meta encoding",id:"type-meta-encoding",level:2},{value:"Shared class meta (streaming)",id:"shared-class-meta-streaming",level:3},{value:"Schema modes",id:"schema-modes",level:2},{value:"ClassDef format (compatible mode)",id:"classdef-format-compatible-mode",level:2},{value:"Binary layout",id:"binary-layout",level:3},{value:"Class meta bytes",id:"class-meta-bytes",level:3},{value:"Field info",id:"field-info",level:3},{value:"Field type encoding",id:"field-type-encoding",level:3},{value:"Meta string encoding",id:"meta-string-encoding",level:2},{value:"Package and type names",id:"package-and-type-names",level:3},{value:"Field names",id:"field-names",level:3},{value:"Encoding algorithms",id:"encoding-algorithms",level:3},{value:"Value encodings",id:"value-encodings",level:2},{value:"Primitives",id:"primitives",level:3},{value:"String",id:"string",level:3},{value:"Enum",id:"enum",level:3},{value:"Binary (byte[])",id:"binary-byte",level:3},{value:"Primitive arrays",id:"primitive-arrays",level:3},{value:"Object arrays",id:"object-arrays",level:3},{value:"Collections (List/Set)",id:"collections-listset",level:3},{value:"Maps",id:"maps",level:3},{value:"Null key/value entries",id:"null-keyvalue-entries",level:4},{value:"Objects and structs",id:"objects-and-structs",level:3},{value:"Extensions (EXT)",id:"extensions-ext",level:3},{value:"Out-of-band buffers",id:"out-of-band-buffers",level:2}];function h(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"spec-overview",children:"Spec overview"}),"\n",(0,s.jsx)(n.p,{children:"Apache Fory Java serialization is a dynamic binary format for Java object graphs. It supports\nshared references, circular references, polymorphism, and optional schema evolution. The format is\nstream friendly: shared type metadata is written inline when needed and there is no meta start\noffset."}),"\n",(0,s.jsxs)(n.p,{children:["The Java native format is an extension of the xlang wire format and reuses the same core framing\nand encodings; see ",(0,s.jsx)(n.code,{children:"docs/specification/xlang_serialization_spec.md"})," for the shared baseline."]}),"\n",(0,s.jsx)(n.p,{children:"Overall layout:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| fory header | object ref meta | object type meta | object value data |\n"})}),"\n",(0,s.jsx)(n.p,{children:"All data is encoded in little endian byte order. When running on a big endian platform, array\nserializers swap byte order on write/read so the on-wire layout remains little endian."}),"\n",(0,s.jsx)(n.h2,{id:"fory-header",children:"Fory header"}),"\n",(0,s.jsx)(n.p,{children:"Java native serialization writes a one byte bitmap header. The header layout mirrors the xlang\nbitmap and uses the same flag bits."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"|     5 bits    | 1 bit | 1 bit | 1 bit |\n+--------------+-------+-------+-------+\n| reserved     |  oob  | xlang | null  |\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"null flag: 1 when object is null, 0 otherwise. If object is null, other bits are not set."}),"\n",(0,s.jsx)(n.li,{children:"xlang flag: 1 when serialization uses xlang format, 0 when serialization uses Java native format."}),"\n",(0,s.jsxs)(n.li,{children:["oob flag: 1 when ",(0,s.jsx)(n.code,{children:"BufferCallback"})," is not null, 0 otherwise."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The header is always a single byte; no language ID is written."}),"\n",(0,s.jsx)(n.h2,{id:"reference-meta",children:"Reference meta"}),"\n",(0,s.jsx)(n.p,{children:"Reference tracking uses the same flags as the xlang specification."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Flag"}),(0,s.jsx)(n.th,{children:"Byte Value"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"NULL FLAG"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"-3"})}),(0,s.jsx)(n.td,{children:"Object is null. No further bytes are written for this object."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"REF FLAG"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"-2"})}),(0,s.jsx)(n.td,{children:"Object was already serialized. Followed by unsigned varint32 reference ID."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"NOT_NULL VALUE FLAG"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"-1"})}),(0,s.jsx)(n.td,{children:"Object is non-null but reference tracking is disabled for this type. Object data follows immediately."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"REF VALUE FLAG"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"0"})}),(0,s.jsx)(n.td,{children:"Object is referencable and this is its first occurrence. Object data follows. Assigns next reference ID."})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["When reference tracking is disabled globally or for a specific field/type, only ",(0,s.jsx)(n.code,{children:"NULL FLAG"})," and\n",(0,s.jsx)(n.code,{children:"NOT_NULL VALUE FLAG"})," are used."]}),"\n",(0,s.jsx)(n.h2,{id:"type-system-and-type-ids",children:"Type system and type IDs"}),"\n",(0,s.jsx)(n.p,{children:"Java native serialization uses the unified type ID layout shared with xlang:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"full_type_id = (user_type_id << 8) | internal_type_id\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"internal_type_id"})," is the low 8 bits describing the kind (enum/struct/ext, named variants, or a\nbuilt-in type)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"user_type_id"})," is the numeric registration ID (0-based) for user-defined enum/struct/ext types."]}),"\n",(0,s.jsxs)(n.li,{children:["Named types use ",(0,s.jsx)(n.code,{children:"NAMED_*"})," internal IDs and carry names in metadata rather than embedding a user\nID."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"shared-internal-type-ids-0-63",children:"Shared internal type IDs (0-63)"}),"\n",(0,s.jsxs)(n.p,{children:["Java native mode shares the xlang internal IDs for all values below 64. IDs ",(0,s.jsx)(n.code,{children:"0~56"})," are defined by\nthe xlang spec, while ",(0,s.jsx)(n.code,{children:"57~63"})," are reserved for future internal use. These IDs are stable across\nlanguages."]}),"\n",(0,s.jsxs)(n.p,{children:["See the internal type ID table in\n",(0,s.jsx)(n.a,{href:"/docs/next/specification/xlang_serialization_spec#internal-type-id-table",children:"Xlang Serialization Format"}),".\nJava shares all IDs ",(0,s.jsx)(n.code,{children:"< 64"}),", with ",(0,s.jsx)(n.code,{children:"57~63"})," reserved for future internal use."]}),"\n",(0,s.jsx)(n.h3,{id:"java-native-built-in-type-ids",children:"Java native built-in type IDs"}),"\n",(0,s.jsxs)(n.p,{children:["Java native serialization assigns Java-specific built-ins starting at\n",(0,s.jsx)(n.code,{children:"Types.BOUND + 5"})," (",(0,s.jsx)(n.code,{children:"Types.BOUND"})," is 64; 5 IDs are reserved for future use).\nType IDs in ",(0,s.jsx)(n.code,{children:"0~56"})," are shared with xlang; ",(0,s.jsx)(n.code,{children:"57~63"})," are reserved; ",(0,s.jsx)(n.code,{children:"64+"})," are only\nvalid in Java native mode."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Type ID"}),(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"69"}),(0,s.jsx)(n.td,{children:"VOID_ID"}),(0,s.jsx)(n.td,{children:"java.lang.Void"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"70"}),(0,s.jsx)(n.td,{children:"CHAR_ID"}),(0,s.jsx)(n.td,{children:"java.lang.Character"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"71"}),(0,s.jsx)(n.td,{children:"PRIMITIVE_VOID_ID"}),(0,s.jsx)(n.td,{children:"void"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"72"}),(0,s.jsx)(n.td,{children:"PRIMITIVE_BOOL_ID"}),(0,s.jsx)(n.td,{children:"boolean"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"73"}),(0,s.jsx)(n.td,{children:"PRIMITIVE_INT8_ID"}),(0,s.jsx)(n.td,{children:"byte"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"74"}),(0,s.jsx)(n.td,{children:"PRIMITIVE_CHAR_ID"}),(0,s.jsx)(n.td,{children:"char"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"75"}),(0,s.jsx)(n.td,{children:"PRIMITIVE_INT16_ID"}),(0,s.jsx)(n.td,{children:"short"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"76"}),(0,s.jsx)(n.td,{children:"PRIMITIVE_INT32_ID"}),(0,s.jsx)(n.td,{children:"int"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"77"}),(0,s.jsx)(n.td,{children:"PRIMITIVE_FLOAT32_ID"}),(0,s.jsx)(n.td,{children:"float"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"78"}),(0,s.jsx)(n.td,{children:"PRIMITIVE_INT64_ID"}),(0,s.jsx)(n.td,{children:"long"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"79"}),(0,s.jsx)(n.td,{children:"PRIMITIVE_FLOAT64_ID"}),(0,s.jsx)(n.td,{children:"double"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"80"}),(0,s.jsx)(n.td,{children:"PRIMITIVE_BOOLEAN_ARRAY_ID"}),(0,s.jsx)(n.td,{children:"boolean[]"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"81"}),(0,s.jsx)(n.td,{children:"PRIMITIVE_BYTE_ARRAY_ID"}),(0,s.jsx)(n.td,{children:"byte[]"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"82"}),(0,s.jsx)(n.td,{children:"PRIMITIVE_CHAR_ARRAY_ID"}),(0,s.jsx)(n.td,{children:"char[]"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"83"}),(0,s.jsx)(n.td,{children:"PRIMITIVE_SHORT_ARRAY_ID"}),(0,s.jsx)(n.td,{children:"short[]"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"84"}),(0,s.jsx)(n.td,{children:"PRIMITIVE_INT_ARRAY_ID"}),(0,s.jsx)(n.td,{children:"int[]"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"85"}),(0,s.jsx)(n.td,{children:"PRIMITIVE_FLOAT_ARRAY_ID"}),(0,s.jsx)(n.td,{children:"float[]"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"86"}),(0,s.jsx)(n.td,{children:"PRIMITIVE_LONG_ARRAY_ID"}),(0,s.jsx)(n.td,{children:"long[]"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"87"}),(0,s.jsx)(n.td,{children:"PRIMITIVE_DOUBLE_ARRAY_ID"}),(0,s.jsx)(n.td,{children:"double[]"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"88"}),(0,s.jsx)(n.td,{children:"STRING_ARRAY_ID"}),(0,s.jsx)(n.td,{children:"String[]"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"89"}),(0,s.jsx)(n.td,{children:"OBJECT_ARRAY_ID"}),(0,s.jsx)(n.td,{children:"Object[]"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"90"}),(0,s.jsx)(n.td,{children:"ARRAYLIST_ID"}),(0,s.jsx)(n.td,{children:"java.util.ArrayList"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"91"}),(0,s.jsx)(n.td,{children:"HASHMAP_ID"}),(0,s.jsx)(n.td,{children:"java.util.HashMap"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"92"}),(0,s.jsx)(n.td,{children:"HASHSET_ID"}),(0,s.jsx)(n.td,{children:"java.util.HashSet"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"93"}),(0,s.jsx)(n.td,{children:"CLASS_ID"}),(0,s.jsx)(n.td,{children:"java.lang.Class"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"94"}),(0,s.jsx)(n.td,{children:"EMPTY_OBJECT_ID"}),(0,s.jsx)(n.td,{children:"empty object stub"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"95"}),(0,s.jsx)(n.td,{children:"LAMBDA_STUB_ID"}),(0,s.jsx)(n.td,{children:"lambda stub"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"96"}),(0,s.jsx)(n.td,{children:"JDK_PROXY_STUB_ID"}),(0,s.jsx)(n.td,{children:"JDK proxy stub"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"97"}),(0,s.jsx)(n.td,{children:"REPLACE_STUB_ID"}),(0,s.jsx)(n.td,{children:"writeReplace/readResolve stub"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"98"}),(0,s.jsx)(n.td,{children:"NONEXISTENT_META_SHARED_ID"}),(0,s.jsx)(n.td,{children:"meta-shared unknown class stub"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"registration-and-named-types",children:"Registration and named types"}),"\n",(0,s.jsx)(n.p,{children:"User-defined enum/struct/ext types can be registered by numeric ID or by name."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Numeric registration: ",(0,s.jsx)(n.code,{children:"full_type_id = (user_id << 8) | internal_type_id"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Name registration: type meta uses namespace and type name (see below)."}),"\n",(0,s.jsx)(n.li,{children:"Unregistered types are encoded as named types using namespace = package name and type name =\nsimple class name."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Named type selection rules for unregistered types:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"enum -> NAMED_ENUM"}),"\n",(0,s.jsx)(n.li,{children:"struct-like serializers -> NAMED_STRUCT (or NAMED_COMPATIBLE_STRUCT in compatible mode)"}),"\n",(0,s.jsx)(n.li,{children:"all other custom serializers -> NAMED_EXT"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"type-meta-encoding",children:"Type meta encoding"}),"\n",(0,s.jsx)(n.p,{children:"Every value is written with a type ID followed by optional type metadata:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Write ",(0,s.jsx)(n.code,{children:"type_id"})," using varuint32 small7 encoding."]}),"\n",(0,s.jsxs)(n.li,{children:["For ",(0,s.jsx)(n.code,{children:"NAMED_ENUM"}),", ",(0,s.jsx)(n.code,{children:"NAMED_STRUCT"}),", ",(0,s.jsx)(n.code,{children:"NAMED_EXT"}),", ",(0,s.jsx)(n.code,{children:"NAMED_COMPATIBLE_STRUCT"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If meta share is enabled: write shared class meta (streaming format)."}),"\n",(0,s.jsx)(n.li,{children:"Otherwise: write namespace and type name as meta strings."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["For ",(0,s.jsx)(n.code,{children:"COMPATIBLE_STRUCT"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If meta share is enabled: write shared class meta (streaming format)."}),"\n",(0,s.jsx)(n.li,{children:"Otherwise: no extra meta (type ID is sufficient)."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"All other types: no extra meta."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"shared-class-meta-streaming",children:"Shared class meta (streaming)"}),"\n",(0,s.jsx)(n.p,{children:"When meta share is enabled, Java uses the streaming shared meta protocol and writes TypeDef\nbytes inline on first use."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| varuint32: index_marker | [class def bytes if new] |\n\nindex_marker = (index << 1) | flag\nflag = 1 -> reference\nflag = 0 -> new type\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"flag == 1"}),", this is a reference to a previously written type. No class def bytes follow."]}),"\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"flag == 0"}),", this is a new type definition and class def bytes are written inline."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The index is assigned sequentially in the order types are first encountered."}),"\n",(0,s.jsx)(n.h2,{id:"schema-modes",children:"Schema modes"}),"\n",(0,s.jsx)(n.p,{children:"Java native serialization supports two schema modes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Schema consistent (compatible mode disabled): fields are serialized in a fixed order and no\nClassDef is required. Type meta uses ",(0,s.jsx)(n.code,{children:"STRUCT"})," or ",(0,s.jsx)(n.code,{children:"NAMED_STRUCT"})," for user-defined classes."]}),"\n",(0,s.jsxs)(n.li,{children:["Schema evolution (compatible mode enabled): fields are serialized with schema evolution metadata\n(ClassDef). Type meta uses ",(0,s.jsx)(n.code,{children:"COMPATIBLE_STRUCT"})," or ",(0,s.jsx)(n.code,{children:"NAMED_COMPATIBLE_STRUCT"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"classdef-format-compatible-mode",children:"ClassDef format (compatible mode)"}),"\n",(0,s.jsx)(n.p,{children:"ClassDef is the schema evolution metadata encoded for compatible structs. It is written inline\nwhen shared meta is enabled, or referenced by index when already seen."}),"\n",(0,s.jsx)(n.h3,{id:"binary-layout",children:"Binary layout"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| 8 bytes header | [varuint32 extra size] | class meta bytes |\n"})}),"\n",(0,s.jsx)(n.p,{children:"Header layout (lower bits on the right):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| 50-bit hash | 4 bits reserved | 1 bit compress | 1 bit has_fields_meta | 8-bit size |\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: lower 8 bits. If size equals the mask (0xFF), write extra size as varuint32 and add it."}),"\n",(0,s.jsx)(n.li,{children:"compress: set when payload is compressed."}),"\n",(0,s.jsx)(n.li,{children:"has_fields_meta: set when field metadata is present."}),"\n",(0,s.jsx)(n.li,{children:"reserved: bits 10-13 are reserved for future use and must be zero."}),"\n",(0,s.jsx)(n.li,{children:"hash: 50-bit hash of the payload and flags."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"class-meta-bytes",children:"Class meta bytes"}),"\n",(0,s.jsx)(n.p,{children:"Class meta encodes a linearized class hierarchy (from parent to leaf) and field metadata:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| num_classes | class_layer_0 | class_layer_1 | ... |\n\nclass_layer:\n| num_fields << 1 | registered_flag | [type_id if registered] |\n| namespace | type_name | field_infos |\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"num_classes"})," stores ",(0,s.jsx)(n.code,{children:"(num_layers - 1)"})," in a single byte.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If it equals ",(0,s.jsx)(n.code,{children:"0b1111"}),", read an extra varuint32 small7 and add it."]}),"\n",(0,s.jsxs)(n.li,{children:["The actual number of layers is ",(0,s.jsx)(n.code,{children:"num_classes + 1"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"registered_flag"})," is 1 if the class is registered by numeric ID."]}),"\n",(0,s.jsx)(n.li,{children:"If registered by ID, the class type ID follows (varuint32 small7)."}),"\n",(0,s.jsx)(n.li,{children:"If registered by name or unregistered, namespace and type name are written as meta strings."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"field-info",children:"Field info"}),"\n",(0,s.jsx)(n.p,{children:"Each field uses a compact header followed by its name bytes (omitted when TAG_ID is used) and its\ntype info:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| field_header | [field_name_bytes] | field_type |\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"field_header"})," bits:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"bit 0: trackingRef"}),"\n",(0,s.jsx)(n.li,{children:"bit 1: nullable"}),"\n",(0,s.jsx)(n.li,{children:"bits 2-3: field name encoding"}),"\n",(0,s.jsx)(n.li,{children:"bits 4-6: name length (len-1), or tag ID when TAG_ID is used; value 7 indicates extended length"}),"\n",(0,s.jsx)(n.li,{children:"bit 7: reserved (0)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Field name encoding:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"0: UTF8"}),"\n",(0,s.jsx)(n.li,{children:"1: ALL_TO_LOWER_SPECIAL"}),"\n",(0,s.jsx)(n.li,{children:"2: LOWER_UPPER_DIGIT_SPECIAL"}),"\n",(0,s.jsx)(n.li,{children:"3: TAG_ID (field name omitted, tag ID stored in size field)"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["If length is extended (size==7), an extra varuint32 small7 storing ",(0,s.jsx)(n.code,{children:"(len-1) - 7"})," follows."]}),"\n",(0,s.jsx)(n.h3,{id:"field-type-encoding",children:"Field type encoding"}),"\n",(0,s.jsx)(n.p,{children:"Field types are encoded with a type tag and optional nested type info. For nested types, the header\nincludes nullable/trackingRef flags in the low bits.\nTop-level field types use the tag only (no flags)."}),"\n",(0,s.jsx)(n.p,{children:"Type tags:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Tag"}),(0,s.jsx)(n.th,{children:"Field type"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"Object (ObjectFieldType)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"Map (MapFieldType)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"Collection/List/Set (CollectionFieldType)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"Array (ArrayFieldType)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"4"}),(0,s.jsx)(n.td,{children:"Enum (EnumFieldType)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"5+"}),(0,s.jsx)(n.td,{children:"Registered type (RegisteredFieldType)"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Encoding rules:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"ObjectFieldType: write tag 0."}),"\n",(0,s.jsx)(n.li,{children:"MapFieldType: write tag 1, then key type, then value type."}),"\n",(0,s.jsx)(n.li,{children:"CollectionFieldType: write tag 2, then element type."}),"\n",(0,s.jsx)(n.li,{children:"ArrayFieldType: write tag 3, then dimensions, then component type."}),"\n",(0,s.jsx)(n.li,{children:"EnumFieldType: write tag 4."}),"\n",(0,s.jsxs)(n.li,{children:["RegisteredFieldType: write tag ",(0,s.jsx)(n.code,{children:"5 + type_id"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For nested types, nullable/trackingRef flags are stored in the low bits of the header as\n",(0,s.jsx)(n.code,{children:"(type_tag << 2) | (nullable << 1) | tracking_ref"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"meta-string-encoding",children:"Meta string encoding"}),"\n",(0,s.jsx)(n.p,{children:"Namespace, type names, and field names use the same meta string encodings as the xlang spec."}),"\n",(0,s.jsx)(n.h3,{id:"package-and-type-names",children:"Package and type names"}),"\n",(0,s.jsx)(n.p,{children:"Header format:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| 6 bits size | 2 bits encoding |\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size is the byte length of the encoded name."}),"\n",(0,s.jsxs)(n.li,{children:["if size == 63, write extra length ",(0,s.jsx)(n.code,{children:"(size - 63)"})," as varuint32 small7."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Encodings:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Package name: UTF8, ALL_TO_LOWER_SPECIAL, LOWER_UPPER_DIGIT_SPECIAL"}),"\n",(0,s.jsx)(n.li,{children:"Type name: UTF8, LOWER_UPPER_DIGIT_SPECIAL, FIRST_TO_LOWER_SPECIAL, ALL_TO_LOWER_SPECIAL"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"field-names",children:"Field names"}),"\n",(0,s.jsx)(n.p,{children:"Field name encoding is described in the ClassDef field header section. When using TAG_ID, the\nfield name bytes are omitted and the tag ID is stored in the size field."}),"\n",(0,s.jsx)(n.h3,{id:"encoding-algorithms",children:"Encoding algorithms"}),"\n",(0,s.jsxs)(n.p,{children:["See the xlang specification for encoding algorithms and tables:\n",(0,s.jsx)(n.code,{children:"docs/specification/xlang_serialization_spec.md#meta-string"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"value-encodings",children:"Value encodings"}),"\n",(0,s.jsx)(n.p,{children:"This section describes the byte layouts for common built-in serializers used in Java native\nserialization. Custom serializers (EXT) may define additional formats but must still follow the\nreference and type meta rules described above."}),"\n",(0,s.jsx)(n.h3,{id:"primitives",children:"Primitives"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"boolean: 1 byte (0x00 or 0x01)."}),"\n",(0,s.jsx)(n.li,{children:"byte: 1 byte."}),"\n",(0,s.jsx)(n.li,{children:"short: 2 bytes little endian."}),"\n",(0,s.jsx)(n.li,{children:"char: 2 bytes little endian (UTF-16 code unit)."}),"\n",(0,s.jsxs)(n.li,{children:["int:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"fixed: 4 bytes little endian."}),"\n",(0,s.jsxs)(n.li,{children:["varint: signed varint32 (ZigZag) when ",(0,s.jsx)(n.code,{children:"compressInt"})," is enabled."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["long:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"fixed: 8 bytes little endian."}),"\n",(0,s.jsxs)(n.li,{children:["varint: signed varint64 (ZigZag) when ",(0,s.jsx)(n.code,{children:"longEncoding=VARINT"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["tagged: tagged int64 when ",(0,s.jsx)(n.code,{children:"longEncoding=TAGGED"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"float: IEEE 754 float32, little endian."}),"\n",(0,s.jsx)(n.li,{children:"double: IEEE 754 float64, little endian."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Varint encodings follow the xlang spec:\n",(0,s.jsx)(n.code,{children:"docs/specification/xlang_serialization_spec.md#unsigned-varint32"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"string",children:"String"}),"\n",(0,s.jsx)(n.p,{children:"Strings are encoded as:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| varuint36_small: (num_bytes << 2) | coder | string bytes |\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["coder: 2-bit value","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"0: LATIN1"}),"\n",(0,s.jsx)(n.li,{children:"1: UTF16"}),"\n",(0,s.jsx)(n.li,{children:"2: UTF8"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"num_bytes: byte length of the encoded string payload."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"UTF16 is encoded as little endian 2-byte code units."}),"\n",(0,s.jsx)(n.h3,{id:"enum",children:"Enum"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"serializeEnumByName"})," is enabled: write enum name as a meta string."]}),"\n",(0,s.jsx)(n.li,{children:"Otherwise: write enum ordinal as varuint32 small7."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"binary-byte",children:"Binary (byte[])"}),"\n",(0,s.jsx)(n.p,{children:"Primitive byte arrays are encoded as:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| varuint32: num_bytes | raw bytes |\n"})}),"\n",(0,s.jsx)(n.h3,{id:"primitive-arrays",children:"Primitive arrays"}),"\n",(0,s.jsxs)(n.p,{children:["Primitive arrays use ",(0,s.jsx)(n.code,{children:"writePrimitiveArrayWithSize"})," unless compression is enabled:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| varuint32: byte_length | raw bytes |\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"compressIntArray"}),": int[] encoded as ",(0,s.jsx)(n.code,{children:"| varuint32: length | varint32... |"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"compressLongArray"}),": long[] encoded as ",(0,s.jsx)(n.code,{children:"| varuint32: length | varint64/tagged... |"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"object-arrays",children:"Object arrays"}),"\n",(0,s.jsx)(n.p,{children:"Object arrays encode length and a monomorphic flag:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| varuint32_small7: (length << 1) | mono_flag |\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"mono_flag == 1"}),", all elements share a known component serializer. Each element uses ref\nflags and the component serializer writes the value."]}),"\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"mono_flag == 0"}),", each element uses ref flags and writes its own class info and data."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"collections-listset",children:"Collections (List/Set)"}),"\n",(0,s.jsx)(n.p,{children:"Collections encode length and a one-byte elements header:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| varuint32_small7: length | elements_header | [elem_class_info] | elements... |\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"elements_header"})," bits (see ",(0,s.jsx)(n.code,{children:"CollectionFlags"}),"):"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"bit 0: TRACKING_REF"}),"\n",(0,s.jsx)(n.li,{children:"bit 1: HAS_NULL"}),"\n",(0,s.jsx)(n.li,{children:"bit 2: IS_DECL_ELEMENT_TYPE"}),"\n",(0,s.jsx)(n.li,{children:"bit 3: IS_SAME_TYPE"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"IS_SAME_TYPE"})," is set and ",(0,s.jsx)(n.code,{children:"IS_DECL_ELEMENT_TYPE"})," is not set, the element class info is written\nonce before the elements. Element values then follow with either ref flags (if TRACKING_REF) or\nper-element null flags (if HAS_NULL)."]}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"IS_SAME_TYPE"})," is not set, each element is written with its own class info and data (and\noptionally ref flags)."]}),"\n",(0,s.jsx)(n.h3,{id:"maps",children:"Maps"}),"\n",(0,s.jsx)(n.p,{children:"Maps encode entry count and then a sequence of chunks. Each chunk groups entries that share key\nand value types."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| varuint32_small7: size | chunk_1 | chunk_2 | ... |\n\nchunk (non-null entries):\n| header | chunk_size | [key_class_info] | [value_class_info] | entries... |\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"header"})," bits (see ",(0,s.jsx)(n.code,{children:"MapFlags"}),"):"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"bit 0: TRACKING_KEY_REF"}),"\n",(0,s.jsx)(n.li,{children:"bit 1: KEY_HAS_NULL"}),"\n",(0,s.jsx)(n.li,{children:"bit 2: KEY_DECL_TYPE"}),"\n",(0,s.jsx)(n.li,{children:"bit 3: TRACKING_VALUE_REF"}),"\n",(0,s.jsx)(n.li,{children:"bit 4: VALUE_HAS_NULL"}),"\n",(0,s.jsx)(n.li,{children:"bit 5: VALUE_DECL_TYPE"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"KEY_DECL_TYPE"})," or ",(0,s.jsx)(n.code,{children:"VALUE_DECL_TYPE"})," is unset, the corresponding class info is written once at\nthe start of the chunk. ",(0,s.jsx)(n.code,{children:"chunk_size"})," is a single byte (1..255) and ",(0,s.jsx)(n.code,{children:"MAX_CHUNK_SIZE"})," is 255."]}),"\n",(0,s.jsx)(n.h4,{id:"null-keyvalue-entries",children:"Null key/value entries"}),"\n",(0,s.jsxs)(n.p,{children:["Entries with null key or null value are encoded as special single-entry chunks without a\n",(0,s.jsx)(n.code,{children:"chunk_size"})," byte:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["null key, non-null value: ",(0,s.jsx)(n.code,{children:"NULL_KEY_VALUE_DECL_TYPE*"})," flags, then value payload"]}),"\n",(0,s.jsxs)(n.li,{children:["null value, non-null key: ",(0,s.jsx)(n.code,{children:"NULL_VALUE_KEY_DECL_TYPE*"})," flags, then key payload"]}),"\n",(0,s.jsxs)(n.li,{children:["null key and null value: ",(0,s.jsx)(n.code,{children:"KV_NULL"})," header only"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These chunks always represent exactly one entry."}),"\n",(0,s.jsx)(n.h3,{id:"objects-and-structs",children:"Objects and structs"}),"\n",(0,s.jsx)(n.p,{children:"Object values are encoded as:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| ref meta | type meta | field data |\n"})}),"\n",(0,s.jsx)(n.p,{children:"Field data is written by the serializer selected by the class info. For standard object\nserialization:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Fields are sorted deterministically using ",(0,s.jsx)(n.code,{children:"DescriptorGrouper"})," order:\nprimitives, boxed primitives, built-ins, collections, maps, then other fields, with names sorted\nwithin each category."]}),"\n",(0,s.jsxs)(n.li,{children:["For compatible mode, ",(0,s.jsx)(n.code,{children:"MetaSharedSerializer"})," uses ClassDef field metadata to read and skip\nunknown fields."]}),"\n",(0,s.jsx)(n.li,{children:"For each field, the serializer uses field metadata (nullable, trackingRef, polymorphic) to decide\nwhether to write ref flags and/or type meta before the field value."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"extensions-ext",children:"Extensions (EXT)"}),"\n",(0,s.jsx)(n.p,{children:"Extension types are encoded by their registered serializer. Type meta is still written before the\nvalue as described above. The serializer is responsible for the value layout."}),"\n",(0,s.jsx)(n.h2,{id:"out-of-band-buffers",children:"Out-of-band buffers"}),"\n",(0,s.jsxs)(n.p,{children:["When a ",(0,s.jsx)(n.code,{children:"BufferCallback"})," is provided, the oob flag is set in the header and serializers may emit\nbuffer references instead of inline bytes (for example, large primitive arrays). The out-of-band\nbuffer protocol is specific to the callback implementation; the main stream only contains\nreferences to those buffers."]})]})}function o(e={}){const{wrapper:n}={...(0,l.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>d,a:()=>t});var s=i(67294);const l={},r=s.createContext(l);function t(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:t(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);