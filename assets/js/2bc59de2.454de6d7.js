"use strict";(self.webpackChunkfory_site=self.webpackChunkfory_site||[]).push([[31691],{23458:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>t,default:()=>h,frontMatter:()=>s,metadata:()=>d,toc:()=>c});var r=i(85893),l=i(11151);const s={title:"Field Configuration",sidebar_position:7,id:"field_configuration",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},t=void 0,d={id:"guide/cpp/field_configuration",title:"Field Configuration",description:"This page explains how to configure field-level metadata for serialization.",source:"@site/docs/guide/cpp/field-configuration.md",sourceDirName:"guide/cpp",slug:"/guide/cpp/field_configuration",permalink:"/docs/next/guide/cpp/field_configuration",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/fory-site/tree/main/docs/guide/cpp/field-configuration.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{title:"Field Configuration",sidebar_position:7,id:"field_configuration",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},sidebar:"docsSidebar",previous:{title:"Custom Serializers",permalink:"/docs/next/guide/cpp/custom_serializers"},next:{title:"Supported Types",permalink:"/docs/next/guide/cpp/supported_types"}},a={},c=[{value:"Overview",id:"overview",level:2},{value:"The fory::field Template",id:"the-foryfield-template",level:2},{value:"Template Parameters",id:"template-parameters",level:3},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Tag Types",id:"tag-types",level:2},{value:"fory::nullable",id:"forynullable",level:3},{value:"fory::not_null",id:"forynot_null",level:3},{value:"fory::ref",id:"foryref",level:3},{value:"fory::dynamic&lt;V&gt;",id:"forydynamicv",level:3},{value:"Combining Tags",id:"combining-tags",level:3},{value:"Type Rules",id:"type-rules",level:2},{value:"Complete Example",id:"complete-example",level:2},{value:"Compile-Time Validation",id:"compile-time-validation",level:2},{value:"Backwards Compatibility",id:"backwards-compatibility",level:2},{value:"FORY_FIELD_TAGS Macro",id:"fory_field_tags-macro",level:2},{value:"Usage",id:"usage",level:3},{value:"FORY_FIELD_TAGS Options",id:"fory_field_tags-options",level:3},{value:"FORY_FIELD_CONFIG Macro",id:"fory_field_config-macro",level:2},{value:"Basic Syntax",id:"basic-syntax",level:3},{value:"The F() Builder",id:"the-f-builder",level:3},{value:"Encoding Options for Unsigned Integers",id:"encoding-options-for-unsigned-integers",level:3},{value:"Complete Example",id:"complete-example-1",level:3},{value:"Cross-Language Compatibility",id:"cross-language-compatibility",level:3},{value:"Schema Evolution with FORY_FIELD_CONFIG",id:"schema-evolution-with-fory_field_config",level:3},{value:"FORY_FIELD_CONFIG Options Reference",id:"fory_field_config-options-reference",level:3},{value:"Default Values",id:"default-values",level:2},{value:"Default Values Summary",id:"default-values-summary",level:3},{value:"Related Topics",id:"related-topics",level:2}];function o(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"This page explains how to configure field-level metadata for serialization."}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"Apache Fory\u2122 provides three ways to configure field-level metadata at compile time:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"fory::field<>"})," template"]})," - Inline metadata in struct definition with wrapper types"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"FORY_FIELD_TAGS"})," macro"]})," - Non-invasive metadata for basic field configuration"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"FORY_FIELD_CONFIG"})," macro"]})," - Advanced configuration with builder pattern and encoding control"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"These enable:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tag IDs"}),": Assign compact numeric IDs for schema evolution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Nullability"}),": Mark pointer fields as nullable"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reference Tracking"}),": Enable reference tracking for shared pointers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Encoding Control"}),": Specify wire format for integers (varint, fixed, tagged)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dynamic Dispatch"}),": Control polymorphic type info for smart pointers"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Comparison:"})}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Feature"}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.code,{children:"fory::field<>"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.code,{children:"FORY_FIELD_TAGS"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.code,{children:"FORY_FIELD_CONFIG"})})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Struct modification"})}),(0,r.jsx)(n.td,{children:"Required (wrap types)"}),(0,r.jsx)(n.td,{children:"None"}),(0,r.jsx)(n.td,{children:"None"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Encoding control"})}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"Yes (varint/fixed/tagged)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Builder pattern"})}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"Yes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Dynamic control"})}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"Yes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Compile-time verify"})}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"Limited"}),(0,r.jsx)(n.td,{children:"Yes (member pointers)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Cross-lang compat"})}),(0,r.jsx)(n.td,{children:"Limited"}),(0,r.jsx)(n.td,{children:"Limited"}),(0,r.jsx)(n.td,{children:"Full"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Recommended for"})}),(0,r.jsx)(n.td,{children:"Simple structs"}),(0,r.jsx)(n.td,{children:"Third-party types"}),(0,r.jsx)(n.td,{children:"Complex/xlang structs"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"the-foryfield-template",children:"The fory::field Template"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template <typename T, int16_t Id, typename... Options>\nclass field;\n"})}),"\n",(0,r.jsx)(n.h3,{id:"template-parameters",children:"Template Parameters"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Parameter"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"T"})}),(0,r.jsx)(n.td,{children:"The underlying field type"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Id"})}),(0,r.jsx)(n.td,{children:"Field tag ID (int16_t) for compact serialization"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Options"})}),(0,r.jsxs)(n.td,{children:["Optional tags: ",(0,r.jsx)(n.code,{children:"fory::nullable"}),", ",(0,r.jsx)(n.code,{children:"fory::ref"})]})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'#include "fory/serialization/fory.h"\n\nusing namespace fory::serialization;\n\nstruct Person {\n  fory::field<std::string, 0> name;\n  fory::field<int32_t, 1> age;\n  fory::field<std::optional<std::string>, 2> nickname;\n};\nFORY_STRUCT(Person, name, age, nickname);\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"fory::field<>"})," wrapper is transparent - you can use it like the underlying type:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'Person person;\nperson.name = "Alice";           // Direct assignment\nperson.age = 30;\nstd::string n = person.name;     // Implicit conversion\nint a = person.age.get();        // Explicit get()\n'})}),"\n",(0,r.jsx)(n.h2,{id:"tag-types",children:"Tag Types"}),"\n",(0,r.jsx)(n.h3,{id:"forynullable",children:"fory::nullable"}),"\n",(0,r.jsxs)(n.p,{children:["Marks a smart pointer field as nullable (can be ",(0,r.jsx)(n.code,{children:"nullptr"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"struct Node {\n  fory::field<std::string, 0> name;\n  fory::field<std::shared_ptr<Node>, 1, fory::nullable> next;  // Can be nullptr\n};\nFORY_STRUCT(Node, name, next);\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Valid for:"})," ",(0,r.jsx)(n.code,{children:"std::shared_ptr<T>"}),", ",(0,r.jsx)(n.code,{children:"fory::serialization::SharedWeak<T>"}),", ",(0,r.jsx)(n.code,{children:"std::unique_ptr<T>"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note:"})," For nullable primitives or strings, use ",(0,r.jsx)(n.code,{children:"std::optional<T>"})," instead:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Correct: use std::optional for nullable primitives\nfory::field<std::optional<int32_t>, 0> optional_value;\n\n// Wrong: nullable is not allowed for primitives\n// fory::field<int32_t, 0, fory::nullable> value;  // Compile error!\n"})}),"\n",(0,r.jsx)(n.h3,{id:"forynot_null",children:"fory::not_null"}),"\n",(0,r.jsx)(n.p,{children:"Explicitly marks a pointer field as non-nullable. This is the default for smart pointers, but can be used for documentation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"fory::field<std::shared_ptr<Data>, 0, fory::not_null> data;  // Must not be nullptr\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Valid for:"})," ",(0,r.jsx)(n.code,{children:"std::shared_ptr<T>"}),", ",(0,r.jsx)(n.code,{children:"fory::serialization::SharedWeak<T>"}),", ",(0,r.jsx)(n.code,{children:"std::unique_ptr<T>"})]}),"\n",(0,r.jsx)(n.h3,{id:"foryref",children:"fory::ref"}),"\n",(0,r.jsx)(n.p,{children:"Enables reference tracking for shared pointer fields. When multiple fields reference the same object, it will be serialized once and shared:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"struct Graph {\n  fory::field<std::string, 0> name;\n  fory::field<std::shared_ptr<Graph>, 1, fory::ref> left;    // Ref tracked\n  fory::field<std::shared_ptr<Graph>, 2, fory::ref> right;   // Ref tracked\n};\nFORY_STRUCT(Graph, name, left, right);\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Valid for:"})," ",(0,r.jsx)(n.code,{children:"std::shared_ptr<T>"}),", ",(0,r.jsx)(n.code,{children:"fory::serialization::SharedWeak<T>"})," (requires shared ownership)"]}),"\n",(0,r.jsx)(n.h3,{id:"forydynamicv",children:"fory::dynamic<V>"}),"\n",(0,r.jsx)(n.p,{children:"Controls whether type info is written for polymorphic smart pointer fields:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fory::dynamic<true>"}),": Force type info to be written (enable runtime subtype support)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fory::dynamic<false>"}),": skip type info (use declared type directly, no dynamic dispatch)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["By default, Fory auto-detects polymorphism via ",(0,r.jsx)(n.code,{children:"std::is_polymorphic<T>"}),". Use this tag to override:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Base class with virtual methods (detected as polymorphic by default)\nstruct Animal {\n  virtual ~Animal() = default;\n  virtual std::string speak() const = 0;\n};\n\nstruct Zoo {\n  // Auto: type info written because Animal has virtual methods\n  fory::field<std::shared_ptr<Animal>, 0, fory::nullable> animal;\n\n  // Force non-dynamic: skip type info even though Animal has virtual methods\n  // Use when you know the runtime type will always be exactly as declared\n  fory::field<std::shared_ptr<Animal>, 1, fory::nullable, fory::dynamic<false>> fixed_animal;\n};\nFORY_STRUCT(Zoo, animal, fixed_animal);\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Valid for:"})," ",(0,r.jsx)(n.code,{children:"std::shared_ptr<T>"}),", ",(0,r.jsx)(n.code,{children:"std::unique_ptr<T>"})]}),"\n",(0,r.jsx)(n.h3,{id:"combining-tags",children:"Combining Tags"}),"\n",(0,r.jsx)(n.p,{children:"Multiple tags can be combined for shared pointers and SharedWeak:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Nullable + ref tracking\nfory::field<std::shared_ptr<Node>, 0, fory::nullable, fory::ref> link;\n"})}),"\n",(0,r.jsx)(n.h2,{id:"type-rules",children:"Type Rules"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Allowed Options"}),(0,r.jsx)(n.th,{children:"Nullability"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Primitives, strings"}),(0,r.jsx)(n.td,{children:"None"}),(0,r.jsxs)(n.td,{children:["Use ",(0,r.jsx)(n.code,{children:"std::optional<T>"})," if nullable"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"std::optional<T>"})}),(0,r.jsx)(n.td,{children:"None"}),(0,r.jsx)(n.td,{children:"Inherently nullable"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"std::shared_ptr<T>"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"nullable"}),", ",(0,r.jsx)(n.code,{children:"ref"}),", ",(0,r.jsx)(n.code,{children:"dynamic<V>"})]}),(0,r.jsx)(n.td,{children:"Non-null by default"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"fory::serialization::SharedWeak<T>"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"nullable"}),", ",(0,r.jsx)(n.code,{children:"ref"}),", ",(0,r.jsx)(n.code,{children:"dynamic<V>"})]}),(0,r.jsx)(n.td,{children:"Non-null by default"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"std::unique_ptr<T>"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"nullable"}),", ",(0,r.jsx)(n.code,{children:"dynamic<V>"})]}),(0,r.jsx)(n.td,{children:"Non-null by default"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'#include "fory/serialization/fory.h"\n\nusing namespace fory::serialization;\n\n// Define a struct with various field configurations\nstruct Document {\n  // Required fields (non-nullable)\n  fory::field<std::string, 0> title;\n  fory::field<int32_t, 1> version;\n\n  // Optional primitive using std::optional\n  fory::field<std::optional<std::string>, 2> description;\n\n  // Nullable pointer\n  fory::field<std::unique_ptr<std::string>, 3, fory::nullable> metadata;\n\n  // Reference-tracked shared pointer\n  fory::field<std::shared_ptr<Document>, 4, fory::ref> parent;\n\n  // Nullable + reference-tracked\n  fory::field<std::shared_ptr<Document>, 5, fory::nullable, fory::ref> related;\n};\nFORY_STRUCT(Document, title, version, description, metadata, parent, related);\n\nint main() {\n  auto fory = Fory::builder().xlang(true).build();\n  fory.register_struct<Document>(100);\n\n  Document doc;\n  doc.title = "My Document";\n  doc.version = 1;\n  doc.description = "A sample document";\n  doc.metadata = nullptr;  // Allowed because nullable\n  doc.parent = std::make_shared<Document>();\n  doc.parent->title = "Parent Doc";\n  doc.related = nullptr;  // Allowed because nullable\n\n  auto bytes = fory.serialize(doc).value();\n  auto decoded = fory.deserialize<Document>(bytes).value();\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"compile-time-validation",children:"Compile-Time Validation"}),"\n",(0,r.jsx)(n.p,{children:"Invalid configurations are caught at compile time:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Error: nullable and not_null are mutually exclusive\nfory::field<std::shared_ptr<int>, 0, fory::nullable, fory::not_null> bad1;\n\n// Error: nullable only valid for smart pointers\nfory::field<int32_t, 0, fory::nullable> bad2;\n\n// Error: ref only valid for shared_ptr\nfory::field<std::unique_ptr<int>, 0, fory::ref> bad3;\n\n// Error: options not allowed for std::optional (inherently nullable)\nfory::field<std::optional<int>, 0, fory::nullable> bad4;\n"})}),"\n",(0,r.jsx)(n.h2,{id:"backwards-compatibility",children:"Backwards Compatibility"}),"\n",(0,r.jsxs)(n.p,{children:["Existing structs without ",(0,r.jsx)(n.code,{children:"fory::field<>"})," wrappers continue to work:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Old style - still works\nstruct LegacyPerson {\n  std::string name;\n  int32_t age;\n};\nFORY_STRUCT(LegacyPerson, name, age);\n\n// New style with field metadata\nstruct ModernPerson {\n  fory::field<std::string, 0> name;\n  fory::field<int32_t, 1> age;\n};\nFORY_STRUCT(ModernPerson, name, age);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"fory_field_tags-macro",children:"FORY_FIELD_TAGS Macro"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"FORY_FIELD_TAGS"})," macro provides a non-invasive way to add field metadata without modifying struct definitions. This is useful for:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Third-party types"}),": Add metadata to types you don't own"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Clean structs"}),": Keep struct definitions as pure C++"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Isolated dependencies"}),": Confine Fory headers to serialization config files"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"usage",children:"Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'// user_types.h - NO fory headers needed!\nstruct Document {\n  std::string title;\n  int32_t version;\n  std::optional<std::string> description;\n  std::shared_ptr<User> author;\n  std::shared_ptr<User> reviewer;\n  std::shared_ptr<Document> parent;\n  std::unique_ptr<Data> data;\n};\n\n// serialization_config.cpp - fory config isolated here\n#include "fory/serialization/fory.h"\n#include "user_types.h"\n\nFORY_STRUCT(Document, title, version, description, author, reviewer, parent, data)\n\nFORY_FIELD_TAGS(Document,\n  (title, 0),                      // string: non-nullable\n  (version, 1),                    // int: non-nullable\n  (description, 2),                // optional: inherently nullable\n  (author, 3),                     // shared_ptr: non-nullable (default)\n  (reviewer, 4, nullable),         // shared_ptr: nullable\n  (parent, 5, ref),                // shared_ptr: non-nullable, with ref tracking\n  (data, 6, nullable)              // unique_ptr: nullable\n)\n'})}),"\n",(0,r.jsx)(n.h3,{id:"fory_field_tags-options",children:"FORY_FIELD_TAGS Options"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Field Type"}),(0,r.jsx)(n.th,{children:"Valid Combinations"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Primitives, strings"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"(field, id)"})," only"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"std::optional<T>"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"(field, id)"})," only"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"std::shared_ptr<T>"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"(field, id)"}),", ",(0,r.jsx)(n.code,{children:"(field, id, nullable)"}),", ",(0,r.jsx)(n.code,{children:"(field, id, ref)"}),", ",(0,r.jsx)(n.code,{children:"(field, id, nullable, ref)"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"std::unique_ptr<T>"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"(field, id)"}),", ",(0,r.jsx)(n.code,{children:"(field, id, nullable)"})]})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"fory_field_config-macro",children:"FORY_FIELD_CONFIG Macro"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"FORY_FIELD_CONFIG"})," macro is the most powerful and flexible way to configure field-level serialization. It provides:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Builder pattern API"}),": Fluent, chainable configuration with ",(0,r.jsx)(n.code,{children:"F(id).option1().option2()"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Encoding control"}),": Specify how unsigned integers are encoded (varint, fixed, tagged)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compile-time verification"}),": Field names are verified against member pointers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cross-language compatibility"}),": Configure encoding to match other languages (Java, Rust, etc.)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"basic-syntax",children:"Basic Syntax"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"FORY_FIELD_CONFIG(StructType,\n    (field1, fory::F(0)),                           // Simple: just ID\n    (field2, fory::F(1).nullable()),                // With nullable\n    (field3, fory::F(2).varint()),                  // With encoding\n    (field4, fory::F(3).nullable().ref()),          // Multiple options\n    (field5, 4)                                     // Backward compatible: integer ID\n);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"the-f-builder",children:"The F() Builder"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"fory::F(id)"})," factory creates a ",(0,r.jsx)(n.code,{children:"FieldMeta"})," object that supports method chaining:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"fory::F(0)                    // Create with field ID 0\n    .nullable()               // Mark as nullable\n    .ref()                    // Enable reference tracking\n    .varint()                 // Use variable-length encoding\n    .fixed()                  // Use fixed-size encoding\n    .tagged()                 // Use tagged encoding\n    .dynamic(false)           // skip type info (no dynamic dispatch)\n    .dynamic(true)            // Force type info (enable dynamic dispatch)\n    .compress(false)          // Disable compression\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tip:"})," To use ",(0,r.jsx)(n.code,{children:"F()"})," without the ",(0,r.jsx)(n.code,{children:"fory::"})," prefix, add a using declaration:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"using fory::F;\n\nFORY_FIELD_CONFIG(MyStruct,\n    (field1, F(0).varint()),      // No prefix needed\n    (field2, F(1).nullable())\n);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"encoding-options-for-unsigned-integers",children:"Encoding Options for Unsigned Integers"}),"\n",(0,r.jsxs)(n.p,{children:["For ",(0,r.jsx)(n.code,{children:"uint32_t"})," and ",(0,r.jsx)(n.code,{children:"uint64_t"})," fields, you can specify the wire encoding:"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Method"}),(0,r.jsx)(n.th,{children:"Type ID"}),(0,r.jsx)(n.th,{children:"Description"}),(0,r.jsx)(n.th,{children:"Use Case"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".varint()"})}),(0,r.jsx)(n.td,{children:"VAR_UINT32/64"}),(0,r.jsx)(n.td,{children:"Variable-length encoding (1-5 or 1-10 bytes)"}),(0,r.jsx)(n.td,{children:"Values typically small"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".fixed()"})}),(0,r.jsx)(n.td,{children:"UINT32/64"}),(0,r.jsx)(n.td,{children:"Fixed-size encoding (always 4 or 8 bytes)"}),(0,r.jsx)(n.td,{children:"Values uniformly distributed"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".tagged()"})}),(0,r.jsx)(n.td,{children:"TAGGED_UINT64"}),(0,r.jsx)(n.td,{children:"Tagged hybrid encoding with size hint (uint64)"}),(0,r.jsx)(n.td,{children:"Mixed small and large values (uint64)"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note:"})," ",(0,r.jsx)(n.code,{children:"uint8_t"})," and ",(0,r.jsx)(n.code,{children:"uint16_t"})," always use fixed encoding (UINT8, UINT16)."]}),"\n",(0,r.jsx)(n.h3,{id:"complete-example-1",children:"Complete Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'#include "fory/serialization/fory.h"\n\nusing namespace fory::serialization;\n\n// Define struct with unsigned integer fields\nstruct MetricsData {\n  // Counters - often small values, use varint for space efficiency\n  uint32_t request_count;\n  uint64_t bytes_sent;\n\n  // IDs - uniformly distributed, use fixed for consistent performance\n  uint32_t user_id;\n  uint64_t session_id;\n\n  // Timestamps - use tagged encoding for mixed value ranges\n  uint64_t created_at;\n\n  // Nullable fields\n  std::optional<uint32_t> error_count;\n  std::optional<uint64_t> last_access_time;\n};\n\nFORY_STRUCT(MetricsData, request_count, bytes_sent, user_id, session_id,\n            created_at, error_count, last_access_time);\n\n// Configure field encoding\nFORY_FIELD_CONFIG(MetricsData,\n    // Small counters - varint saves space\n    (request_count, fory::F(0).varint()),\n    (bytes_sent, fory::F(1).varint()),\n\n    // IDs - fixed for consistent performance\n    (user_id, fory::F(2).fixed()),\n    (session_id, fory::F(3).fixed()),\n\n    // Timestamp - tagged encoding\n    (created_at, fory::F(4).tagged()),\n\n    // Nullable fields\n    (error_count, fory::F(5).nullable().varint()),\n    (last_access_time, fory::F(6).nullable().tagged())\n);\n\nint main() {\n  auto fory = Fory::builder().xlang(true).build();\n  fory.register_struct<MetricsData>(100);\n\n  MetricsData data{\n      .request_count = 42,\n      .bytes_sent = 1024,\n      .user_id = 12345678,\n      .session_id = 9876543210,\n      .created_at = 1704067200000000000ULL, // 2024-01-01 in nanoseconds\n      .error_count = 3,\n      .last_access_time = std::nullopt\n  };\n\n  auto bytes = fory.serialize(data).value();\n  auto decoded = fory.deserialize<MetricsData>(bytes).value();\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"cross-language-compatibility",children:"Cross-Language Compatibility"}),"\n",(0,r.jsxs)(n.p,{children:["When serializing data to be read by other languages, use ",(0,r.jsx)(n.code,{children:"FORY_FIELD_CONFIG"})," to match their encoding expectations:"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Java Compatibility:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Java uses these type IDs for unsigned integers:\n// - Byte (u8): UINT8 (fixed)\n// - Short (u16): UINT16 (fixed)\n// - Integer (u32): VAR_UINT32 (varint) or UINT32 (fixed)\n// - Long (u64): VAR_UINT64 (varint), UINT64 (fixed), or TAGGED_UINT64\n\nstruct JavaCompatible {\n  uint8_t byte_field;      // Maps to Java Byte\n  uint16_t short_field;    // Maps to Java Short\n  uint32_t int_var_field;   // Maps to Java Integer with varint\n  uint32_t int_fixed_field; // Maps to Java Integer with fixed\n  uint64_t long_var_field;  // Maps to Java Long with varint\n  uint64_t long_tagged;    // Maps to Java Long with tagged\n};\n\nFORY_STRUCT(JavaCompatible, byte_field, short_field, int_var_field,\n            int_fixed_field, long_var_field, long_tagged);\n\nFORY_FIELD_CONFIG(JavaCompatible,\n    (byte_field, fory::F(0)),                    // UINT8 (auto)\n    (short_field, fory::F(1)),                   // UINT16 (auto)\n    (int_var_field, fory::F(2).varint()),         // VAR_UINT32\n    (int_fixed_field, fory::F(3).fixed()),        // UINT32\n    (long_var_field, fory::F(4).varint()),        // VAR_UINT64\n    (long_tagged, fory::F(5).tagged())           // TAGGED_UINT64\n);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"schema-evolution-with-fory_field_config",children:"Schema Evolution with FORY_FIELD_CONFIG"}),"\n",(0,r.jsx)(n.p,{children:"In compatible mode, fields can have different nullability between sender and receiver:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Version 1: All fields non-nullable\nstruct DataV1 {\n  uint32_t id;\n  uint64_t timestamp;\n};\nFORY_STRUCT(DataV1, id, timestamp);\nFORY_FIELD_CONFIG(DataV1,\n    (id, fory::F(0).varint()),\n    (timestamp, fory::F(1).tagged())\n);\n\n// Version 2: Added nullable fields\nstruct DataV2 {\n  uint32_t id;\n  uint64_t timestamp;\n  std::optional<uint32_t> version;  // New nullable field\n};\nFORY_STRUCT(DataV2, id, timestamp, version);\nFORY_FIELD_CONFIG(DataV2,\n    (id, fory::F(0).varint()),\n    (timestamp, fory::F(1).tagged()),\n    (version, fory::F(2).nullable().varint())  // New field with nullable\n);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"fory_field_config-options-reference",children:"FORY_FIELD_CONFIG Options Reference"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Method"}),(0,r.jsx)(n.th,{children:"Description"}),(0,r.jsx)(n.th,{children:"Valid For"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".nullable()"})}),(0,r.jsx)(n.td,{children:"Mark field as nullable"}),(0,r.jsx)(n.td,{children:"Smart pointers, primitives"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".ref()"})}),(0,r.jsx)(n.td,{children:"Enable reference tracking"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"std::shared_ptr"}),", ",(0,r.jsx)(n.code,{children:"fory::serialization::SharedWeak"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".dynamic(true)"})}),(0,r.jsx)(n.td,{children:"Force type info to be written (dynamic dispatch)"}),(0,r.jsx)(n.td,{children:"Smart pointers"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".dynamic(false)"})}),(0,r.jsx)(n.td,{children:"skip type info (use declared type directly)"}),(0,r.jsx)(n.td,{children:"Smart pointers"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".varint()"})}),(0,r.jsx)(n.td,{children:"Use variable-length encoding"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"uint32_t"}),", ",(0,r.jsx)(n.code,{children:"uint64_t"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".fixed()"})}),(0,r.jsx)(n.td,{children:"Use fixed-size encoding"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"uint32_t"}),", ",(0,r.jsx)(n.code,{children:"uint64_t"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".tagged()"})}),(0,r.jsx)(n.td,{children:"Use tagged hybrid encoding"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"uint64_t"})," only"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".compress(v)"})}),(0,r.jsx)(n.td,{children:"Enable/disable field compression"}),(0,r.jsx)(n.td,{children:"All types"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"default-values",children:"Default Values"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Nullable"}),": Only ",(0,r.jsx)(n.code,{children:"std::optional<T>"})," is nullable by default; all other types (including ",(0,r.jsx)(n.code,{children:"std::shared_ptr"}),") are non-nullable"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Ref tracking"}),": Enabled by default for ",(0,r.jsx)(n.code,{children:"std::shared_ptr<T>"})," and ",(0,r.jsx)(n.code,{children:"fory::serialization::SharedWeak<T>"}),", disabled for other types unless configured"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["You ",(0,r.jsx)(n.strong,{children:"need to configure fields"})," when:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A field can be null (use ",(0,r.jsx)(n.code,{children:"std::optional<T>"})," or mark with ",(0,r.jsx)(n.code,{children:"nullable()"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["A field needs reference tracking for shared/circular objects (use ",(0,r.jsx)(n.code,{children:"ref()"}),")"]}),"\n",(0,r.jsx)(n.li,{children:"Integer types need specific encoding for cross-language compatibility"}),"\n",(0,r.jsx)(n.li,{children:"You want to reduce metadata size (use field IDs)"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Xlang mode: explicit configuration required\nstruct User {\n    std::string name;                              // Non-nullable by default\n    std::optional<std::string> email;              // Nullable (std::optional)\n    std::shared_ptr<User> friend_ptr;              // Ref tracking by default\n};\n\nFORY_STRUCT(User, name, email, friend_ptr);\n\nFORY_FIELD_CONFIG(User,\n    (name, fory::F(0)),\n    (email, fory::F(1)),                           // nullable implicit for optional\n    (friend_ptr, fory::F(2).nullable().ref())      // explicit nullable + ref\n);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"default-values-summary",children:"Default Values Summary"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Default Nullable"}),(0,r.jsx)(n.th,{children:"Default Ref Tracking"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:["Primitives, ",(0,r.jsx)(n.code,{children:"string"})]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"false"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"false"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"std::optional<T>"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"false"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"std::shared_ptr<T>"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"false"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"fory::serialization::SharedWeak<T>"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"false"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"std::unique_ptr<T>"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"false"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"false"})})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/next/guide/cpp/type_registration",children:"Type Registration"})," - Registering types with FORY_STRUCT"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/next/guide/cpp/schema_evolution",children:"Schema Evolution"})," - Using tag IDs for schema evolution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/next/guide/cpp/configuration",children:"Configuration"})," - Enabling reference tracking globally"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/next/guide/cpp/cross_language",children:"Cross-Language"})," - Interoperability with Java, Rust, Python"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>d,a:()=>t});var r=i(67294);const l={},s=r.createContext(l);function t(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:t(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);