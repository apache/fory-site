"use strict";(self.webpackChunkfory_site=self.webpackChunkfory_site||[]).push([[51081],{61700:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var t=i(85893),s=i(11151);const r={title:"Schema Evolution",sidebar_position:70,id:"schema_evolution",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},a=void 0,o={id:"guide/go/schema_evolution",title:"Schema Evolution",description:"Schema evolution allows your data structures to change over time while maintaining compatibility with previously serialized data. Fory Go supports this through compatible mode.",source:"@site/versioned_docs/version-0.15/guide/go/schema-evolution.md",sourceDirName:"guide/go",slug:"/guide/go/schema_evolution",permalink:"/docs/guide/go/schema_evolution",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/fory-site/tree/main/docs/guide/go/schema-evolution.md",tags:[],version:"0.15",sidebarPosition:70,frontMatter:{title:"Schema Evolution",sidebar_position:70,id:"schema_evolution",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},sidebar:"docsSidebar",previous:{title:"Field Configuration",permalink:"/docs/guide/go/struct_tags"},next:{title:"Cross-Language Serialization",permalink:"/docs/guide/go/cross_language"}},l={},d=[{value:"Enabling Compatible Mode",id:"enabling-compatible-mode",level:2},{value:"How It Works",id:"how-it-works",level:2},{value:"Without Compatible Mode (Default)",id:"without-compatible-mode-default",level:3},{value:"With Compatible Mode",id:"with-compatible-mode",level:3},{value:"Disable Evolution for Stable Structs",id:"disable-evolution-for-stable-structs",level:3},{value:"Supported Schema Changes",id:"supported-schema-changes",level:2},{value:"Adding Fields",id:"adding-fields",level:3},{value:"Removing Fields",id:"removing-fields",level:3},{value:"Reordering Fields",id:"reordering-fields",level:3},{value:"Incompatible Changes",id:"incompatible-changes",level:2},{value:"Type Changes",id:"type-changes",level:3},{value:"Renaming Fields",id:"renaming-fields",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Use Compatible Mode for Persistent Data",id:"1-use-compatible-mode-for-persistent-data",level:3},{value:"2. Provide Default Values",id:"2-provide-default-values",level:3},{value:"Cross-Language Schema Evolution",id:"cross-language-schema-evolution",level:2},{value:"Go (Producer)",id:"go-producer",level:3},{value:"Java (Consumer with newer schema)",id:"java-consumer-with-newer-schema",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Hash Mismatch (Schema Consistent Mode)",id:"hash-mismatch-schema-consistent-mode",level:3},{value:"Unknown Fields",id:"unknown-fields",level:3},{value:"Complete Example",id:"complete-example",level:2},{value:"Related Topics",id:"related-topics",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Schema evolution allows your data structures to change over time while maintaining compatibility with previously serialized data. Fory Go supports this through compatible mode."}),"\n",(0,t.jsx)(n.h2,{id:"enabling-compatible-mode",children:"Enabling Compatible Mode"}),"\n",(0,t.jsx)(n.p,{children:"Enable compatible mode when creating a Fory instance:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"f := fory.New(fory.WithCompatible(true))\n"})}),"\n",(0,t.jsx)(n.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,t.jsx)(n.h3,{id:"without-compatible-mode-default",children:"Without Compatible Mode (Default)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Compact serialization without metadata"}),"\n",(0,t.jsx)(n.li,{children:"Struct hash is checked during deserialization"}),"\n",(0,t.jsxs)(n.li,{children:["Any schema change causes ",(0,t.jsx)(n.code,{children:"ErrKindHashMismatch"})]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"with-compatible-mode",children:"With Compatible Mode"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Type metadata is written to serialized data"}),"\n",(0,t.jsx)(n.li,{children:"Supports adding, removing, and reordering fields"}),"\n",(0,t.jsx)(n.li,{children:"Enables forward and backward compatibility"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"disable-evolution-for-stable-structs",children:"Disable Evolution for Stable Structs"}),"\n",(0,t.jsxs)(n.p,{children:["If a struct schema is stable and will not change, you can disable evolution for that struct to avoid compatible metadata overhead. Implement the ",(0,t.jsx)(n.code,{children:"ForyEvolving"})," interface and return ",(0,t.jsx)(n.code,{children:"false"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"type StableMessage struct {\n    ID int64\n}\n\nfunc (StableMessage) ForyEvolving() bool {\n    return false\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"supported-schema-changes",children:"Supported Schema Changes"}),"\n",(0,t.jsx)(n.h3,{id:"adding-fields",children:"Adding Fields"}),"\n",(0,t.jsx)(n.p,{children:"New fields can be added; they receive zero values when deserializing old data:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'// Version 1\ntype UserV1 struct {\n    ID   int64\n    Name string\n}\n\n// Version 2 (added Email)\ntype UserV2 struct {\n    ID    int64\n    Name  string\n    Email string  // New field\n}\n\nf := fory.New(fory.WithCompatible(true))\nf.RegisterStruct(UserV1{}, 1)\n\n// Serialize with V1\nuserV1 := &UserV1{ID: 1, Name: "Alice"}\ndata, _ := f.Serialize(userV1)\n\n// Deserialize with V2\nf2 := fory.New(fory.WithCompatible(true))\nf2.RegisterStruct(UserV2{}, 1)\n\nvar userV2 UserV2\nf2.Deserialize(data, &userV2)\n// userV2.Email = "" (zero value)\n'})}),"\n",(0,t.jsx)(n.h3,{id:"removing-fields",children:"Removing Fields"}),"\n",(0,t.jsx)(n.p,{children:"Removed fields are skipped during deserialization:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'// Version 1\ntype ConfigV1 struct {\n    Host     string\n    Port     int32\n    Timeout  int64\n    Debug    bool  // Will be removed\n}\n\n// Version 2 (removed Debug)\ntype ConfigV2 struct {\n    Host    string\n    Port    int32\n    Timeout int64\n    // Debug field removed\n}\n\nf := fory.New(fory.WithCompatible(true))\nf.RegisterStruct(ConfigV1{}, 1)\n\n// Serialize with V1\nconfig := &ConfigV1{Host: "localhost", Port: 8080, Timeout: 30, Debug: true}\ndata, _ := f.Serialize(config)\n\n// Deserialize with V2\nf2 := fory.New(fory.WithCompatible(true))\nf2.RegisterStruct(ConfigV2{}, 1)\n\nvar configV2 ConfigV2\nf2.Deserialize(data, &configV2)\n// Debug field data is skipped\n'})}),"\n",(0,t.jsx)(n.h3,{id:"reordering-fields",children:"Reordering Fields"}),"\n",(0,t.jsx)(n.p,{children:"Field order can change between versions:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"// Version 1\ntype PersonV1 struct {\n    FirstName string\n    LastName  string\n    Age       int32\n}\n\n// Version 2 (reordered)\ntype PersonV2 struct {\n    Age       int32   // Moved up\n    LastName  string\n    FirstName string  // Moved down\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Compatible mode handles this automatically by matching fields by name."}),"\n",(0,t.jsx)(n.h2,{id:"incompatible-changes",children:"Incompatible Changes"}),"\n",(0,t.jsx)(n.p,{children:"Some changes are NOT supported, even in compatible mode:"}),"\n",(0,t.jsx)(n.h3,{id:"type-changes",children:"Type Changes"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"// NOT SUPPORTED\ntype V1 struct {\n    Value int32  // int32\n}\n\ntype V2 struct {\n    Value string  // Changed to string - INCOMPATIBLE\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"renaming-fields",children:"Renaming Fields"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"// NOT SUPPORTED (treated as remove + add)\ntype V1 struct {\n    UserName string\n}\n\ntype V2 struct {\n    Username string  // Different name - NOT a rename\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This is treated as removing ",(0,t.jsx)(n.code,{children:"UserName"})," and adding ",(0,t.jsx)(n.code,{children:"Username"}),", resulting in data loss."]}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"1-use-compatible-mode-for-persistent-data",children:"1. Use Compatible Mode for Persistent Data"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"// For data stored in databases, files, or caches\nf := fory.New(fory.WithCompatible(true))\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-provide-default-values",children:"2. Provide Default Values"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"type ConfigV2 struct {\n    Host    string\n    Port    int32\n    Timeout int64\n    Retries int32  // New field\n}\n\nfunc NewConfigV2() *ConfigV2 {\n    return &ConfigV2{\n        Retries: 3,  // Default value\n    }\n}\n\n// After deserialize, apply defaults\nif config.Retries == 0 {\n    config.Retries = 3\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"cross-language-schema-evolution",children:"Cross-Language Schema Evolution"}),"\n",(0,t.jsx)(n.p,{children:"Schema evolution works across languages:"}),"\n",(0,t.jsx)(n.h3,{id:"go-producer",children:"Go (Producer)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'type MessageV1 struct {\n    ID      int64\n    Content string\n}\n\nf := fory.New(fory.WithCompatible(true))\nf.RegisterStruct(MessageV1{}, 1)\ndata, _ := f.Serialize(&MessageV1{ID: 1, Content: "Hello"})\n'})}),"\n",(0,t.jsx)(n.h3,{id:"java-consumer-with-newer-schema",children:"Java (Consumer with newer schema)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public class Message {\n    long id;\n    String content;\n    String author;  // New field in Java\n}\n\nFory fory = Fory.builder()\n    .withXlang(true)\n    .withCompatibleMode(true)\n    .build();\nfory.register(Message.class, 1);\nMessage msg = fory.deserialize(data, Message.class);\n// msg.author will be null\n"})}),"\n",(0,t.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsx)(n.p,{children:"Compatible mode mainly affects serialized size:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Aspect"}),(0,t.jsx)(n.th,{children:"Schema Consistent"}),(0,t.jsx)(n.th,{children:"Compatible Mode"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Serialized Size"}),(0,t.jsx)(n.td,{children:"Smaller"}),(0,t.jsx)(n.td,{children:"Larger (includes metadata, especially without field IDs)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Speed"}),(0,t.jsx)(n.td,{children:"Fast"}),(0,t.jsx)(n.td,{children:"Similar (metadata is just memcpy)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Schema Flexibility"}),(0,t.jsx)(n.td,{children:"None"}),(0,t.jsx)(n.td,{children:"Full"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"}),": Using field IDs (",(0,t.jsx)(n.code,{children:'fory:"id=N"'}),") reduces metadata size in compatible mode."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Recommendation"}),": Use compatible mode for:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Persistent storage"}),"\n",(0,t.jsx)(n.li,{children:"Cross-service communication"}),"\n",(0,t.jsx)(n.li,{children:"Long-lived caches"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Use schema consistent mode for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"In-memory operations"}),"\n",(0,t.jsx)(n.li,{children:"Same-version communication"}),"\n",(0,t.jsx)(n.li,{children:"Minimum serialized size"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsx)(n.h3,{id:"hash-mismatch-schema-consistent-mode",children:"Hash Mismatch (Schema Consistent Mode)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"f := fory.New()  // Compatible mode disabled\n\n// Schema changed without compatible mode\nerr := f.Deserialize(oldData, &newStruct)\n// Error: ErrKindHashMismatch\n"})}),"\n",(0,t.jsx)(n.h3,{id:"unknown-fields",children:"Unknown Fields"}),"\n",(0,t.jsx)(n.p,{children:"In compatible mode, unknown fields are skipped silently. To detect them:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"// Currently, Fory skips unknown fields automatically\n// No explicit API for detecting unknown fields\n"})}),"\n",(0,t.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "github.com/apache/fory/go/fory"\n)\n\n// V1: Initial schema\ntype ProductV1 struct {\n    ID    int64\n    Name  string\n    Price float64\n}\n\n// V2: Added fields\ntype ProductV2 struct {\n    ID          int64\n    Name        string\n    Price       float64\n    Description string  // New\n    InStock     bool    // New\n}\n\nfunc main() {\n    // Serialize with V1\n    f1 := fory.New(fory.WithCompatible(true))\n    f1.RegisterStruct(ProductV1{}, 1)\n\n    product := &ProductV1{ID: 1, Name: "Widget", Price: 9.99}\n    data, _ := f1.Serialize(product)\n    fmt.Printf("V1 serialized: %d bytes\\n", len(data))\n\n    // Deserialize with V2\n    f2 := fory.New(fory.WithCompatible(true))\n    f2.RegisterStruct(ProductV2{}, 1)\n\n    var productV2 ProductV2\n    if err := f2.Deserialize(data, &productV2); err != nil {\n        panic(err)\n    }\n\n    fmt.Printf("ID: %d\\n", productV2.ID)\n    fmt.Printf("Name: %s\\n", productV2.Name)\n    fmt.Printf("Price: %.2f\\n", productV2.Price)\n    fmt.Printf("Description: %q (zero value)\\n", productV2.Description)\n    fmt.Printf("InStock: %v (zero value)\\n", productV2.InStock)\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/guide/go/configuration",children:"Configuration"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/guide/go/cross_language",children:"Cross-Language Serialization"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/guide/go/troubleshooting",children:"Troubleshooting"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>o,a:()=>a});var t=i(67294);const s={},r=t.createContext(s);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);