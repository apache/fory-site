"use strict";(self.webpackChunkfory_site=self.webpackChunkfory_site||[]).push([[62883],{85134:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>g,frontMatter:()=>t,metadata:()=>o,toc:()=>c});var s=i(85893),r=i(11151);const t={title:"Type Registration",sidebar_position:30,id:"type_registration",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},a=void 0,o={id:"guide/go/type_registration",title:"Type Registration",description:"Type registration tells Fory how to identify and serialize your custom types. Registration is required for struct, enum, and extension types.",source:"@site/versioned_docs/version-0.15/guide/go/type-registration.md",sourceDirName:"guide/go",slug:"/guide/go/type_registration",permalink:"/docs/guide/go/type_registration",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/fory-site/tree/main/docs/guide/go/type-registration.md",tags:[],version:"0.15",sidebarPosition:30,frontMatter:{title:"Type Registration",sidebar_position:30,id:"type_registration",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},sidebar:"docsSidebar",previous:{title:"Basic Serialization",permalink:"/docs/guide/go/basic_serialization"},next:{title:"Custom Serializers",permalink:"/docs/guide/go/custom_serializers"}},l={},c=[{value:"Why Register Types?",id:"why-register-types",level:2},{value:"Struct Registration",id:"struct-registration",level:2},{value:"Register by ID",id:"register-by-id",level:3},{value:"Register by Name",id:"register-by-name",level:3},{value:"Enum Registration",id:"enum-registration",level:2},{value:"Register by ID",id:"register-by-id-1",level:3},{value:"Register by Name",id:"register-by-name-1",level:3},{value:"Extension Types",id:"extension-types",level:2},{value:"Registration Scope",id:"registration-scope",level:2},{value:"Registration Timing",id:"registration-timing",level:2},{value:"Nested Type Registration",id:"nested-type-registration",level:2},{value:"Cross-Language Registration",id:"cross-language-registration",level:2},{value:"Using IDs",id:"using-ids",level:3},{value:"Using Names",id:"using-names",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Common Errors",id:"common-errors",level:2},{value:"Unregistered Type",id:"unregistered-type",level:3},{value:"ID/Name Mismatch",id:"idname-mismatch",level:3},{value:"Duplicate Registration",id:"duplicate-registration",level:3},{value:"Related Topics",id:"related-topics",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Type registration tells Fory how to identify and serialize your custom types. Registration is required for struct, enum, and extension types."}),"\n",(0,s.jsx)(n.h2,{id:"why-register-types",children:"Why Register Types?"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type Identification"}),": Fory needs to identify the actual type during deserialization"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Polymorphism"}),": When deserializing interface types, Fory must know which concrete type to create"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cross-Language Compatibility"}),": Other languages need to recognize and deserialize your types"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"struct-registration",children:"Struct Registration"}),"\n",(0,s.jsx)(n.h3,{id:"register-by-id",children:"Register by ID"}),"\n",(0,s.jsx)(n.p,{children:"Register a struct with a numeric type ID for compact serialization:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"type User struct {\n    ID   int64\n    Name string\n}\n\nf := fory.New()\nerr := f.RegisterStruct(User{}, 1)\nif err != nil {\n    panic(err)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"ID Guidelines"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"IDs must be unique within your application"}),"\n",(0,s.jsx)(n.li,{children:"IDs must be consistent across all languages for cross-language serialization"}),"\n",(0,s.jsx)(n.li,{children:"Use the same ID for the same type in serializer and deserializer"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"register-by-name",children:"Register by Name"}),"\n",(0,s.jsx)(n.p,{children:"Register a struct with a type name string. This is more flexible but has higher serialization cost:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'f := fory.New()\nerr := f.RegisterNamedStruct(User{}, "example.User")\nif err != nil {\n    panic(err)\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Name Guidelines"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Use fully-qualified names following ",(0,s.jsx)(n.code,{children:"namespace.TypeName"})," convention"]}),"\n",(0,s.jsx)(n.li,{children:"Names must be unique and consistent across all languages"}),"\n",(0,s.jsx)(n.li,{children:"Names are case-sensitive"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"enum-registration",children:"Enum Registration"}),"\n",(0,s.jsx)(n.p,{children:"Go doesn't have native enums, but you can register integer types as enums:"}),"\n",(0,s.jsx)(n.h3,{id:"register-by-id-1",children:"Register by ID"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"type Status int32\n\nconst (\n    StatusPending  Status = 0\n    StatusActive   Status = 1\n    StatusComplete Status = 2\n)\n\nf := fory.New()\nerr := f.RegisterEnum(Status(0), 1)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"register-by-name-1",children:"Register by Name"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'err := f.RegisterNamedEnum(Status(0), "example.Status")\n'})}),"\n",(0,s.jsx)(n.h2,{id:"extension-types",children:"Extension Types"}),"\n",(0,s.jsx)(n.p,{children:"For types requiring custom serialization logic, register as extension types with a custom serializer:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'f := fory.New()\n\n// Register by ID\nerr := f.RegisterExtension(CustomType{}, 1, &CustomSerializer{})\n\n// Or register by name\nerr = f.RegisterNamedExtension(CustomType{}, "example.Custom", &CustomSerializer{})\n'})}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/docs/guide/go/custom_serializers",children:"Custom Serializers"})," for details on implementing the ",(0,s.jsx)(n.code,{children:"ExtensionSerializer"})," interface."]}),"\n",(0,s.jsx)(n.h2,{id:"registration-scope",children:"Registration Scope"}),"\n",(0,s.jsx)(n.p,{children:"Type registration is per-Fory-instance:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"f1 := fory.New()\nf2 := fory.New()\n\n// Types registered on f1 are NOT available on f2\nf1.RegisterStruct(User{}, 1)\n\n// f2 cannot deserialize User unless also registered\nf2.RegisterStruct(User{}, 1)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"registration-timing",children:"Registration Timing"}),"\n",(0,s.jsx)(n.p,{children:"Register types after creating a Fory instance and before any serialize/deserialize calls:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'f := fory.New()\n\n// Register before use\nf.RegisterStruct(User{}, 1)\nf.RegisterStruct(Order{}, 2)\n\n// Now serialize/deserialize\ndata, _ := f.Serialize(&User{ID: 1, Name: "Alice"})\n'})}),"\n",(0,s.jsx)(n.h2,{id:"nested-type-registration",children:"Nested Type Registration"}),"\n",(0,s.jsx)(n.p,{children:"Register all struct types in the object graph, including nested types:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"type Address struct {\n    City    string\n    Country string\n}\n\ntype Person struct {\n    Name    string\n    Address Address\n}\n\nf := fory.New()\n\n// Register ALL struct types used in the object graph\nf.RegisterStruct(Address{}, 1)\nf.RegisterStruct(Person{}, 2)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"cross-language-registration",children:"Cross-Language Registration"}),"\n",(0,s.jsx)(n.p,{children:"For cross-language serialization, types must be registered consistently across all languages."}),"\n",(0,s.jsx)(n.h3,{id:"using-ids",children:"Using IDs"}),"\n",(0,s.jsx)(n.p,{children:"All languages use the same numeric ID:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Go"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"f.RegisterStruct(User{}, 1)\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Java"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"fory.register(User.class, 1);\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Python"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"fory.register(User, type_id=1)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"using-names",children:"Using Names"}),"\n",(0,s.jsx)(n.p,{children:"All languages use the same type name:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Go"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'f.RegisterNamedStruct(User{}, "example.User")\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Java"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'fory.register(User.class, "example.User");\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Python"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'fory.register(User, typename="example.User")\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Rust"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use fory::{Fory, ForyObject};\n\n#[derive(ForyObject)]\nstruct User {\n    id: i64,\n    name: String,\n}\n\nlet mut fory = Fory::default();\nfory.register_by_name::<User>("example.User")?;\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Register early"}),": Register all types at application startup before any serialization"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Be consistent"}),": Use the same ID or name across all languages and all instances"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Register all types"}),": Include nested struct types, not just top-level types"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Prefer IDs for performance"}),": Numeric IDs have lower serialization overhead than names"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use names for flexibility"}),": Names are easier to manage and less prone to conflicts"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"common-errors",children:"Common Errors"}),"\n",(0,s.jsx)(n.h3,{id:"unregistered-type",children:"Unregistered Type"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"error: unknown type encountered\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution"}),": Register the type before serialization/deserialization."]}),"\n",(0,s.jsx)(n.h3,{id:"idname-mismatch",children:"ID/Name Mismatch"}),"\n",(0,s.jsx)(n.p,{children:"Data serialized with one ID or name cannot be deserialized if registered with a different ID or name."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution"}),": Use consistent IDs or names across serializer and deserializer."]}),"\n",(0,s.jsx)(n.h3,{id:"duplicate-registration",children:"Duplicate Registration"}),"\n",(0,s.jsx)(n.p,{children:"Two types registered with the same ID will conflict."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution"}),": Ensure unique IDs for each type."]}),"\n",(0,s.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/guide/go/basic_serialization",children:"Basic Serialization"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/guide/go/cross_language",children:"Cross-Language Serialization"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/guide/go/supported_types",children:"Supported Types"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/guide/go/troubleshooting",children:"Troubleshooting"})}),"\n"]})]})}function g(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>o,a:()=>a});var s=i(67294);const r={},t=s.createContext(r);function a(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);