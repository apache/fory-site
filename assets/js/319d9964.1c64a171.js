"use strict";(self.webpackChunkfory_site=self.webpackChunkfory_site||[]).push([[72921],{68499:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>d,toc:()=>o});var i=s(85893),t=s(11151);const r={title:"Schema Evolution",sidebar_position:3,id:"schema_evolution",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},a=void 0,d={id:"guide/cpp/schema_evolution",title:"Schema Evolution",description:"Apache Fory\u2122 supports schema evolution in Compatible mode, allowing serialization and deserialization peers to have different type definitions.",source:"@site/versioned_docs/version-0.14/guide/cpp/schema-evolution.md",sourceDirName:"guide/cpp",slug:"/guide/cpp/schema_evolution",permalink:"/docs/0.14/guide/cpp/schema_evolution",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/fory-site/tree/main/docs/guide/cpp/schema-evolution.md",tags:[],version:"0.14",sidebarPosition:3,frontMatter:{title:"Schema Evolution",sidebar_position:3,id:"schema_evolution",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},sidebar:"docsSidebar",previous:{title:"Basic Serialization",permalink:"/docs/0.14/guide/cpp/basic_serialization"},next:{title:"Type Registration",permalink:"/docs/0.14/guide/cpp/type_registration"}},l={},o=[{value:"Compatible Mode",id:"compatible-mode",level:2},{value:"Schema Evolution Features",id:"schema-evolution-features",level:2},{value:"Adding Fields (Backward Compatibility)",id:"adding-fields-backward-compatibility",level:2},{value:"Removing Fields (Forward Compatibility)",id:"removing-fields-forward-compatibility",level:2},{value:"Field Reordering",id:"field-reordering",level:2},{value:"Nested Struct Evolution",id:"nested-struct-evolution",level:2},{value:"Bidirectional Evolution",id:"bidirectional-evolution",level:2},{value:"Default Values",id:"default-values",level:2},{value:"Schema Consistent Mode (Default)",id:"schema-consistent-mode-default",level:2},{value:"Type ID Requirements",id:"type-id-requirements",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Plan for Evolution",id:"1-plan-for-evolution",level:3},{value:"2. Use Meaningful Default Values",id:"2-use-meaningful-default-values",level:3},{value:"3. Document Schema Versions",id:"3-document-schema-versions",level:3},{value:"4. Test Evolution Paths",id:"4-test-evolution-paths",level:3},{value:"Cross-Language Schema Evolution",id:"cross-language-schema-evolution",level:2},{value:"Related Topics",id:"related-topics",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Apache Fory\u2122 supports schema evolution in ",(0,i.jsx)(n.strong,{children:"Compatible mode"}),", allowing serialization and deserialization peers to have different type definitions."]}),"\n",(0,i.jsx)(n.h2,{id:"compatible-mode",children:"Compatible Mode"}),"\n",(0,i.jsxs)(n.p,{children:["Enable schema evolution with ",(0,i.jsx)(n.code,{children:"compatible(true)"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include "fory/serialization/fory.h"\n\nusing namespace fory::serialization;\n\n// Version 1: Original schema\nstruct PersonV1 {\n  std::string name;\n  int32_t age;\n};\nFORY_STRUCT(PersonV1, name, age);\n\n// Version 2: Added email field\nstruct PersonV2 {\n  std::string name;\n  int32_t age;\n  std::string email;  // NEW FIELD\n};\nFORY_STRUCT(PersonV2, name, age, email);\n\nint main() {\n  // Create separate Fory instances for each schema version\n  auto fory_v1 = Fory::builder()\n      .compatible(true)  // Enable schema evolution\n      .xlang(true)\n      .build();\n\n  auto fory_v2 = Fory::builder()\n      .compatible(true)\n      .xlang(true)\n      .build();\n\n  // Register with the SAME type ID for schema evolution\n  constexpr uint32_t PERSON_TYPE_ID = 100;\n  fory_v1.register_struct<PersonV1>(PERSON_TYPE_ID);\n  fory_v2.register_struct<PersonV2>(PERSON_TYPE_ID);\n\n  // Serialize with V1\n  PersonV1 v1{"Alice", 30};\n  auto bytes = fory_v1.serialize(v1).value();\n\n  // Deserialize as V2 - email gets default value (empty string)\n  auto v2 = fory_v2.deserialize<PersonV2>(bytes).value();\n  assert(v2.name == "Alice");\n  assert(v2.age == 30);\n  assert(v2.email == "");  // Default value for missing field\n\n  return 0;\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"schema-evolution-features",children:"Schema Evolution Features"}),"\n",(0,i.jsx)(n.p,{children:"Compatible mode supports the following schema changes:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Change Type"}),(0,i.jsx)(n.th,{children:"Support"}),(0,i.jsx)(n.th,{children:"Behavior"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Add new fields"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"Missing fields use default values"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Remove fields"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"Extra fields are skipped"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Reorder fields"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"Fields matched by name, not position"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Change nullability"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"T"})," \u2194 ",(0,i.jsx)(n.code,{children:"std::optional<T>"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Change field types"}),(0,i.jsx)(n.td,{children:"\u274c"}),(0,i.jsx)(n.td,{children:"Types must be compatible"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Rename fields"}),(0,i.jsx)(n.td,{children:"\u274c"}),(0,i.jsx)(n.td,{children:"Field names must match (case-sensitive)"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"adding-fields-backward-compatibility",children:"Adding Fields (Backward Compatibility)"}),"\n",(0,i.jsx)(n.p,{children:"When deserializing old data with a new schema that has additional fields:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// Old schema (V1)\nstruct ProductV1 {\n  std::string name;\n  double price;\n};\nFORY_STRUCT(ProductV1, name, price);\n\n// New schema (V2) with additional fields\nstruct ProductV2 {\n  std::string name;\n  double price;\n  std::vector<std::string> tags;       // NEW\n  std::map<std::string, std::string> attributes;  // NEW\n};\nFORY_STRUCT(ProductV2, name, price, tags, attributes);\n\n// Serialize V1\nProductV1 v1{"Laptop", 999.99};\nauto bytes = fory_v1.serialize(v1).value();\n\n// Deserialize as V2\nauto v2 = fory_v2.deserialize<ProductV2>(bytes).value();\nassert(v2.name == "Laptop");\nassert(v2.price == 999.99);\nassert(v2.tags.empty());        // Default: empty vector\nassert(v2.attributes.empty());  // Default: empty map\n'})}),"\n",(0,i.jsx)(n.h2,{id:"removing-fields-forward-compatibility",children:"Removing Fields (Forward Compatibility)"}),"\n",(0,i.jsx)(n.p,{children:"When deserializing new data with an old schema that has fewer fields:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// Full schema\nstruct UserFull {\n  int64_t id;\n  std::string username;\n  std::string email;\n  std::string password_hash;\n  int32_t login_count;\n};\nFORY_STRUCT(UserFull, id, username, email, password_hash, login_count);\n\n// Minimal schema (removed 3 fields)\nstruct UserMinimal {\n  int64_t id;\n  std::string username;\n};\nFORY_STRUCT(UserMinimal, id, username);\n\n// Serialize full version\nUserFull full{12345, "johndoe", "john@example.com", "hash123", 42};\nauto bytes = fory_full.serialize(full).value();\n\n// Deserialize as minimal - extra fields are skipped\nauto minimal = fory_minimal.deserialize<UserMinimal>(bytes).value();\nassert(minimal.id == 12345);\nassert(minimal.username == "johndoe");\n// email, password_hash, login_count are skipped\n'})}),"\n",(0,i.jsx)(n.h2,{id:"field-reordering",children:"Field Reordering"}),"\n",(0,i.jsx)(n.p,{children:"In compatible mode, fields are matched by name, not by position:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// Original field order\nstruct ConfigOriginal {\n  std::string host;\n  int32_t port;\n  bool enable_ssl;\n  std::string protocol;\n};\nFORY_STRUCT(ConfigOriginal, host, port, enable_ssl, protocol);\n\n// Reordered fields\nstruct ConfigReordered {\n  bool enable_ssl;      // Moved to first\n  std::string protocol; // Moved to second\n  std::string host;     // Moved to third\n  int32_t port;         // Moved to last\n};\nFORY_STRUCT(ConfigReordered, enable_ssl, protocol, host, port);\n\n// Serialize with original order\nConfigOriginal orig{"localhost", 8080, true, "https"};\nauto bytes = fory_orig.serialize(orig).value();\n\n// Deserialize with different field order - works correctly\nauto reordered = fory_reord.deserialize<ConfigReordered>(bytes).value();\nassert(reordered.host == "localhost");\nassert(reordered.port == 8080);\nassert(reordered.enable_ssl == true);\nassert(reordered.protocol == "https");\n'})}),"\n",(0,i.jsx)(n.h2,{id:"nested-struct-evolution",children:"Nested Struct Evolution"}),"\n",(0,i.jsx)(n.p,{children:"Schema evolution works recursively for nested structs:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// V1 Address\nstruct AddressV1 {\n  std::string street;\n  std::string city;\n};\nFORY_STRUCT(AddressV1, street, city);\n\n// V2 Address with new fields\nstruct AddressV2 {\n  std::string street;\n  std::string city;\n  std::string country;  // NEW\n  std::string zipcode;  // NEW\n};\nFORY_STRUCT(AddressV2, street, city, country, zipcode);\n\n// V1 Employee with V1 Address\nstruct EmployeeV1 {\n  std::string name;\n  AddressV1 home_address;\n};\nFORY_STRUCT(EmployeeV1, name, home_address);\n\n// V2 Employee with V2 Address and new field\nstruct EmployeeV2 {\n  std::string name;\n  AddressV2 home_address;  // Nested struct evolved\n  std::string employee_id; // NEW\n};\nFORY_STRUCT(EmployeeV2, name, home_address, employee_id);\n\n// Register types with same IDs\nconstexpr uint32_t ADDRESS_TYPE_ID = 100;\nconstexpr uint32_t EMPLOYEE_TYPE_ID = 101;\n\nfory_v1.register_struct<AddressV1>(ADDRESS_TYPE_ID);\nfory_v1.register_struct<EmployeeV1>(EMPLOYEE_TYPE_ID);\nfory_v2.register_struct<AddressV2>(ADDRESS_TYPE_ID);\nfory_v2.register_struct<EmployeeV2>(EMPLOYEE_TYPE_ID);\n\n// Serialize V1\nEmployeeV1 emp_v1{"Jane Doe", {"123 Main St", "NYC"}};\nauto bytes = fory_v1.serialize(emp_v1).value();\n\n// Deserialize as V2\nauto emp_v2 = fory_v2.deserialize<EmployeeV2>(bytes).value();\nassert(emp_v2.name == "Jane Doe");\nassert(emp_v2.home_address.street == "123 Main St");\nassert(emp_v2.home_address.city == "NYC");\nassert(emp_v2.home_address.country == "");  // Default\nassert(emp_v2.home_address.zipcode == "");  // Default\nassert(emp_v2.employee_id == "");           // Default\n'})}),"\n",(0,i.jsx)(n.h2,{id:"bidirectional-evolution",children:"Bidirectional Evolution"}),"\n",(0,i.jsx)(n.p,{children:"Schema evolution works in both directions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// V2 -> V1 (downgrade)\nPersonV2 v2{"Charlie", 35, "charlie@example.com"};\nauto bytes = fory_v2.serialize(v2).value();\n\nauto v1 = fory_v1.deserialize<PersonV1>(bytes).value();\nassert(v1.name == "Charlie");\nassert(v1.age == 35);\n// email field is discarded during deserialization\n'})}),"\n",(0,i.jsx)(n.h2,{id:"default-values",children:"Default Values"}),"\n",(0,i.jsx)(n.p,{children:"When fields are missing, C++ default initialization is used:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Default Value"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"int8_t"}),", ",(0,i.jsx)(n.code,{children:"int16_t"}),"..."]}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"0"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"float"}),", ",(0,i.jsx)(n.code,{children:"double"})]}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"0.0"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"bool"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"false"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"std::string"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:'""'})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"std::vector<T>"})}),(0,i.jsx)(n.td,{children:"Empty vector"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"std::map<K,V>"})}),(0,i.jsx)(n.td,{children:"Empty map"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"std::set<T>"})}),(0,i.jsx)(n.td,{children:"Empty set"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"std::optional<T>"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"std::nullopt"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Struct types"}),(0,i.jsx)(n.td,{children:"Default-constructed"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"schema-consistent-mode-default",children:"Schema Consistent Mode (Default)"}),"\n",(0,i.jsx)(n.p,{children:"Without compatible mode, schemas must match exactly:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// Strict mode (default)\nauto fory = Fory::builder()\n    .compatible(false)  // Default: schema must match\n    .xlang(true)\n    .build();\n\n// Serialization/deserialization requires identical schemas\n// Schema mismatches may cause errors or undefined behavior\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Use SchemaConsistent mode when:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Schemas are guaranteed to match (same binary version)"}),"\n",(0,i.jsx)(n.li,{children:"Maximum performance is required (less metadata overhead)"}),"\n",(0,i.jsx)(n.li,{children:"You control both serialization and deserialization"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Use Compatible mode when:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Schemas may evolve independently"}),"\n",(0,i.jsx)(n.li,{children:"Cross-version compatibility is required"}),"\n",(0,i.jsx)(n.li,{children:"Different services may have different schema versions"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"type-id-requirements",children:"Type ID Requirements"}),"\n",(0,i.jsx)(n.p,{children:"For schema evolution to work:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Same Type ID"}),": Different versions of the same struct must use the same type ID"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Consistent IDs"}),": Type IDs must be consistent across all Fory instances"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Register All Versions"}),": Each Fory instance registers its own struct version"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"constexpr uint32_t PERSON_TYPE_ID = 100;\n\n// Instance 1 uses PersonV1\nfory_v1.register_struct<PersonV1>(PERSON_TYPE_ID);\n\n// Instance 2 uses PersonV2\nfory_v2.register_struct<PersonV2>(PERSON_TYPE_ID);\n\n// Same type ID enables schema evolution\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"1-plan-for-evolution",children:"1. Plan for Evolution"}),"\n",(0,i.jsx)(n.p,{children:"Design schemas with future changes in mind:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// Good: Use optional for fields that might be removed\nstruct Config {\n  std::string host;\n  int32_t port;\n  std::optional<std::string> deprecated_field;  // Can be removed later\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-use-meaningful-default-values",children:"2. Use Meaningful Default Values"}),"\n",(0,i.jsx)(n.p,{children:"Consider what default values make sense for new fields:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'struct Settings {\n  int32_t timeout_ms;      // Default: 0 (might want a sensible default)\n  bool enabled;            // Default: false\n  std::string mode;        // Default: "" (might want "default")\n};\n'})}),"\n",(0,i.jsx)(n.h3,{id:"3-document-schema-versions",children:"3. Document Schema Versions"}),"\n",(0,i.jsx)(n.p,{children:"Track schema changes for debugging:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// V1: Initial schema (2024-01-01)\n// V2: Added email field (2024-02-01)\n// V3: Added phone, address fields (2024-03-01)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"4-test-evolution-paths",children:"4. Test Evolution Paths"}),"\n",(0,i.jsx)(n.p,{children:"Test both upgrade and downgrade scenarios:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// Test V1 -> V2\n// Test V2 -> V1\n// Test V1 -> V3\n// Test V3 -> V1\n"})}),"\n",(0,i.jsx)(n.h2,{id:"cross-language-schema-evolution",children:"Cross-Language Schema Evolution"}),"\n",(0,i.jsx)(n.p,{children:"Schema evolution works across languages when using xlang mode:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// C++ with compatible mode\nauto fory = Fory::builder()\n    .compatible(true)\n    .xlang(true)\n    .build();\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"// Java with compatible mode\nFory fory = Fory.builder()\n    .withCompatibleMode(CompatibleMode.COMPATIBLE)\n    .withLanguage(Language.XLANG)\n    .build();\n"})}),"\n",(0,i.jsx)(n.p,{children:"Both instances can exchange data even with different schema versions."}),"\n",(0,i.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/0.14/guide/cpp/configuration",children:"Configuration"})," - Enabling compatible mode"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/0.14/guide/cpp/type_registration",children:"Type Registration"})," - Type ID management"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/0.14/guide/cpp/cross_language",children:"Cross-Language"})," - Cross-language considerations"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},11151:(e,n,s)=>{s.d(n,{Z:()=>d,a:()=>a});var i=s(67294);const t={},r=i.createContext(t);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);