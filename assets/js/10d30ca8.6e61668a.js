"use strict";(self.webpackChunkfory_site=self.webpackChunkfory_site||[]).push([[50954],{83141:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var t=i(85893),s=i(11151);const r={title:"Schema Evolution",sidebar_position:7,id:"schema_evolution",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},o=void 0,l={id:"guide/rust/schema_evolution",title:"Schema Evolution",description:"Apache Fory\u2122 supports schema evolution in Compatible mode, allowing serialization and deserialization peers to have different type definitions.",source:"@site/versioned_docs/version-0.14/guide/rust/schema-evolution.md",sourceDirName:"guide/rust",slug:"/guide/rust/schema_evolution",permalink:"/docs/0.14/guide/rust/schema_evolution",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/fory-site/tree/main/docs/guide/rust/schema-evolution.md",tags:[],version:"0.14",sidebarPosition:7,frontMatter:{title:"Schema Evolution",sidebar_position:7,id:"schema_evolution",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},sidebar:"docsSidebar",previous:{title:"Trait Object Serialization",permalink:"/docs/0.14/guide/rust/polymorphism"},next:{title:"Cross-Language Serialization",permalink:"/docs/0.14/guide/rust/cross_language"}},a={},d=[{value:"Compatible Mode",id:"compatible-mode",level:2},{value:"Schema Evolution Features",id:"schema-evolution-features",level:2},{value:"Compatibility Rules",id:"compatibility-rules",level:2},{value:"Enum Support",id:"enum-support",level:2},{value:"Enum Schema Evolution",id:"enum-schema-evolution",level:3},{value:"Tuple Support",id:"tuple-support",level:2},{value:"Related Topics",id:"related-topics",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["Apache Fory\u2122 supports schema evolution in ",(0,t.jsx)(n.strong,{children:"Compatible mode"}),", allowing serialization and deserialization peers to have different type definitions."]}),"\n",(0,t.jsx)(n.h2,{id:"compatible-mode",children:"Compatible Mode"}),"\n",(0,t.jsxs)(n.p,{children:["Enable schema evolution with ",(0,t.jsx)(n.code,{children:"compatible(true)"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use fory::Fory;\nuse fory::ForyObject;\nuse std::collections::HashMap;\n\n#[derive(ForyObject, Debug)]\nstruct PersonV1 {\n    name: String,\n    age: i32,\n    address: String,\n}\n\n#[derive(ForyObject, Debug)]\nstruct PersonV2 {\n    name: String,\n    age: i32,\n    // address removed\n    // phone added\n    phone: Option<String>,\n    metadata: HashMap<String, String>,\n}\n\nlet mut fory1 = Fory::default().compatible(true);\nfory1.register::<PersonV1>(1);\n\nlet mut fory2 = Fory::default().compatible(true);\nfory2.register::<PersonV2>(1);\n\nlet person_v1 = PersonV1 {\n    name: "Alice".to_string(),\n    age: 30,\n    address: "123 Main St".to_string(),\n};\n\n// Serialize with V1\nlet bytes = fory1.serialize(&person_v1);\n\n// Deserialize with V2 - missing fields get default values\nlet person_v2: PersonV2 = fory2.deserialize(&bytes)?;\nassert_eq!(person_v2.name, "Alice");\nassert_eq!(person_v2.age, 30);\nassert_eq!(person_v2.phone, None);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"schema-evolution-features",children:"Schema Evolution Features"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Add new fields with default values"}),"\n",(0,t.jsx)(n.li,{children:"Remove obsolete fields (skipped during deserialization)"}),"\n",(0,t.jsxs)(n.li,{children:["Change field nullability (",(0,t.jsx)(n.code,{children:"T"})," \u2194 ",(0,t.jsx)(n.code,{children:"Option<T>"}),")"]}),"\n",(0,t.jsx)(n.li,{children:"Reorder fields (matched by name, not position)"}),"\n",(0,t.jsx)(n.li,{children:"Type-safe fallback to default values for missing fields"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"compatibility-rules",children:"Compatibility Rules"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Field names must match (case-sensitive)"}),"\n",(0,t.jsx)(n.li,{children:"Type changes are not supported (except nullable/non-nullable)"}),"\n",(0,t.jsx)(n.li,{children:"Nested struct types must be registered on both sides"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"enum-support",children:"Enum Support"}),"\n",(0,t.jsx)(n.p,{children:"Apache Fory\u2122 supports three types of enum variants with full schema evolution in Compatible mode:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Variant Types:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Unit"}),": C-style enums (",(0,t.jsx)(n.code,{children:"Status::Active"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Unnamed"}),": Tuple-like variants (",(0,t.jsx)(n.code,{children:"Message::Pair(String, i32)"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Named"}),": Struct-like variants (",(0,t.jsx)(n.code,{children:"Event::Click { x: i32, y: i32 }"}),")"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use fory::{Fory, ForyObject};\n\n#[derive(Default, ForyObject, Debug, PartialEq)]\nenum Value {\n    #[default]\n    Null,\n    Bool(bool),\n    Number(f64),\n    Text(String),\n    Object { name: String, value: i32 },\n}\n\nlet mut fory = Fory::default();\nfory.register::<Value>(1)?;\n\nlet value = Value::Object { name: "score".to_string(), value: 100 };\nlet bytes = fory.serialize(&value)?;\nlet decoded: Value = fory.deserialize(&bytes)?;\nassert_eq!(value, decoded);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"enum-schema-evolution",children:"Enum Schema Evolution"}),"\n",(0,t.jsx)(n.p,{children:"Compatible mode enables robust schema evolution with variant type encoding (2 bits):"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"0b0"})," = Unit, ",(0,t.jsx)(n.code,{children:"0b1"})," = Unnamed, ",(0,t.jsx)(n.code,{children:"0b10"})," = Named"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"use fory::{Fory, ForyObject};\n\n// Old version\n#[derive(ForyObject)]\nenum OldEvent {\n    Click { x: i32, y: i32 },\n    Scroll { delta: f64 },\n}\n\n// New version - added field and variant\n#[derive(Default, ForyObject)]\nenum NewEvent {\n    #[default]\n    Unknown,\n    Click { x: i32, y: i32, timestamp: u64 },  // Added field\n    Scroll { delta: f64 },\n    KeyPress(String),  // New variant\n}\n\nlet mut fory = Fory::builder().compatible().build();\n\n// Serialize with old schema\nlet old_bytes = fory.serialize(&OldEvent::Click { x: 100, y: 200 })?;\n\n// Deserialize with new schema - timestamp gets default value (0)\nlet new_event: NewEvent = fory.deserialize(&old_bytes)?;\nassert!(matches!(new_event, NewEvent::Click { x: 100, y: 200, timestamp: 0 }));\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Evolution capabilities:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Unknown variants"})," \u2192 Falls back to default variant"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Named variant fields"})," \u2192 Add/remove fields (missing fields use defaults)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Unnamed variant elements"})," \u2192 Add/remove elements (extras skipped, missing use defaults)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Variant type mismatches"})," \u2192 Automatically uses default value for current variant"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Best practices:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Always mark a default variant with ",(0,t.jsx)(n.code,{children:"#[default]"})]}),"\n",(0,t.jsx)(n.li,{children:"Named variants provide better evolution than unnamed"}),"\n",(0,t.jsx)(n.li,{children:"Use compatible mode for cross-version communication"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"tuple-support",children:"Tuple Support"}),"\n",(0,t.jsx)(n.p,{children:"Apache Fory\u2122 supports tuples up to 22 elements out of the box with efficient serialization in both compatible and non-compatible modes."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Features:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Automatic serialization for tuples from 1 to 22 elements"}),"\n",(0,t.jsx)(n.li,{children:"Heterogeneous type support (each element can be a different type)"}),"\n",(0,t.jsx)(n.li,{children:"Schema evolution in Compatible mode (handles missing/extra elements)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Serialization modes:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Non-compatible mode"}),": Serializes elements sequentially without collection headers for minimal overhead"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Compatible mode"}),": Uses collection protocol with type metadata for schema evolution"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use fory::{Fory, Error};\n\nlet mut fory = Fory::default();\n\n// Tuple with heterogeneous types\nlet data: (i32, String, bool, Vec<i32>) = (\n    42,\n    "hello".to_string(),\n    true,\n    vec![1, 2, 3],\n);\n\nlet bytes = fory.serialize(&data)?;\nlet decoded: (i32, String, bool, Vec<i32>) = fory.deserialize(&bytes)?;\nassert_eq!(data, decoded);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/0.14/guide/rust/configuration",children:"Configuration"})," - Enabling compatible mode"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/0.14/guide/rust/polymorphism",children:"Polymorphism"})," - Trait objects with schema evolution"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/0.14/guide/rust/cross_language",children:"Cross-Language"})," - Schema evolution across languages"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>l,a:()=>o});var t=i(67294);const s={},r=t.createContext(s);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);