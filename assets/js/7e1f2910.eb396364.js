"use strict";(self.webpackChunkfory_site=self.webpackChunkfory_site||[]).push([[7205],{2227:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>t,default:()=>o,frontMatter:()=>d,metadata:()=>l,toc:()=>c});var s=i(85893),r=i(11151);const d={title:"Xlang Serialization Format",sidebar_position:0,id:"xlang_serialization_spec",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},t=void 0,l={id:"specification/xlang_serialization_spec",title:"Xlang Serialization Format",description:"Cross-language Serialization Specification",source:"@site/versioned_docs/version-0.15/specification/xlang_serialization_spec.md",sourceDirName:"specification",slug:"/specification/xlang_serialization_spec",permalink:"/docs/specification/xlang_serialization_spec",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/fory-site/tree/main/docs/specification/xlang_serialization_spec.md",tags:[],version:"0.15",sidebarPosition:0,frontMatter:{title:"Xlang Serialization Format",sidebar_position:0,id:"xlang_serialization_spec",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},sidebar:"specificationSidebar",next:{title:"Java Serialization Format",permalink:"/docs/specification/java_serialization_spec"}},a={},c=[{value:"Cross-language Serialization Specification",id:"cross-language-serialization-specification",level:2},{value:"Type Systems",id:"type-systems",level:2},{value:"Data Types",id:"data-types",level:3},{value:"Polymorphisms",id:"polymorphisms",level:3},{value:"Type disambiguation",id:"type-disambiguation",level:3},{value:"Type ID",id:"type-id",level:3},{value:"Internal Type ID Table",id:"internal-type-id-table",level:4},{value:"Type ID Encoding for User Types",id:"type-id-encoding-for-user-types",level:4},{value:"Type mapping",id:"type-mapping",level:3},{value:"Spec overview",id:"spec-overview",level:2},{value:"Fory header",id:"fory-header",level:2},{value:"Reference Meta",id:"reference-meta",level:2},{value:"Reference Flags",id:"reference-flags",level:3},{value:"Reference Tracking Algorithm",id:"reference-tracking-algorithm",level:3},{value:"Reference ID Assignment",id:"reference-id-assignment",level:3},{value:"When Reference Tracking is Disabled",id:"when-reference-tracking-is-disabled",level:3},{value:"Language-Specific Considerations",id:"language-specific-considerations",level:3},{value:"Type Meta",id:"type-meta",level:2},{value:"Type ID encoding",id:"type-id-encoding",level:3},{value:"Type meta payload",id:"type-meta-payload",level:3},{value:"Shared Type Meta (streaming)",id:"shared-type-meta-streaming",level:3},{value:"TypeDef (schema evolution metadata)",id:"typedef-schema-evolution-metadata",level:3},{value:"Global header",id:"global-header",level:4},{value:"TypeDef body",id:"typedef-body",level:4},{value:"Meta String",id:"meta-string",level:2},{value:"Encoding Type IDs",id:"encoding-type-ids",level:3},{value:"Character Mapping Tables",id:"character-mapping-tables",level:3},{value:"LOWER_SPECIAL (5 bits per character)",id:"lower_special-5-bits-per-character",level:4},{value:"LOWER_UPPER_DIGIT_SPECIAL (6 bits per character)",id:"lower_upper_digit_special-6-bits-per-character",level:4},{value:"Encoding Algorithms",id:"encoding-algorithms",level:3},{value:"LOWER_SPECIAL Encoding",id:"lower_special-encoding",level:4},{value:"FIRST_TO_LOWER_SPECIAL Encoding",id:"first_to_lower_special-encoding",level:4},{value:"ALL_TO_LOWER_SPECIAL Encoding",id:"all_to_lower_special-encoding",level:4},{value:"Encoding Selection Algorithm",id:"encoding-selection-algorithm",level:3},{value:"Meta String Header Format",id:"meta-string-header-format",level:3},{value:"Special Character Sets by Context",id:"special-character-sets-by-context",level:3},{value:"Deduplication",id:"deduplication",level:3},{value:"Value Format",id:"value-format",level:2},{value:"Basic types",id:"basic-types",level:3},{value:"bool",id:"bool",level:4},{value:"int8",id:"int8",level:4},{value:"int16",id:"int16",level:4},{value:"unsigned int32",id:"unsigned-int32",level:4},{value:"unsigned varint32",id:"unsigned-varint32",level:4},{value:"signed int32",id:"signed-int32",level:4},{value:"signed varint32",id:"signed-varint32",level:4},{value:"unsigned int64",id:"unsigned-int64",level:4},{value:"unsigned varint64",id:"unsigned-varint64",level:4},{value:"unsigned hybrid int64 (TAGGED_UINT64)",id:"unsigned-hybrid-int64-tagged_uint64",level:4},{value:"VarUint36Small",id:"varuint36small",level:4},{value:"signed int64",id:"signed-int64",level:4},{value:"signed varint64",id:"signed-varint64",level:4},{value:"signed hybrid int64 (TAGGED_INT64)",id:"signed-hybrid-int64-tagged_int64",level:4},{value:"float8",id:"float8",level:4},{value:"float16",id:"float16",level:4},{value:"bfloat16",id:"bfloat16",level:4},{value:"float32",id:"float32",level:4},{value:"float64",id:"float64",level:4},{value:"string",id:"string",level:3},{value:"String Header",id:"string-header",level:4},{value:"Encoding Algorithm",id:"encoding-algorithm",level:4},{value:"Encoding Selection by Language",id:"encoding-selection-by-language",level:4},{value:"Empty String",id:"empty-string",level:4},{value:"duration",id:"duration",level:3},{value:"collection/list",id:"collectionlist",level:3},{value:"Elements Header",id:"elements-header",level:4},{value:"Type Info After Header",id:"type-info-after-header",level:4},{value:"Element Serialization Based on Header",id:"element-serialization-based-on-header",level:4},{value:"elements data",id:"elements-data",level:4},{value:"array",id:"array",level:3},{value:"primitive array",id:"primitive-array",level:4},{value:"Multi-dimensional arrays",id:"multi-dimensional-arrays",level:4},{value:"object array",id:"object-array",level:4},{value:"map",id:"map",level:3},{value:"Map Chunk Format",id:"map-chunk-format",level:4},{value:"KV Header Bits",id:"kv-header-bits",level:4},{value:"Chunk Size",id:"chunk-size",level:4},{value:"Why Chunk-Based Format?",id:"why-chunk-based-format",level:4},{value:"Why serialize chunk by chunk?",id:"why-serialize-chunk-by-chunk",level:4},{value:"enum",id:"enum",level:3},{value:"timestamp",id:"timestamp",level:3},{value:"date",id:"date",level:3},{value:"decimal",id:"decimal",level:3},{value:"struct",id:"struct",level:3},{value:"Field order",id:"field-order",level:4},{value:"Step 1: Field identifier",id:"step-1-field-identifier",level:5},{value:"Step 2: Group assignment",id:"step-2-group-assignment",level:5},{value:"Step 3: Intra-group ordering",id:"step-3-intra-group-ordering",level:5},{value:"Notes",id:"notes",level:5},{value:"Schema consistent (meta share disabled)",id:"schema-consistent-meta-share-disabled",level:4},{value:"Compatible mode (meta share enabled)",id:"compatible-mode-meta-share-enabled",level:4},{value:"Union",id:"union",level:3},{value:"IDL syntax",id:"idl-syntax",level:4},{value:"Type IDs and type meta",id:"type-ids-and-type-meta",level:4},{value:"Union value payload",id:"union-value-payload",level:4},{value:"Wire layouts",id:"wire-layouts",level:4},{value:"Decoding rules",id:"decoding-rules",level:4},{value:"When to use each type ID",id:"when-to-use-each-type-id",level:4},{value:"Compatibility notes",id:"compatibility-notes",level:4},{value:"Type",id:"type",level:3},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"Language Implementation Guidelines",id:"language-implementation-guidelines",level:2}];function h(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"cross-language-serialization-specification",children:"Cross-language Serialization Specification"}),"\n",(0,s.jsx)(n.p,{children:"Apache Fory\u2122 xlang serialization enables automatic cross-language object serialization with support for shared references, circular references, and polymorphism. Unlike traditional serialization frameworks that require IDL definitions and schema compilation, Fory serializes objects directly without any intermediate steps."}),"\n",(0,s.jsx)(n.p,{children:"Key characteristics:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic"}),": No IDL definition, no schema compilation, no manual object-to-protocol conversion"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cross-language"}),": Same binary format works seamlessly across Java, Python, C++, Rust, Go, JavaScript, and more"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reference-aware"}),": Handles shared references and circular references without duplication or infinite recursion"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Polymorphic"}),": Supports object polymorphism with runtime type resolution"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This specification defines the Fory xlang binary format. The format is dynamic rather than static, which enables flexibility and ease of use at the cost of additional complexity in the wire format."}),"\n",(0,s.jsx)(n.h2,{id:"type-systems",children:"Type Systems"}),"\n",(0,s.jsx)(n.h3,{id:"data-types",children:"Data Types"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"bool: a boolean value (true or false)."}),"\n",(0,s.jsx)(n.li,{children:"int8: a 8-bit signed integer."}),"\n",(0,s.jsx)(n.li,{children:"int16: a 16-bit signed integer."}),"\n",(0,s.jsx)(n.li,{children:"int32: a 32-bit signed integer."}),"\n",(0,s.jsx)(n.li,{children:"varint32: a 32-bit signed integer which use fory variable-length encoding."}),"\n",(0,s.jsx)(n.li,{children:"int64: a 64-bit signed integer."}),"\n",(0,s.jsx)(n.li,{children:"varint64: a 64-bit signed integer which use fory PVL encoding."}),"\n",(0,s.jsx)(n.li,{children:"tagged_int64: a 64-bit signed integer which use fory Hybrid encoding."}),"\n",(0,s.jsx)(n.li,{children:"uint8: an 8-bit unsigned integer."}),"\n",(0,s.jsx)(n.li,{children:"uint16: a 16-bit unsigned integer."}),"\n",(0,s.jsx)(n.li,{children:"uint32: a 32-bit unsigned integer."}),"\n",(0,s.jsx)(n.li,{children:"var_uint32: a 32-bit unsigned integer which use fory variable-length encoding."}),"\n",(0,s.jsx)(n.li,{children:"uint64: a 64-bit unsigned integer."}),"\n",(0,s.jsx)(n.li,{children:"var_uint64: a 64-bit unsigned integer which use fory PVL encoding."}),"\n",(0,s.jsx)(n.li,{children:"tagged_uint64: a 64-bit unsigned integer which use fory Hybrid encoding."}),"\n",(0,s.jsx)(n.li,{children:"float8: an 8-bit floating point number."}),"\n",(0,s.jsx)(n.li,{children:"float16: a 16-bit floating point number."}),"\n",(0,s.jsx)(n.li,{children:"bfloat16: a 16-bit brain floating point number."}),"\n",(0,s.jsx)(n.li,{children:"float32: a 32-bit floating point number."}),"\n",(0,s.jsx)(n.li,{children:"float64: a 64-bit floating point number including NaN and Infinity."}),"\n",(0,s.jsx)(n.li,{children:"string: a text string encoded using Latin1/UTF16/UTF-8 encoding."}),"\n",(0,s.jsx)(n.li,{children:"enum: a data type consisting of a set of named values. Rust enum with non-predefined field values are not supported as\nan enum."}),"\n",(0,s.jsx)(n.li,{children:"named_enum: an enum whose value will be serialized as the registered name."}),"\n",(0,s.jsxs)(n.li,{children:["struct: a dynamic(final) type serialized by Fory Struct serializer. i.e. it doesn't have subclasses. Suppose we're\ndeserializing ",(0,s.jsx)(n.code,{children:"List<SomeClass>"}),", we can save dynamic serializer dispatch since ",(0,s.jsx)(n.code,{children:"SomeClass"})," is dynamic(final)."]}),"\n",(0,s.jsx)(n.li,{children:"compatible_struct: a dynamic(final) type serialized by Fory compatible Struct serializer."}),"\n",(0,s.jsxs)(n.li,{children:["named_struct: a ",(0,s.jsx)(n.code,{children:"struct"})," whose type mapping will be encoded as a name."]}),"\n",(0,s.jsxs)(n.li,{children:["named_compatible_struct: a ",(0,s.jsx)(n.code,{children:"compatible_struct"})," whose type mapping will be encoded as a name."]}),"\n",(0,s.jsx)(n.li,{children:"ext: a type which will be serialized by a customized serializer."}),"\n",(0,s.jsxs)(n.li,{children:["named_ext: an ",(0,s.jsx)(n.code,{children:"ext"})," type whose type mapping will be encoded as a name."]}),"\n",(0,s.jsx)(n.li,{children:"list: a sequence of objects."}),"\n",(0,s.jsx)(n.li,{children:"set: an unordered set of unique elements."}),"\n",(0,s.jsxs)(n.li,{children:["map: a map of key-value pairs. Mutable types such as ",(0,s.jsx)(n.code,{children:"list/map/set/array"})," are not allowed as key of map."]}),"\n",(0,s.jsx)(n.li,{children:"duration: an absolute length of time, independent of any calendar/timezone, as a count of nanoseconds."}),"\n",(0,s.jsx)(n.li,{children:"timestamp: a point in time, independent of any calendar/timezone, encoded as seconds (int64) and nanoseconds\n(uint32) since the epoch at UTC midnight on January 1, 1970."}),"\n",(0,s.jsx)(n.li,{children:"date: a naive date without timezone. The count is days relative to an epoch at UTC midnight on Jan 1, 1970."}),"\n",(0,s.jsx)(n.li,{children:"decimal: exact decimal value represented as an integer value in two's complement."}),"\n",(0,s.jsx)(n.li,{children:"binary: an variable-length array of bytes."}),"\n",(0,s.jsxs)(n.li,{children:["array: only allow 1d numeric components. Other arrays will be taken as List. The implementation should support the\ninteroperability between array and list.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"bool_array: one dimensional bool array."}),"\n",(0,s.jsx)(n.li,{children:"int8_array: one dimensional int8 array."}),"\n",(0,s.jsx)(n.li,{children:"int16_array: one dimensional int16 array."}),"\n",(0,s.jsx)(n.li,{children:"int32_array: one dimensional int32 array."}),"\n",(0,s.jsx)(n.li,{children:"int64_array: one dimensional int64 array."}),"\n",(0,s.jsx)(n.li,{children:"float8_array: one dimensional float8 array."}),"\n",(0,s.jsx)(n.li,{children:"float16_array: one dimensional half_float_16 array."}),"\n",(0,s.jsx)(n.li,{children:"bfloat16_array: one dimensional bfloat16 array."}),"\n",(0,s.jsx)(n.li,{children:"float32_array: one dimensional float32 array."}),"\n",(0,s.jsx)(n.li,{children:"float64_array: one dimensional float64 array."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"union: a tagged union type that can hold one of several alternative types. The active alternative is identified by an index."}),"\n",(0,s.jsx)(n.li,{children:"typed_union: a union value with registered numeric union type ID."}),"\n",(0,s.jsx)(n.li,{children:"named_union: a union value with embedded union type name or shared TypeDef."}),"\n",(0,s.jsx)(n.li,{children:"none: represents an empty/unit value with no data (e.g., for empty union alternatives)."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Note:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Unsigned integer types use the same byte sizes as their signed counterparts; the difference is in value interpretation. See ",(0,s.jsx)(n.a,{href:"/docs/specification/xlang_type_mapping",children:"Type mapping"})," for language-specific type mappings."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"polymorphisms",children:"Polymorphisms"}),"\n",(0,s.jsx)(n.p,{children:"For polymorphism, if one non-final class is registered, and only one subclass is registered, then we can take all\nelements in List/Map have same type, thus reduce runtime check cost."}),"\n",(0,s.jsx)(n.p,{children:"Collection/Array polymorphism are not fully supported, since some languages such as golang have only one collection\ntype. If users want to get exactly the type he passed, he must pass that type when deserializing or annotate that type\nto the field of struct."}),"\n",(0,s.jsx)(n.h3,{id:"type-disambiguation",children:"Type disambiguation"}),"\n",(0,s.jsx)(n.p,{children:"Due to differences between type systems of languages, those types can't be mapped one-to-one between languages. When\ndeserializing, Fory use the target data structure type and the data type in the data jointly to determine how to\ndeserialize and populate the target data structure. For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"class Foo {\n  int[] intArray;\n  Object[] objects;\n  List<Object> objectList;\n}\n\nclass Foo2 {\n  int[] intArray;\n  List<Object> objects;\n  List<Object> objectList;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"intArray"})," has an ",(0,s.jsx)(n.code,{children:"int32_array"})," type. But both ",(0,s.jsx)(n.code,{children:"objects"})," and ",(0,s.jsx)(n.code,{children:"objectList"})," fields in the serialize data have ",(0,s.jsx)(n.code,{children:"list"})," data\ntype. When deserializing, the implementation will create an ",(0,s.jsx)(n.code,{children:"Object"})," array for ",(0,s.jsx)(n.code,{children:"objects"}),", but create a ",(0,s.jsx)(n.code,{children:"ArrayList"}),"\nfor ",(0,s.jsx)(n.code,{children:"objectList"})," to populate its elements. And the serialized data of ",(0,s.jsx)(n.code,{children:"Foo"})," can be deserialized into ",(0,s.jsx)(n.code,{children:"Foo2"})," too."]}),"\n",(0,s.jsx)(n.p,{children:"Users can also provide meta hints for fields of a type, or the type whole. Here is an example in java which use\nannotation to provide such information."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"@ForyObject(fieldsNullable = false, trackingRef = false)\nclass Foo {\n  @ForyField(trackingRef = false)\n  int[] intArray;\n  @ForyField(polymorphic = true)\n  Object object;\n  @ForyField(tagId = 1, nullable = true)\n  List<Object> objectList;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Such information can be provided in other languages too:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"cpp: use macro and template."}),"\n",(0,s.jsx)(n.li,{children:"golang: use struct tag."}),"\n",(0,s.jsx)(n.li,{children:"python: use typehint."}),"\n",(0,s.jsx)(n.li,{children:"rust: use macro."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"type-id",children:"Type ID"}),"\n",(0,s.jsxs)(n.p,{children:["All internal data types use an 8-bit internal ID (",(0,s.jsx)(n.code,{children:"0~255"}),", with ",(0,s.jsx)(n.code,{children:"0~56"})," defined here). Users can\nregister types by numeric ID (",(0,s.jsx)(n.code,{children:"0~0xFFFFFFFE"})," in current implementations). User IDs are encoded\nseparately from the internal type ID; there is no bit shifting/packing."]}),"\n",(0,s.jsxs)(n.p,{children:["Named types (",(0,s.jsx)(n.code,{children:"NAMED_*"}),") do not embed a user ID; their names are carried in metadata instead."]}),"\n",(0,s.jsx)(n.h4,{id:"internal-type-id-table",children:"Internal Type ID Table"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Type ID"}),(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"UNKNOWN"}),(0,s.jsx)(n.td,{children:"Unknown type, used for dynamic typing"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"BOOL"}),(0,s.jsx)(n.td,{children:"Boolean value"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"INT8"}),(0,s.jsx)(n.td,{children:"8-bit signed integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"INT16"}),(0,s.jsx)(n.td,{children:"16-bit signed integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"4"}),(0,s.jsx)(n.td,{children:"INT32"}),(0,s.jsx)(n.td,{children:"32-bit signed integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"5"}),(0,s.jsx)(n.td,{children:"VARINT32"}),(0,s.jsx)(n.td,{children:"Variable-length encoded 32-bit signed integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"6"}),(0,s.jsx)(n.td,{children:"INT64"}),(0,s.jsx)(n.td,{children:"64-bit signed integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"7"}),(0,s.jsx)(n.td,{children:"VARINT64"}),(0,s.jsx)(n.td,{children:"Variable-length encoded 64-bit signed integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"8"}),(0,s.jsx)(n.td,{children:"TAGGED_INT64"}),(0,s.jsx)(n.td,{children:"Hybrid encoded 64-bit signed integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"9"}),(0,s.jsx)(n.td,{children:"UINT8"}),(0,s.jsx)(n.td,{children:"8-bit unsigned integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"10"}),(0,s.jsx)(n.td,{children:"UINT16"}),(0,s.jsx)(n.td,{children:"16-bit unsigned integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"11"}),(0,s.jsx)(n.td,{children:"UINT32"}),(0,s.jsx)(n.td,{children:"32-bit unsigned integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"12"}),(0,s.jsx)(n.td,{children:"VAR_UINT32"}),(0,s.jsx)(n.td,{children:"Variable-length encoded 32-bit unsigned integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"13"}),(0,s.jsx)(n.td,{children:"UINT64"}),(0,s.jsx)(n.td,{children:"64-bit unsigned integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"14"}),(0,s.jsx)(n.td,{children:"VAR_UINT64"}),(0,s.jsx)(n.td,{children:"Variable-length encoded 64-bit unsigned integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"15"}),(0,s.jsx)(n.td,{children:"TAGGED_UINT64"}),(0,s.jsx)(n.td,{children:"Hybrid encoded 64-bit unsigned integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"16"}),(0,s.jsx)(n.td,{children:"FLOAT8"}),(0,s.jsx)(n.td,{children:"8-bit floating point (float8)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"17"}),(0,s.jsx)(n.td,{children:"FLOAT16"}),(0,s.jsx)(n.td,{children:"16-bit floating point (half precision)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"18"}),(0,s.jsx)(n.td,{children:"BFLOAT16"}),(0,s.jsx)(n.td,{children:"16-bit brain floating point"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"19"}),(0,s.jsx)(n.td,{children:"FLOAT32"}),(0,s.jsx)(n.td,{children:"32-bit floating point (single precision)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"20"}),(0,s.jsx)(n.td,{children:"FLOAT64"}),(0,s.jsx)(n.td,{children:"64-bit floating point (double precision)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"21"}),(0,s.jsx)(n.td,{children:"STRING"}),(0,s.jsx)(n.td,{children:"UTF-8/UTF-16/Latin1 encoded string"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"22"}),(0,s.jsx)(n.td,{children:"LIST"}),(0,s.jsx)(n.td,{children:"Ordered collection (List, Array, Vector)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"23"}),(0,s.jsx)(n.td,{children:"SET"}),(0,s.jsx)(n.td,{children:"Unordered collection of unique elements"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"24"}),(0,s.jsx)(n.td,{children:"MAP"}),(0,s.jsx)(n.td,{children:"Key-value mapping"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"25"}),(0,s.jsx)(n.td,{children:"ENUM"}),(0,s.jsx)(n.td,{children:"Enum registered by numeric ID"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"26"}),(0,s.jsx)(n.td,{children:"NAMED_ENUM"}),(0,s.jsx)(n.td,{children:"Enum registered by namespace + type name"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"27"}),(0,s.jsx)(n.td,{children:"STRUCT"}),(0,s.jsx)(n.td,{children:"Struct registered by numeric ID (schema consistent)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"28"}),(0,s.jsx)(n.td,{children:"COMPATIBLE_STRUCT"}),(0,s.jsx)(n.td,{children:"Struct with schema evolution support (by ID)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"29"}),(0,s.jsx)(n.td,{children:"NAMED_STRUCT"}),(0,s.jsx)(n.td,{children:"Struct registered by namespace + type name"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"30"}),(0,s.jsx)(n.td,{children:"NAMED_COMPATIBLE_STRUCT"}),(0,s.jsx)(n.td,{children:"Struct with schema evolution (by name)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"31"}),(0,s.jsx)(n.td,{children:"EXT"}),(0,s.jsx)(n.td,{children:"Extension type registered by numeric ID"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"32"}),(0,s.jsx)(n.td,{children:"NAMED_EXT"}),(0,s.jsx)(n.td,{children:"Extension type registered by namespace + type name"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"33"}),(0,s.jsx)(n.td,{children:"UNION"}),(0,s.jsx)(n.td,{children:"Union value, schema identity not embedded"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"34"}),(0,s.jsx)(n.td,{children:"TYPED_UNION"}),(0,s.jsx)(n.td,{children:"Union value with registered numeric type ID"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"35"}),(0,s.jsx)(n.td,{children:"NAMED_UNION"}),(0,s.jsx)(n.td,{children:"Union value with embedded type name/TypeDef"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"36"}),(0,s.jsx)(n.td,{children:"NONE"}),(0,s.jsx)(n.td,{children:"Empty/unit type (no data)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"37"}),(0,s.jsx)(n.td,{children:"DURATION"}),(0,s.jsx)(n.td,{children:"Time duration (seconds + nanoseconds)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"38"}),(0,s.jsx)(n.td,{children:"TIMESTAMP"}),(0,s.jsx)(n.td,{children:"Point in time (seconds + nanoseconds since epoch)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"39"}),(0,s.jsx)(n.td,{children:"DATE"}),(0,s.jsx)(n.td,{children:"Date without timezone (days since epoch)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"40"}),(0,s.jsx)(n.td,{children:"DECIMAL"}),(0,s.jsx)(n.td,{children:"Arbitrary precision decimal"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"41"}),(0,s.jsx)(n.td,{children:"BINARY"}),(0,s.jsx)(n.td,{children:"Raw binary data"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"42"}),(0,s.jsx)(n.td,{children:"ARRAY"}),(0,s.jsx)(n.td,{children:"Generic array type"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"43"}),(0,s.jsx)(n.td,{children:"BOOL_ARRAY"}),(0,s.jsx)(n.td,{children:"1D boolean array"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"44"}),(0,s.jsx)(n.td,{children:"INT8_ARRAY"}),(0,s.jsx)(n.td,{children:"1D int8 array"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"45"}),(0,s.jsx)(n.td,{children:"INT16_ARRAY"}),(0,s.jsx)(n.td,{children:"1D int16 array"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"46"}),(0,s.jsx)(n.td,{children:"INT32_ARRAY"}),(0,s.jsx)(n.td,{children:"1D int32 array"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"47"}),(0,s.jsx)(n.td,{children:"INT64_ARRAY"}),(0,s.jsx)(n.td,{children:"1D int64 array"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"48"}),(0,s.jsx)(n.td,{children:"UINT8_ARRAY"}),(0,s.jsx)(n.td,{children:"1D uint8 array"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"49"}),(0,s.jsx)(n.td,{children:"UINT16_ARRAY"}),(0,s.jsx)(n.td,{children:"1D uint16 array"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"50"}),(0,s.jsx)(n.td,{children:"UINT32_ARRAY"}),(0,s.jsx)(n.td,{children:"1D uint32 array"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"51"}),(0,s.jsx)(n.td,{children:"UINT64_ARRAY"}),(0,s.jsx)(n.td,{children:"1D uint64 array"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"52"}),(0,s.jsx)(n.td,{children:"FLOAT8_ARRAY"}),(0,s.jsx)(n.td,{children:"1D float8 array"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"53"}),(0,s.jsx)(n.td,{children:"FLOAT16_ARRAY"}),(0,s.jsx)(n.td,{children:"1D float16 array"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"54"}),(0,s.jsx)(n.td,{children:"BFLOAT16_ARRAY"}),(0,s.jsx)(n.td,{children:"1D bfloat16 array"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"55"}),(0,s.jsx)(n.td,{children:"FLOAT32_ARRAY"}),(0,s.jsx)(n.td,{children:"1D float32 array"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"56"}),(0,s.jsx)(n.td,{children:"FLOAT64_ARRAY"}),(0,s.jsx)(n.td,{children:"1D float64 array"})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"type-id-encoding-for-user-types",children:"Type ID Encoding for User Types"}),"\n",(0,s.jsx)(n.p,{children:"When registering user types (struct/ext/enum/union), the internal type ID is written as the 8-bit\nkind. The user type ID is written separately as an unsigned varint32 (small7); there is no bit\nshift or packing."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"User ID"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Internal ID"}),(0,s.jsx)(n.th,{children:"Encoded User ID"}),(0,s.jsx)(n.th,{children:"Decimal"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"STRUCT"}),(0,s.jsx)(n.td,{children:"27"}),(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"0"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"ENUM"}),(0,s.jsx)(n.td,{children:"25"}),(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"0"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"STRUCT"}),(0,s.jsx)(n.td,{children:"27"}),(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"COMPATIBLE_STRUCT"}),(0,s.jsx)(n.td,{children:"28"}),(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"NAMED_STRUCT"}),(0,s.jsx)(n.td,{children:"29"}),(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"2"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"When reading type IDs:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Read internal type ID from the type ID field."}),"\n",(0,s.jsxs)(n.li,{children:["If the internal type is a user-registered kind, read ",(0,s.jsx)(n.code,{children:"user_type_id"})," as varuint32."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"type-mapping",children:"Type mapping"}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/docs/specification/xlang_type_mapping",children:"Type mapping"})]}),"\n",(0,s.jsx)(n.h2,{id:"spec-overview",children:"Spec overview"}),"\n",(0,s.jsx)(n.p,{children:"Here is the overall format:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| fory header | object ref meta | object type meta | object value data |\n"})}),"\n",(0,s.jsx)(n.p,{children:"The data are serialized using little endian byte order for all types."}),"\n",(0,s.jsx)(n.h2,{id:"fory-header",children:"Fory header"}),"\n",(0,s.jsx)(n.p,{children:"Fory header format for xlang serialization:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"|        1 byte bitmap           |\n+--------------------------------+\n|            flags               |\n"})}),"\n",(0,s.jsx)(n.p,{children:"Detailed byte layout:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Byte 0:   Bitmap flags\n          - Bit 0: null flag (0x01)\n          - Bit 1: xlang flag (0x02)\n          - Bit 2: oob flag (0x04)\n          - Bits 3-7: reserved\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"null flag"})," (bit 0): 1 when object is null, 0 otherwise. If an object is null, only this flag is set."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"xlang flag"})," (bit 1): 1 when serialization uses Fory xlang format, 0 when serialization uses Fory language-native format."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"oob flag"})," (bit 2): 1 when out-of-band serialization is enabled (BufferCallback is not null), 0 otherwise."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"All data is encoded in little-endian format."}),"\n",(0,s.jsx)(n.h2,{id:"reference-meta",children:"Reference Meta"}),"\n",(0,s.jsx)(n.p,{children:"Reference tracking handles whether the object is null, and whether to track reference for the object by writing\ncorresponding flags and maintaining internal state."}),"\n",(0,s.jsx)(n.h3,{id:"reference-flags",children:"Reference Flags"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Flag"}),(0,s.jsx)(n.th,{children:"Byte Value (int8)"}),(0,s.jsx)(n.th,{children:"Hex"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"NULL FLAG"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"-3"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"0xFD"})}),(0,s.jsx)(n.td,{children:"Object is null. No further bytes are written for this object."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"REF FLAG"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"-2"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"0xFE"})}),(0,s.jsx)(n.td,{children:"Object was already serialized. Followed by unsigned varint32 reference ID."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"NOT_NULL VALUE FLAG"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"-1"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"0xFF"})}),(0,s.jsx)(n.td,{children:"Object is non-null but reference tracking is disabled for this type. Object data follows immediately."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"REF VALUE FLAG"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"0"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"0x00"})}),(0,s.jsx)(n.td,{children:"Object is referencable and this is its first occurrence. Object data follows. Assigns next reference ID."})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"reference-tracking-algorithm",children:"Reference Tracking Algorithm"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Writing:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function write_ref_or_null(buffer, obj):\n    if obj is null:\n        buffer.write_int8(NULL_FLAG)      // -3\n        return true  // done, no more data to write\n\n    if reference_tracking_enabled:\n        ref_id = lookup_written_objects(obj)\n        if ref_id exists:\n            buffer.write_int8(REF_FLAG)   // -2\n            buffer.write_varuint32(ref_id)\n            return true  // done, reference written\n        else:\n            buffer.write_int8(REF_VALUE_FLAG)  // 0\n            add_to_written_objects(obj, next_ref_id++)\n            return false  // continue to serialize object data\n    else:\n        buffer.write_int8(NOT_NULL_VALUE_FLAG)  // -1\n        return false  // continue to serialize object data\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Reading:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function read_ref_or_null(buffer):\n    flag = buffer.read_int8()\n    switch flag:\n        case NULL_FLAG (-3):\n            return (null, true)  // null object, done\n        case REF_FLAG (-2):\n            ref_id = buffer.read_varuint32()\n            obj = get_from_read_objects(ref_id)\n            return (obj, true)  // referenced object, done\n        case NOT_NULL_VALUE_FLAG (-1):\n            return (null, false)  // non-null, continue reading\n        case REF_VALUE_FLAG (0):\n            reserve_ref_slot()  // will be filled after reading\n            return (null, false)  // non-null, continue reading\n"})}),"\n",(0,s.jsx)(n.h3,{id:"reference-id-assignment",children:"Reference ID Assignment"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Reference IDs are assigned sequentially starting from ",(0,s.jsx)(n.code,{children:"0"})]}),"\n",(0,s.jsxs)(n.li,{children:["The ID is assigned when ",(0,s.jsx)(n.code,{children:"REF_VALUE_FLAG"})," is written (first occurrence)"]}),"\n",(0,s.jsx)(n.li,{children:"Objects are stored in a list/map indexed by their reference ID"}),"\n",(0,s.jsx)(n.li,{children:"For reading, a placeholder slot is reserved before deserializing the object, then filled after"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"when-reference-tracking-is-disabled",children:"When Reference Tracking is Disabled"}),"\n",(0,s.jsxs)(n.p,{children:["When reference tracking is disabled globally or for specific types, only the ",(0,s.jsx)(n.code,{children:"NULL"})," and ",(0,s.jsx)(n.code,{children:"NOT_NULL VALUE"})," flags\nwill be used for reference meta. This reduces overhead for types that are known not to have references."]}),"\n",(0,s.jsx)(n.h3,{id:"language-specific-considerations",children:"Language-Specific Considerations"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Languages with nullable and reference types by default (Java, Python, JavaScript):"})}),"\n",(0,s.jsx)(n.p,{children:"In xlang mode, for cross-language compatibility:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["All fields are treated as ",(0,s.jsx)(n.strong,{children:"not-null"})," by default"]}),"\n",(0,s.jsxs)(n.li,{children:["Reference tracking is ",(0,s.jsx)(n.strong,{children:"disabled"})," by default"]}),"\n",(0,s.jsx)(n.li,{children:"Users can explicitly mark fields as nullable or enable reference tracking via annotations"}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Optional"})," types (e.g., ",(0,s.jsx)(n.code,{children:"java.util.Optional"}),", ",(0,s.jsx)(n.code,{children:"typing.Optional"}),") are treated as nullable"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Annotation examples:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// Java: use @ForyField annotation\npublic class MyClass {\n    @ForyField(nullable = true, ref = true)\n    private Object refField;\n\n    @ForyField(nullable = false)\n    private String requiredField;\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# Python: use typing with fory field descriptors\nfrom pyfory import Fory, ForyField\n\nclass MyClass:\n    ref_field: ForyField(SomeType, nullable=True, ref=True)\n    required_field: ForyField(str, nullable=False)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Languages with non-nullable types by default:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Language"}),(0,s.jsx)(n.th,{children:"Null Representation"}),(0,s.jsx)(n.th,{children:"Reference Tracking Support"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Rust"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Option::None"})}),(0,s.jsxs)(n.td,{children:["Via ",(0,s.jsx)(n.code,{children:"Rc<T>"}),", ",(0,s.jsx)(n.code,{children:"Arc<T>"}),", ",(0,s.jsx)(n.code,{children:"Weak<T>"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"C++"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"std::nullopt"}),", ",(0,s.jsx)(n.code,{children:"nullptr"})]}),(0,s.jsxs)(n.td,{children:["Via ",(0,s.jsx)(n.code,{children:"std::shared_ptr<T>"}),", ",(0,s.jsx)(n.code,{children:"weak_ptr<T>"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Go"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"nil"})," interface/pointer"]}),(0,s.jsx)(n.td,{children:"Via pointer/interface types"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Important:"})," For languages like Rust that don't have implicit reference semantics, reference tracking must use\nexplicit smart pointers (",(0,s.jsx)(n.code,{children:"Rc"}),", ",(0,s.jsx)(n.code,{children:"Arc"}),")."]}),"\n",(0,s.jsx)(n.h2,{id:"type-meta",children:"Type Meta"}),"\n",(0,s.jsx)(n.p,{children:"Every non-primitive value begins with a type ID that identifies its concrete type. The type ID is\nfollowed by optional type-specific metadata."}),"\n",(0,s.jsx)(n.h3,{id:"type-id-encoding",children:"Type ID encoding"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The type ID is written as an unsigned varint32 (small7)."}),"\n",(0,s.jsx)(n.li,{children:"Internal types use their internal type ID directly (low 8 bits)."}),"\n",(0,s.jsxs)(n.li,{children:["User-registered types write the internal type ID, then write ",(0,s.jsx)(n.code,{children:"user_type_id"})," as varuint32.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"user_type_id"})," is a numeric ID (0~0xFFFFFFFE in current implementations)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"internal_type_id"})," is one of ",(0,s.jsx)(n.code,{children:"ENUM"}),", ",(0,s.jsx)(n.code,{children:"STRUCT"}),", ",(0,s.jsx)(n.code,{children:"COMPATIBLE_STRUCT"}),", ",(0,s.jsx)(n.code,{children:"EXT"}),", or ",(0,s.jsx)(n.code,{children:"TYPED_UNION"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Named types do not embed a user ID. They use ",(0,s.jsx)(n.code,{children:"NAMED_*"})," internal type IDs and carry a namespace\nand type name (or shared TypeDef) instead."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"type-meta-payload",children:"Type meta payload"}),"\n",(0,s.jsx)(n.p,{children:"After the type ID:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ENUM / STRUCT / EXT / TYPED_UNION"}),": no extra bytes beyond the ",(0,s.jsx)(n.code,{children:"user_type_id"})," (registration by ID required on both sides)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"COMPATIBLE_STRUCT"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If meta share is enabled, write a shared TypeDef entry (see below)."}),"\n",(0,s.jsx)(n.li,{children:"If meta share is disabled, no extra bytes."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"NAMED_ENUM / NAMED_STRUCT / NAMED_COMPATIBLE_STRUCT / NAMED_EXT / NAMED_UNION"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If meta share is disabled, write ",(0,s.jsx)(n.code,{children:"namespace"})," and ",(0,s.jsx)(n.code,{children:"type_name"})," as meta strings."]}),"\n",(0,s.jsx)(n.li,{children:"If meta share is enabled, write a shared TypeDef entry (see below)."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"UNION"}),": no extra bytes at this layer."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"LIST / SET / MAP / ARRAY / primitives"}),": no extra bytes at this layer."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Unregistered types are serialized as named types:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Enums -> ",(0,s.jsx)(n.code,{children:"NAMED_ENUM"})]}),"\n",(0,s.jsxs)(n.li,{children:["Struct-like classes -> ",(0,s.jsx)(n.code,{children:"NAMED_STRUCT"})," (or ",(0,s.jsx)(n.code,{children:"NAMED_COMPATIBLE_STRUCT"})," when meta share is enabled)"]}),"\n",(0,s.jsxs)(n.li,{children:["Custom extension types -> ",(0,s.jsx)(n.code,{children:"NAMED_EXT"})]}),"\n",(0,s.jsxs)(n.li,{children:["Unions -> ",(0,s.jsx)(n.code,{children:"NAMED_UNION"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The namespace is the package/module name and the type name is the simple class name."}),"\n",(0,s.jsx)(n.h3,{id:"shared-type-meta-streaming",children:"Shared Type Meta (streaming)"}),"\n",(0,s.jsx)(n.p,{children:"When meta share is enabled, TypeDef metadata is written inline the first time a type is\nencountered, and subsequent occurrences only reference it."}),"\n",(0,s.jsx)(n.p,{children:"Encoding:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"marker = (index << 1) | flag"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"flag = 0"}),": new type definition follows"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"flag = 1"}),": reference to a previously written type definition"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"index"})," is the sequential index assigned to this type (starting from 0)."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Write algorithm:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Look up the class in the per-stream meta context map."}),"\n",(0,s.jsxs)(n.li,{children:["If found, write ",(0,s.jsx)(n.code,{children:"(index << 1) | 1"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["If not found:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["assign ",(0,s.jsx)(n.code,{children:"index = next_id"})]}),"\n",(0,s.jsxs)(n.li,{children:["write ",(0,s.jsx)(n.code,{children:"(index << 1)"})]}),"\n",(0,s.jsx)(n.li,{children:"write the encoded TypeDef bytes immediately after"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Read algorithm:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Read ",(0,s.jsx)(n.code,{children:"marker"})," as varuint32."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"flag = marker & 1"}),", ",(0,s.jsx)(n.code,{children:"index = marker >>> 1"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"flag == 1"}),", use the cached TypeDef at ",(0,s.jsx)(n.code,{children:"index"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"flag == 0"}),", read a TypeDef, cache it at ",(0,s.jsx)(n.code,{children:"index"}),", and use it."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"TypeDef bytes include the 8-byte global header and optional size extension."}),"\n",(0,s.jsx)(n.h3,{id:"typedef-schema-evolution-metadata",children:"TypeDef (schema evolution metadata)"}),"\n",(0,s.jsx)(n.p,{children:"TypeDef describes a struct-like type (or a named enum/ext) for schema evolution and name\nresolution. It is encoded as:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"|    8-byte global header   | [optional size varuint] | TypeDef body |\n"})}),"\n",(0,s.jsx)(n.h4,{id:"global-header",children:"Global header"}),"\n",(0,s.jsx)(n.p,{children:"The 8-byte header is a little-endian uint64:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Low 8 bits: meta size (number of bytes in the TypeDef body).","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If meta size >= 0xFF, the low 8 bits are set to 0xFF and an extra\n",(0,s.jsx)(n.code,{children:"varuint32(meta_size - 0xFF)"})," follows immediately after the header."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Bit 8: ",(0,s.jsx)(n.code,{children:"HAS_FIELDS_META"})," (1 = fields metadata present)."]}),"\n",(0,s.jsxs)(n.li,{children:["Bit 9: ",(0,s.jsx)(n.code,{children:"COMPRESS_META"})," (1 = body is compressed; decompress before parsing)."]}),"\n",(0,s.jsx)(n.li,{children:"Bits 10-13: reserved for future extension (must be zero)."}),"\n",(0,s.jsx)(n.li,{children:"High 50 bits: hash of the TypeDef body."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"typedef-body",children:"TypeDef body"}),"\n",(0,s.jsx)(n.p,{children:"TypeDef body has a single layer (fields are flattened in class hierarchy order):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| meta header (1 byte) | type spec | field info ... |\n"})}),"\n",(0,s.jsx)(n.p,{children:"Meta header byte:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Bits 0-4: ",(0,s.jsx)(n.code,{children:"num_fields"})," (0-30).","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"num_fields == 31"}),", read an extra ",(0,s.jsx)(n.code,{children:"varuint32"})," and add it."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Bit 5: ",(0,s.jsx)(n.code,{children:"REGISTER_BY_NAME"})," (1 = namespace + type name, 0 = numeric type ID)."]}),"\n",(0,s.jsx)(n.li,{children:"Bits 6-7: reserved."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Type spec:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"REGISTER_BY_NAME"})," is set:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"namespace"})," meta string"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"type_name"})," meta string"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Otherwise:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"type_id"})," as ",(0,s.jsx)(n.code,{children:"varuint32"})," (small7)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Field info list:"}),"\n",(0,s.jsx)(n.p,{children:"Each field is encoded as:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| field header (1 byte) | field type info | [field name bytes] |\n"})}),"\n",(0,s.jsx)(n.p,{children:"Field header layout:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Bits 6-7: field name encoding (",(0,s.jsx)(n.code,{children:"UTF8"}),", ",(0,s.jsx)(n.code,{children:"ALL_TO_LOWER_SPECIAL"}),",\n",(0,s.jsx)(n.code,{children:"LOWER_UPPER_DIGIT_SPECIAL"}),", or ",(0,s.jsx)(n.code,{children:"TAG_ID"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["Bits 2-5: size","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["For name encoding: ",(0,s.jsx)(n.code,{children:"size = (name_bytes_length - 1)"})]}),"\n",(0,s.jsxs)(n.li,{children:["For tag ID: ",(0,s.jsx)(n.code,{children:"size = tag_id"})]}),"\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"size == 0b1111"}),", read ",(0,s.jsx)(n.code,{children:"varuint32(size - 15)"})," and add it"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Bit 1: nullable flag"}),"\n",(0,s.jsx)(n.li,{children:"Bit 0: reference tracking flag"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Field type info:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The top-level field type is written as ",(0,s.jsx)(n.code,{children:"varuint32(type_id)"})," (small7) without flags."]}),"\n",(0,s.jsxs)(n.li,{children:["For ",(0,s.jsx)(n.code,{children:"LIST"})," / ",(0,s.jsx)(n.code,{children:"SET"}),", an element type follows, encoded as\n",(0,s.jsx)(n.code,{children:"(nested_type_id << 2) | (nullable << 1) | tracking_ref"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["For ",(0,s.jsx)(n.code,{children:"MAP"}),", key type and value type follow, both encoded the same way."]}),"\n",(0,s.jsxs)(n.li,{children:["One-dimensional primitive arrays use ",(0,s.jsx)(n.code,{children:"*_ARRAY"})," type IDs; other arrays are encoded as ",(0,s.jsx)(n.code,{children:"LIST"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Field names:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"TAG_ID"})," encoding is used, no name bytes are written."]}),"\n",(0,s.jsx)(n.li,{children:"Otherwise, write the encoded field name bytes as a meta string."}),"\n",(0,s.jsxs)(n.li,{children:["For xlang, field names are converted to ",(0,s.jsx)(n.code,{children:"snake_case"})," before encoding for\ncross-language compatibility."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Field order:"}),"\n",(0,s.jsx)(n.p,{children:"Field order is implementation-defined. Decoders must match fields by name or tag ID rather than\nposition. Fory uses a stable grouping and sorting order to produce deterministic TypeDefs."}),"\n",(0,s.jsx)(n.h2,{id:"meta-string",children:"Meta String"}),"\n",(0,s.jsx)(n.p,{children:"Meta string is a compressed encoding for metadata strings such as field names, type names, and namespaces.\nThis compression significantly reduces the size of type metadata in serialized data."}),"\n",(0,s.jsx)(n.h3,{id:"encoding-type-ids",children:"Encoding Type IDs"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"ID"}),(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Bits/Char"}),(0,s.jsx)(n.th,{children:"Character Set"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"UTF8"}),(0,s.jsx)(n.td,{children:"8"}),(0,s.jsx)(n.td,{children:"Any UTF-8 character"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"LOWER_SPECIAL"}),(0,s.jsx)(n.td,{children:"5"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"a-z . _ $ |"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"LOWER_UPPER_DIGIT_SPECIAL"}),(0,s.jsx)(n.td,{children:"6"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"a-z A-Z 0-9 . _"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"FIRST_TO_LOWER_SPECIAL"}),(0,s.jsx)(n.td,{children:"5"}),(0,s.jsxs)(n.td,{children:["First char uppercase, rest ",(0,s.jsx)(n.code,{children:"a-z . _"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"4"}),(0,s.jsx)(n.td,{children:"ALL_TO_LOWER_SPECIAL"}),(0,s.jsx)(n.td,{children:"5"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"a-z A-Z . _"})," (uppercase escaped)"]})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"character-mapping-tables",children:"Character Mapping Tables"}),"\n",(0,s.jsx)(n.h4,{id:"lower_special-5-bits-per-character",children:"LOWER_SPECIAL (5 bits per character)"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Character"}),(0,s.jsx)(n.th,{children:"Code (binary)"}),(0,s.jsx)(n.th,{children:"Code (decimal)"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"a-z"}),(0,s.jsx)(n.td,{children:"00000-11001"}),(0,s.jsx)(n.td,{children:"0-25"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"."}),(0,s.jsx)(n.td,{children:"11010"}),(0,s.jsx)(n.td,{children:"26"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"_"}),(0,s.jsx)(n.td,{children:"11011"}),(0,s.jsx)(n.td,{children:"27"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"$"}),(0,s.jsx)(n.td,{children:"11100"}),(0,s.jsx)(n.td,{children:"28"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"|"}),(0,s.jsx)(n.td,{children:"11101"}),(0,s.jsx)(n.td,{children:"29"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," The ",(0,s.jsx)(n.code,{children:"|"})," character is used as an escape sequence in ALL_TO_LOWER_SPECIAL encoding."]}),"\n",(0,s.jsx)(n.h4,{id:"lower_upper_digit_special-6-bits-per-character",children:"LOWER_UPPER_DIGIT_SPECIAL (6 bits per character)"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Character"}),(0,s.jsx)(n.th,{children:"Code (binary)"}),(0,s.jsx)(n.th,{children:"Code (decimal)"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"a-z"}),(0,s.jsx)(n.td,{children:"000000-011001"}),(0,s.jsx)(n.td,{children:"0-25"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"A-Z"}),(0,s.jsx)(n.td,{children:"011010-110011"}),(0,s.jsx)(n.td,{children:"26-51"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0-9"}),(0,s.jsx)(n.td,{children:"110100-111101"}),(0,s.jsx)(n.td,{children:"52-61"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"."}),(0,s.jsx)(n.td,{children:"111110"}),(0,s.jsx)(n.td,{children:"62"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"_"}),(0,s.jsx)(n.td,{children:"111111"}),(0,s.jsx)(n.td,{children:"63"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"encoding-algorithms",children:"Encoding Algorithms"}),"\n",(0,s.jsx)(n.h4,{id:"lower_special-encoding",children:"LOWER_SPECIAL Encoding"}),"\n",(0,s.jsxs)(n.p,{children:["For strings containing only ",(0,s.jsx)(n.code,{children:"a-z"}),", ",(0,s.jsx)(n.code,{children:"."}),", ",(0,s.jsx)(n.code,{children:"_"}),", ",(0,s.jsx)(n.code,{children:"$"}),", ",(0,s.jsx)(n.code,{children:"|"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function encode_lower_special(str):\n    bits = []\n    for char in str:\n        bits.append(lookup_lower_special[char])  // 5 bits each\n\n    // Pad to byte boundary\n    total_bits = len(str) * 5\n    padding_bits = (8 - (total_bits % 8)) % 8\n\n    // First bit indicates if last char should be stripped (due to padding)\n    strip_last = (padding_bits >= 5)\n    if strip_last:\n        prepend bit 1\n    else:\n        prepend bit 0\n\n    return pack_bits_to_bytes(bits)\n"})}),"\n",(0,s.jsx)(n.h4,{id:"first_to_lower_special-encoding",children:"FIRST_TO_LOWER_SPECIAL Encoding"}),"\n",(0,s.jsxs)(n.p,{children:["For strings like ",(0,s.jsx)(n.code,{children:"MyFieldName"})," where only the first character is uppercase:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function encode_first_to_lower_special(str):\n    // Convert first char to lowercase\n    modified = str[0].lower() + str[1:]\n    // Then use LOWER_SPECIAL encoding\n    return encode_lower_special(modified)\n"})}),"\n",(0,s.jsx)(n.h4,{id:"all_to_lower_special-encoding",children:"ALL_TO_LOWER_SPECIAL Encoding"}),"\n",(0,s.jsxs)(n.p,{children:["For strings with multiple uppercase characters like ",(0,s.jsx)(n.code,{children:"MyTypeName"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'function encode_all_to_lower_special(str):\n    result = ""\n    for char in str:\n        if char.is_upper():\n            result += "|" + char.lower()  // Escape uppercase with |\n        else:\n            result += char\n    return encode_lower_special(result)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Example: ",(0,s.jsx)(n.code,{children:"MyType"})," \u2192 ",(0,s.jsx)(n.code,{children:"|my|type"})," \u2192 encoded with LOWER_SPECIAL"]}),"\n",(0,s.jsx)(n.h3,{id:"encoding-selection-algorithm",children:"Encoding Selection Algorithm"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function choose_encoding(str):\n    if all chars in str are in [a-z . _ $ |]:\n        return LOWER_SPECIAL\n\n    if first char is uppercase AND rest are in [a-z . _]:\n        return FIRST_TO_LOWER_SPECIAL\n\n    if all chars are in [a-z A-Z . _]:\n        lower_special_size = encode_all_to_lower_special(str).size\n        luds_size = encode_lower_upper_digit_special(str).size\n        if lower_special_size <= luds_size:\n            return ALL_TO_LOWER_SPECIAL\n        else:\n            return LOWER_UPPER_DIGIT_SPECIAL\n\n    if all chars are in [a-z A-Z 0-9 . _]:\n        return LOWER_UPPER_DIGIT_SPECIAL\n\n    return UTF8\n"})}),"\n",(0,s.jsx)(n.h3,{id:"meta-string-header-format",children:"Meta String Header Format"}),"\n",(0,s.jsx)(n.p,{children:"Meta strings are written with a header that includes the encoding type:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| 3 bits encoding | 5+ bits length | encoded bytes |\n"})}),"\n",(0,s.jsx)(n.p,{children:"Or for larger strings:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| varuint: (length << 3) | encoding | encoded bytes |\n"})}),"\n",(0,s.jsx)(n.h3,{id:"special-character-sets-by-context",children:"Special Character Sets by Context"}),"\n",(0,s.jsx)(n.p,{children:"Different contexts use different special characters:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Context"}),(0,s.jsx)(n.th,{children:"Special Chars"}),(0,s.jsx)(n.th,{children:"Notes"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Field Name"}),(0,s.jsx)(n.td,{children:". _ $ |"}),(0,s.jsx)(n.td,{children:"$ for inner classes, | for escape"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Namespace"}),(0,s.jsx)(n.td,{children:". _"}),(0,s.jsx)(n.td,{children:"Package/module separators"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Type Name"}),(0,s.jsx)(n.td,{children:"$ _"}),(0,s.jsx)(n.td,{children:"$ for inner classes in Java"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"deduplication",children:"Deduplication"}),"\n",(0,s.jsx)(n.p,{children:"Meta strings are deduplicated within a serialization session:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"First occurrence:  | (length << 1) | [hash if large] | encoding | bytes |\nReference:         | ((id + 1) << 1) | 1 |\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Bit 0 of the header indicates: 0 = new string, 1 = reference to previous"}),"\n",(0,s.jsx)(n.li,{children:"Large strings (> 16 bytes) include 64-bit hash for content-based deduplication"}),"\n",(0,s.jsx)(n.li,{children:"Small strings use exact byte comparison"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"value-format",children:"Value Format"}),"\n",(0,s.jsx)(n.h3,{id:"basic-types",children:"Basic types"}),"\n",(0,s.jsx)(n.h4,{id:"bool",children:"bool"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 1 byte"}),"\n",(0,s.jsxs)(n.li,{children:["format: 0 for ",(0,s.jsx)(n.code,{children:"false"}),", 1 for ",(0,s.jsx)(n.code,{children:"true"})]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"int8",children:"int8"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 1 byte"}),"\n",(0,s.jsx)(n.li,{children:"format: write as pure byte."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"int16",children:"int16"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 2 byte"}),"\n",(0,s.jsx)(n.li,{children:"byte order: raw bytes of little endian order"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"unsigned-int32",children:"unsigned int32"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 4 byte"}),"\n",(0,s.jsx)(n.li,{children:"byte order: raw bytes of little endian order"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"unsigned-varint32",children:"unsigned varint32"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 1~5 bytes"}),"\n",(0,s.jsxs)(n.li,{children:["Format: The most significant bit (MSB) in every byte indicates whether to have the next byte. If the continuation\nbit is set (i.e. ",(0,s.jsx)(n.code,{children:"b & 0x80 == 0x80"}),"), then the next byte should be read until a byte with unset continuation bit."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Encoding Algorithm:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function write_varuint32(value):\n    while value >= 0x80:\n        buffer.write_byte((value & 0x7F) | 0x80)  // 7 bits of data + continuation bit\n        value = value >> 7\n    buffer.write_byte(value)  // final byte without continuation bit\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Decoding Algorithm:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function read_varuint32():\n    result = 0\n    shift = 0\n    while true:\n        byte = buffer.read_byte()\n        result = result | ((byte & 0x7F) << shift)\n        if (byte & 0x80) == 0:\n            break\n        shift = shift + 7\n    return result\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Byte sizes by value range:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Value Range"}),(0,s.jsx)(n.th,{children:"Bytes"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0 ~ 127"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"128 ~ 16383"}),(0,s.jsx)(n.td,{children:"2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"16384 ~ 2097151"}),(0,s.jsx)(n.td,{children:"3"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2097152 ~ 268435455"}),(0,s.jsx)(n.td,{children:"4"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"268435456 ~ 4294967295"}),(0,s.jsx)(n.td,{children:"5"})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"signed-int32",children:"signed int32"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 4 bytes"}),"\n",(0,s.jsx)(n.li,{children:"byte order: raw bytes of little endian order"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"signed-varint32",children:"signed varint32"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 1~5 bytes"}),"\n",(0,s.jsx)(n.li,{children:"Format: First convert the number into positive unsigned int using ZigZag encoding, then encode as unsigned varint."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"ZigZag Encoding:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"// Encode: convert signed to unsigned\nzigzag_value = (value << 1) ^ (value >> 31)\n\n// Decode: convert unsigned back to signed\noriginal = (zigzag_value >> 1) ^ (-(zigzag_value & 1))\n// Or equivalently:\noriginal = (zigzag_value >> 1) ^ (~(zigzag_value & 1) + 1)\n"})}),"\n",(0,s.jsx)(n.p,{children:"ZigZag encoding maps signed integers to unsigned integers so that small absolute values (positive or negative)\nhave small encoded values:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Original"}),(0,s.jsx)(n.th,{children:"ZigZag Encoded"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"0"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"-1"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"-2"}),(0,s.jsx)(n.td,{children:"3"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"4"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"..."}),(0,s.jsx)(n.td,{children:"..."})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"unsigned-int64",children:"unsigned int64"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 8 bytes"}),"\n",(0,s.jsx)(n.li,{children:"byte order: raw bytes of little endian order"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"unsigned-varint64",children:"unsigned varint64"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 1~9 bytes"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Uses PVL (Progressive Variable-Length) encoding:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function write_varuint64(value):\n    while value >= 0x80:\n        buffer.write_byte((value & 0x7F) | 0x80)\n        value = value >> 7\n    buffer.write_byte(value)\n"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Value Range"}),(0,s.jsx)(n.th,{children:"Bytes"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0 ~ 127"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"128 ~ 16383"}),(0,s.jsx)(n.td,{children:"2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"..."}),(0,s.jsx)(n.td,{children:"..."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2^56 ~ 2^63-1"}),(0,s.jsx)(n.td,{children:"9"})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"unsigned-hybrid-int64-tagged_uint64",children:"unsigned hybrid int64 (TAGGED_UINT64)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 4 or 9 bytes"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Optimized for unsigned values that fit in 31 bits (common case for IDs, sizes, counts, etc.):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"if value in [0, 2147483647]:  // fits in 31 bits (2^31 - 1), full unsigned range\n    write 4 bytes: ((int32) value) << 1  // bit 0 is 0, indicating 4-byte encoding\nelse:\n    write 1 byte:  0x01                  // bit 0 is 1, indicating 9-byte encoding\n    write 8 bytes: value as little-endian uint64\n"})}),"\n",(0,s.jsx)(n.p,{children:"Reading:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"first_int32 = read_int32_le()\nif (first_int32 & 1) == 0:\n    return (uint64)(first_int32 >> 1)  // 4-byte encoding, unsigned\nelse:\n    return read_uint64_le()            // read remaining 8 bytes\n"})}),"\n",(0,s.jsx)(n.p,{children:"Note: TAGGED_UINT64 uses the full 31 bits for positive values [0, 2^31-1], compared to TAGGED_INT64 which splits the range for signed values [-2^30, 2^30-1]."}),"\n",(0,s.jsx)(n.h4,{id:"varuint36small",children:"VarUint36Small"}),"\n",(0,s.jsx)(n.p,{children:"A specialized encoding used for string headers that combines size (up to 36 bits) with encoding flags:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"// Write: encodes (size << 2) | encoding_flags\nfunction write_varuint36_small(value):\n    if value < 0x80:\n        buffer.write_byte(value)\n    else:\n        // Standard varint encoding for values >= 128\n        write_varuint64(value)\n"})}),"\n",(0,s.jsx)(n.p,{children:"This encoding is optimized for the common case where string length fits in 7 bits (strings < 32 characters)."}),"\n",(0,s.jsx)(n.h4,{id:"signed-int64",children:"signed int64"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 8 bytes"}),"\n",(0,s.jsx)(n.li,{children:"byte order: raw bytes of little endian order"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"signed-varint64",children:"signed varint64"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 1~9 bytes"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Uses ZigZag encoding first, then PVL varint:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"// Encode\nzigzag_value = (value << 1) ^ (value >> 63)\nwrite_varuint64(zigzag_value)\n\n// Decode\nzigzag_value = read_varuint64()\nvalue = (zigzag_value >> 1) ^ (-(zigzag_value & 1))\n"})}),"\n",(0,s.jsx)(n.h4,{id:"signed-hybrid-int64-tagged_int64",children:"signed hybrid int64 (TAGGED_INT64)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 4 or 9 bytes"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Optimized for small signed values:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"if value in [-1073741824, 1073741823]:  // fits in 30 bits + sign ([-2^30, 2^30-1])\n    write 4 bytes: ((int32) value) << 1  // bit 0 is 0, indicating 4-byte encoding\nelse:\n    write 1 byte:  0x01                  // bit 0 is 1, indicating 9-byte encoding\n    write 8 bytes: value as little-endian int64\n"})}),"\n",(0,s.jsx)(n.p,{children:"Reading:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"first_int32 = read_int32_le()\nif (first_int32 & 1) == 0:\n    return (int64)(first_int32 >> 1)  // 4-byte encoding, sign-extended\nelse:\n    return read_int64_le()            // read remaining 8 bytes\n"})}),"\n",(0,s.jsx)(n.p,{children:"Note: TAGGED_INT64 uses 30 bits + sign for values [-2^30, 2^30-1], while TAGGED_UINT64 uses full 31 bits for unsigned values [0, 2^31-1]."}),"\n",(0,s.jsx)(n.h4,{id:"float8",children:"float8"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 1 byte"}),"\n",(0,s.jsxs)(n.li,{children:["format:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"float8 has 4 kinds: float8 kind enum: float8_e4m3fn, float8_e4m3fnuz, float8_e5m2, float8_e5m2fnuz"}),"\n",(0,s.jsx)(n.li,{children:"when serialize as field, write raw 8 bits as one byte directly"}),"\n",(0,s.jsx)(n.li,{children:"when serialize as an object: write type kind as a byte, then write value byte"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"float16",children:"float16"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 2 bytes"}),"\n",(0,s.jsx)(n.li,{children:"format: encode the specified floating-point value according to the IEEE 754 standard binary16 format, preserving NaN values, then write as binary by little endian order."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"bfloat16",children:"bfloat16"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 2 bytes"}),"\n",(0,s.jsx)(n.li,{children:"format: encode the specified floating-point value according to the IEEE 754 standard bfloat16 format, preserving NaN values, then write as binary by little endian order."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"float32",children:"float32"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 4 byte"}),"\n",(0,s.jsx)(n.li,{children:'format: encode the specified floating-point value according to the IEEE 754 floating-point "single format" bit layout,\npreserving Not-a-Number (NaN) values, then write as binary by little endian order.'}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"float64",children:"float64"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 8 byte"}),"\n",(0,s.jsx)(n.li,{children:'format: encode the specified floating-point value according to the IEEE 754 floating-point "double format" bit layout,\npreserving Not-a-Number (NaN) values. then write as binary by little endian order.'}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"string",children:"string"}),"\n",(0,s.jsx)(n.p,{children:"Format:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| varuint36_small: (size << 2) | encoding | binary data |\n"})}),"\n",(0,s.jsx)(n.h4,{id:"string-header",children:"String Header"}),"\n",(0,s.jsxs)(n.p,{children:["The header is encoded using ",(0,s.jsx)(n.code,{children:"varuint36_small"})," format, which combines the byte length and encoding type:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"header = (byte_length << 2) | encoding_type\n"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Encoding Type"}),(0,s.jsx)(n.th,{children:"Value"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"LATIN1"}),(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"ISO-8859-1 single-byte encoding"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"UTF16"}),(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"UTF-16 encoding (2 bytes per code unit)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"UTF8"}),(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"UTF-8 variable-length encoding"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Reserved"}),(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"Reserved for future use"})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"encoding-algorithm",children:"Encoding Algorithm"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Writing:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function write_string(str):\n    bytes = encode_to_bytes(str, chosen_encoding)\n    header = (bytes.length << 2) | encoding_type\n    buffer.write_varuint36_small(header)\n    buffer.write_bytes(bytes)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Reading:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function read_string():\n    header = buffer.read_varuint36_small()\n    encoding = header & 0x03\n    byte_length = header >> 2\n    bytes = buffer.read_bytes(byte_length)\n    return decode_bytes(bytes, encoding)\n"})}),"\n",(0,s.jsx)(n.h4,{id:"encoding-selection-by-language",children:"Encoding Selection by Language"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Writing:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Language"}),(0,s.jsx)(n.th,{children:"Encoding Strategy"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Java (JDK8)"}),(0,s.jsx)(n.td,{children:"Detect at runtime: LATIN1 if all chars < 256, else UTF16"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Java (JDK9+)"}),(0,s.jsx)(n.td,{children:"Use String's internal coder: LATIN1 or UTF16"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Python"}),(0,s.jsx)(n.td,{children:"Can write LATIN1, UTF16, or UTF8 based on string content"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"C++"}),(0,s.jsxs)(n.td,{children:["UTF8 (",(0,s.jsx)(n.code,{children:"std::string"}),") or UTF16 (",(0,s.jsx)(n.code,{children:"std::u16string"}),")"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Rust"}),(0,s.jsxs)(n.td,{children:["UTF8 (",(0,s.jsx)(n.code,{children:"String"}),")"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Go"}),(0,s.jsxs)(n.td,{children:["UTF8 (",(0,s.jsx)(n.code,{children:"string"}),")"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"JavaScript"}),(0,s.jsx)(n.td,{children:"UTF8"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Reading:"})," All languages support decoding all three encodings (LATIN1, UTF16, UTF8)."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Recommendation:"})," Select encoding based on maximum performance - use the encoding that matches the language's native string representation to avoid conversion overhead."]}),"\n",(0,s.jsx)(n.h4,{id:"empty-string",children:"Empty String"}),"\n",(0,s.jsxs)(n.p,{children:["Empty strings are encoded with header ",(0,s.jsx)(n.code,{children:"0"})," (length 0, any encoding) followed by no data bytes."]}),"\n",(0,s.jsx)(n.h3,{id:"duration",children:"duration"}),"\n",(0,s.jsx)(n.p,{children:"Duration is an absolute length of time, independent of any calendar/timezone, as a count of seconds and nanoseconds."}),"\n",(0,s.jsx)(n.p,{children:"Format:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| signed varint64: seconds | signed int32: nanoseconds |\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"seconds"}),": Number of seconds in the duration, encoded as a signed varint64. Can be positive or negative."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"nanoseconds"}),": Nanosecond adjustment to the duration, encoded as a signed int32. Value range is [0, 999,999,999] for positive durations, and [-999,999,999, 0] for negative durations."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Notes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The duration is stored as two separate fields to maintain precision and avoid overflow issues."}),"\n",(0,s.jsx)(n.li,{children:"Seconds are encoded using varint64 for compact representation of common duration values."}),"\n",(0,s.jsx)(n.li,{children:"Nanoseconds are stored as a fixed int32 since the range is limited."}),"\n",(0,s.jsx)(n.li,{children:"The sign of the duration is determined by the seconds field. When seconds is 0, the sign is determined by nanoseconds."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"collectionlist",children:"collection/list"}),"\n",(0,s.jsx)(n.p,{children:"Format:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| varuint32: length | 1 byte elements header | [optional type info] | elements data |\n"})}),"\n",(0,s.jsx)(n.h4,{id:"elements-header",children:"Elements Header"}),"\n",(0,s.jsx)(n.p,{children:"The elements header is a single byte that encodes metadata about the collection elements to optimize serialization:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| bit 7-4 (reserved) |    bit 3    |      bit 2       |   bit 1  |   bit 0   |\n+--------------------+-------------+------------------+----------+-----------+\n|      reserved      | is_same_type| is_decl_elem_type| has_null | track_ref |\n"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Bit"}),(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Value"}),(0,s.jsx)(n.th,{children:"Meaning when SET (1)"}),(0,s.jsx)(n.th,{children:"Meaning when UNSET (0)"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"track_ref"}),(0,s.jsx)(n.td,{children:"0x01"}),(0,s.jsx)(n.td,{children:"Track references for elements"}),(0,s.jsx)(n.td,{children:"Don't track element references"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"has_null"}),(0,s.jsx)(n.td,{children:"0x02"}),(0,s.jsx)(n.td,{children:"Collection may contain null elements"}),(0,s.jsx)(n.td,{children:"No null elements (skip null checks)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"is_decl_elem_type"}),(0,s.jsx)(n.td,{children:"0x04"}),(0,s.jsx)(n.td,{children:"Elements are the declared generic type"}),(0,s.jsx)(n.td,{children:"Element types differ from declared type"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"is_same_type"}),(0,s.jsx)(n.td,{children:"0x08"}),(0,s.jsx)(n.td,{children:"All elements have the same runtime type"}),(0,s.jsx)(n.td,{children:"Elements have different runtime types"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Common header values:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Header"}),(0,s.jsx)(n.th,{children:"Hex"}),(0,s.jsx)(n.th,{children:"Meaning"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0x0C"}),(0,s.jsx)(n.td,{children:"12"}),(0,s.jsx)(n.td,{children:"Declared type + same type, non-null, no ref tracking (optimal)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0x0D"}),(0,s.jsx)(n.td,{children:"13"}),(0,s.jsx)(n.td,{children:"Declared type + same type, non-null, with ref tracking"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0x0E"}),(0,s.jsx)(n.td,{children:"14"}),(0,s.jsx)(n.td,{children:"Declared type + same type, may have nulls, no ref tracking"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0x08"}),(0,s.jsx)(n.td,{children:"8"}),(0,s.jsx)(n.td,{children:"Same type but not declared type (type info written once)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0x00"}),(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"Different types, non-null, no ref tracking (type per element)"})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"type-info-after-header",children:"Type Info After Header"}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"is_decl_elem_type"})," (bit 2) is NOT set, the element type info is written once after the header if ",(0,s.jsx)(n.code,{children:"is_same_type"})," (bit 3) is set:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| header (0x08) | type_id (varuint32) | elements... |\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When both ",(0,s.jsx)(n.code,{children:"is_decl_elem_type"})," and ",(0,s.jsx)(n.code,{children:"is_same_type"})," are NOT set, type info is written per element."]}),"\n",(0,s.jsx)(n.h4,{id:"element-serialization-based-on-header",children:"Element Serialization Based on Header"}),"\n",(0,s.jsx)(n.p,{children:"The header determines how each element is serialized:"}),"\n",(0,s.jsx)(n.h4,{id:"elements-data",children:"elements data"}),"\n",(0,s.jsxs)(n.p,{children:["Based on the elements header, the serialization of elements data may skip ",(0,s.jsx)(n.code,{children:"ref flag"}),"/",(0,s.jsx)(n.code,{children:"null flag"}),"/",(0,s.jsx)(n.code,{children:"element type info"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"fory = ...\nbuffer = ...\nelems = ...\nif element_type_is_same:\n    if not is_declared_type:\n        fory.write_type(buffer, elem_type)\n    elem_serializer = get_serializer(...)\n    if track_ref:\n        for elem in elems:\n            if not ref_resolver.write_ref_or_null(buffer, elem):\n                elem_serializer.write(buffer, elem)\n    elif has_null:\n        for elem in elems:\n            if elem is None:\n                buffer.write_byte(null_flag)\n            else:\n                buffer.write_byte(not_null_flag)\n                elem_serializer.write(buffer, elem)\n    else:\n        for elem in elems:\n            elem_serializer.write(buffer, elem)\nelse:\n    if track_ref:\n        for elem in elems:\n            fory.write_ref(buffer, elem)\n    elif has_null:\n        for elem in elems:\n            fory.write_nullable(buffer, elem)\n    else:\n        for elem in elems:\n            fory.write_value(buffer, elem)\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/apache/fory/blob/20a1a78b17a75a123a6f5b7094c06ff77defc0fe/java/fory-core/src/main/java/org/apache/fory/serializer/collection/CollectionLikeSerializer.java#L302",children:(0,s.jsx)(n.code,{children:"CollectionSerializer#writeElements"})}),"\ncan be taken as an example."]}),"\n",(0,s.jsx)(n.h3,{id:"array",children:"array"}),"\n",(0,s.jsx)(n.h4,{id:"primitive-array",children:"primitive array"}),"\n",(0,s.jsx)(n.p,{children:"Primitive array are taken as a binary buffer, serialization will just write the length of array size as an unsigned int,\nthen copy the whole buffer into the stream."}),"\n",(0,s.jsx)(n.p,{children:"Such serialization won't compress the array. If users want to compress primitive array, users need to register custom\nserializers for such types or mark it as list type."}),"\n",(0,s.jsx)(n.p,{children:"Float array specifics:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["float16/bfloat16 array: write ",(0,s.jsx)(n.code,{children:"varuint"})," length, then raw bytes in little endian order."]}),"\n",(0,s.jsxs)(n.li,{children:["float8 array: write element type kind as a byte, then ",(0,s.jsx)(n.code,{children:"varuint"})," length, then raw bytes in little endian order."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"multi-dimensional-arrays",children:"Multi-dimensional arrays"}),"\n",(0,s.jsxs)(n.p,{children:["Xlang does not define a dedicated tensor encoding. Multi-dimensional arrays are serialized as\nnested lists, while one-dimensional primitive arrays use the ",(0,s.jsx)(n.code,{children:"*_ARRAY"})," type IDs."]}),"\n",(0,s.jsx)(n.h4,{id:"object-array",children:"object array"}),"\n",(0,s.jsx)(n.p,{children:"Object array is serialized using the list format. Object component type will be taken as list element\ngeneric type."}),"\n",(0,s.jsx)(n.h3,{id:"map",children:"map"}),"\n",(0,s.jsx)(n.p,{children:"Map uses a chunk-based format to handle heterogeneous key-value pairs efficiently:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| varuint32: total_size | chunk_1 | chunk_2 | ... | chunk_n |\n"})}),"\n",(0,s.jsx)(n.h4,{id:"map-chunk-format",children:"Map Chunk Format"}),"\n",(0,s.jsx)(n.p,{children:"Each chunk contains up to 255 key-value pairs with the same metadata characteristics:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"|    1 byte    |     1 byte     |        variable bytes        |\n+--------------+----------------+------------------------------+\n|  KV header   |  chunk size N  |  N key-value pairs (N*2 obj) |\n"})}),"\n",(0,s.jsx)(n.h4,{id:"kv-header-bits",children:"KV Header Bits"}),"\n",(0,s.jsx)(n.p,{children:"The KV header is a single byte encoding metadata for both keys and values:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"|  bit 7-6   |     bit 5     |     bit 4    |     bit 3     |     bit 2     |     bit 1    |     bit 0     |\n+------------+---------------+--------------+---------------+---------------+--------------+---------------+\n|  reserved  | val_decl_type | val_has_null | val_track_ref | key_decl_type | key_has_null | key_track_ref |\n"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Bit"}),(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Value"}),(0,s.jsx)(n.th,{children:"Meaning when SET (1)"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"key_track_ref"}),(0,s.jsx)(n.td,{children:"0x01"}),(0,s.jsx)(n.td,{children:"Track references for keys"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"key_has_null"}),(0,s.jsx)(n.td,{children:"0x02"}),(0,s.jsx)(n.td,{children:"Keys may be null (rare, usually invalid)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"key_decl_type"}),(0,s.jsx)(n.td,{children:"0x04"}),(0,s.jsx)(n.td,{children:"Key is the declared generic type"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"val_track_ref"}),(0,s.jsx)(n.td,{children:"0x08"}),(0,s.jsx)(n.td,{children:"Track references for values"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"4"}),(0,s.jsx)(n.td,{children:"val_has_null"}),(0,s.jsx)(n.td,{children:"0x10"}),(0,s.jsx)(n.td,{children:"Values may be null"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"5"}),(0,s.jsx)(n.td,{children:"val_decl_type"}),(0,s.jsx)(n.td,{children:"0x20"}),(0,s.jsx)(n.td,{children:"Value is the declared generic type"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Common KV header values:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Header"}),(0,s.jsx)(n.th,{children:"Hex"}),(0,s.jsx)(n.th,{children:"Meaning"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0x24"}),(0,s.jsx)(n.td,{children:"36"}),(0,s.jsx)(n.td,{children:"Key + value are declared types, non-null, no ref tracking (optimal)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0x2C"}),(0,s.jsx)(n.td,{children:"44"}),(0,s.jsx)(n.td,{children:"Key + value declared types, value tracks refs"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0x34"}),(0,s.jsx)(n.td,{children:"52"}),(0,s.jsx)(n.td,{children:"Key + value declared types, value may be null"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0x00"}),(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"Key + value not declared types, non-null, no ref tracking"})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"chunk-size",children:"Chunk Size"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Maximum chunk size: 255 pairs (fits in 1 byte)"}),"\n",(0,s.jsx)(n.li,{children:"When key or value is null, that entry is serialized as a separate chunk with implicit size 1 (chunk size byte is skipped)"}),"\n",(0,s.jsx)(n.li,{children:"Reader tracks accumulated count against total map size to know when to stop reading chunks"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"why-chunk-based-format",children:"Why Chunk-Based Format?"}),"\n",(0,s.jsx)(n.p,{children:"Map iteration is expensive. Computing a single header for all pairs would require two passes. The chunk-based\napproach allows:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Optimistic prediction"}),": Use first key-value pair to predict header"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Adaptive chunking"}),": Start new chunk if prediction fails for a pair"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Efficient reading"}),": Most maps fit in single chunk (< 255 pairs)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory efficiency"}),": Minimal overhead for common homogeneous maps"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"why-serialize-chunk-by-chunk",children:"Why serialize chunk by chunk?"}),"\n",(0,s.jsxs)(n.p,{children:["When fory will use first key-value pair to predict header optimistically, it can't know how many pairs have same\nmeta(tracking kef ref, key has null and so on). If we don't write chunk by chunk with max chunk size, we must write at\nleast ",(0,s.jsx)(n.code,{children:"X"})," bytes to take up a place for later to update the number which has same elements, ",(0,s.jsx)(n.code,{children:"X"})," is the num_bytes for\nencoding varint encoding of map size."]}),"\n",(0,s.jsx)(n.p,{children:"And most map size are smaller than 255, if all pairs have same data, the chunk will be 1. This is common in golang/rust,\nwhich object are not reference by default."}),"\n",(0,s.jsx)(n.p,{children:"Also, if only one or two keys have different meta, we can make it into a different chunk, so that most pairs can share\nmeta."}),"\n",(0,s.jsx)(n.p,{children:"The implementation can accumulate read count with map size to decide whether to read more chunks."}),"\n",(0,s.jsx)(n.h3,{id:"enum",children:"enum"}),"\n",(0,s.jsx)(n.p,{children:"Enums are serialized as an unsigned var int. If the order of enum values change, the deserialized enum value may not be\nthe value users expect. In such cases, users must register enum serializer by make it write enum value as an enumerated\nstring with unique hash disabled."}),"\n",(0,s.jsx)(n.h3,{id:"timestamp",children:"timestamp"}),"\n",(0,s.jsx)(n.p,{children:"Timestamp represents a point in time independent of any calendar/timezone. It is encoded as:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"seconds"})," (int64): seconds since Unix epoch (1970-01-01T00:00:00Z)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"nanos"})," (uint32): nanosecond adjustment within the second"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["On write, implementations must normalize negative timestamps so that ",(0,s.jsx)(n.code,{children:"nanos"})," is always in ",(0,s.jsx)(n.code,{children:"[0, 1_000_000_000)"}),".\nThis is a fixed-size 12-byte payload (8 bytes seconds + 4 bytes nanos)."]}),"\n",(0,s.jsx)(n.h3,{id:"date",children:"date"}),"\n",(0,s.jsxs)(n.p,{children:["Date represents a date without timezone. It is encoded as an ",(0,s.jsx)(n.code,{children:"int32"})," count of days since the Unix epoch\n(1970-01-01). This is a fixed-size 4-byte payload."]}),"\n",(0,s.jsx)(n.h3,{id:"decimal",children:"decimal"}),"\n",(0,s.jsx)(n.p,{children:"Not supported for now."}),"\n",(0,s.jsx)(n.h3,{id:"struct",children:"struct"}),"\n",(0,s.jsxs)(n.p,{children:["Struct means object of ",(0,s.jsx)(n.code,{children:"class/pojo/struct/bean/record"})," type. Struct values are serialized by writing\nfields in Fory order. The type meta before the value is written according to the rules in\n",(0,s.jsx)(n.a,{href:"#type-meta",children:"Type Meta"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"field-order",children:"Field order"}),"\n",(0,s.jsx)(n.p,{children:"Field order must be deterministic and identical across languages. This section defines the\nlanguage-neutral ordering algorithm; implementations must follow the rules here rather than any\nlanguage-specific helper classes."}),"\n",(0,s.jsx)(n.h5,{id:"step-1-field-identifier",children:"Step 1: Field identifier"}),"\n",(0,s.jsx)(n.p,{children:"For every field, compute a stable identifier used for ordering:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If a tag ID is configured (e.g., ",(0,s.jsx)(n.code,{children:"@ForyField(id=...)"}),"), use the tag ID as a decimal string."]}),"\n",(0,s.jsxs)(n.li,{children:["Otherwise, use the field name converted to ",(0,s.jsx)(n.code,{children:"snake_case"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Tag IDs must be unique within a type; duplicate tag IDs are invalid."}),"\n",(0,s.jsx)(n.h5,{id:"step-2-group-assignment",children:"Step 2: Group assignment"}),"\n",(0,s.jsx)(n.p,{children:"Assign each field to exactly one group in the following order:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Primitive (non-nullable)"}),": primitive or boxed numeric/boolean types with ",(0,s.jsx)(n.code,{children:"nullable=false"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Primitive (nullable)"}),": primitive or boxed numeric/boolean types with ",(0,s.jsx)(n.code,{children:"nullable=true"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Built-in (non-container)"}),": internal type IDs that are not user-defined and not UNKNOWN,\nexcluding collections and maps (for example: STRING, TIME types, UNION/TYPED_UNION/NAMED_UNION,\nprimitive arrays)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Collection"}),": list/set/object-array fields. Non-primitive arrays are treated as LIST for\nordering purposes."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Map"}),": map fields."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Other"}),": user-defined enum/struct/ext and UNKNOWN types."]}),"\n"]}),"\n",(0,s.jsx)(n.h5,{id:"step-3-intra-group-ordering",children:"Step 3: Intra-group ordering"}),"\n",(0,s.jsx)(n.p,{children:"Within each group, apply the following sort keys in order until a difference is found:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Primitive groups (1 and 2):"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Compression category"}),": fixed-size numeric and boolean types first, then compressed numeric\ntypes (",(0,s.jsx)(n.code,{children:"VARINT32"}),", ",(0,s.jsx)(n.code,{children:"VAR_UINT32"}),", ",(0,s.jsx)(n.code,{children:"VARINT64"}),", ",(0,s.jsx)(n.code,{children:"VAR_UINT64"}),", ",(0,s.jsx)(n.code,{children:"TAGGED_INT64"}),", ",(0,s.jsx)(n.code,{children:"TAGGED_UINT64"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Primitive size"})," (descending): 8-byte > 4-byte > 2-byte > 1-byte."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Internal type ID"})," (descending) as a tie-breaker for equal sizes."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Field identifier"})," (lexicographic ascending)."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Built-in / Collection / Map groups (3-5):"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Internal type ID"})," (ascending)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Field identifier"})," (lexicographic ascending)."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Other group (6):"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Field identifier"})," (lexicographic ascending)."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If two fields still compare equal after the rules above, preserve a deterministic order by\ncomparing declaring class name and then the original field name. This tie-breaker should be\nreachable only in invalid schemas (e.g., duplicate tag IDs)."}),"\n",(0,s.jsx)(n.h5,{id:"notes",children:"Notes"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The ordering above is used for serialization order and TypeDef field lists. Schema hashes use\nthe field identifier ordering described in the schema hash section."}),"\n",(0,s.jsxs)(n.li,{children:["Collection/map normalization is required so peers with different concrete types (e.g.,\n",(0,s.jsx)(n.code,{children:"List"})," vs ",(0,s.jsx)(n.code,{children:"Collection"}),") still agree on ordering."]}),"\n",(0,s.jsx)(n.li,{children:"The compressed numeric rule is critical for cross-language consistency: compressed integer\nfields are always placed after all fixed-width integer fields."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"schema-consistent-meta-share-disabled",children:"Schema consistent (meta share disabled)"}),"\n",(0,s.jsx)(n.p,{children:"Object value layout:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| [optional 4-byte schema hash] | field values |\n"})}),"\n",(0,s.jsx)(n.p,{children:"The schema hash is written only when class-version checking is enabled. It is the low 32 bits of a\nMurmurHash3 x64_128 of the struct fingerprint string:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["For each field, build ",(0,s.jsx)(n.code,{children:"<field_id_or_name>,<type_id>,<ref>,<nullable>;"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Field identifier is the tag ID if present, otherwise the snake_case field name."}),"\n",(0,s.jsx)(n.li,{children:"Sort by field identifier lexicographically before concatenation."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Field values are serialized in Fory order. Primitive fields are written as raw values (nullable\nprimitives include a null flag). Non-primitive fields write ref/null flags as needed and then the\nvalue; polymorphic fields include type meta."}),"\n",(0,s.jsx)(n.h4,{id:"compatible-mode-meta-share-enabled",children:"Compatible mode (meta share enabled)"}),"\n",(0,s.jsxs)(n.p,{children:["The field value layout is the same as schema-consistent mode, but the type meta for\n",(0,s.jsx)(n.code,{children:"COMPATIBLE_STRUCT"})," and ",(0,s.jsx)(n.code,{children:"NAMED_COMPATIBLE_STRUCT"})," uses shared TypeDef entries. Deserializers use\nTypeDef to map fields by name or tag ID and to honor nullable/ref flags from metadata; unknown fields\nare skipped."]}),"\n",(0,s.jsx)(n.h3,{id:"union",children:"Union"}),"\n",(0,s.jsxs)(n.p,{children:["Union values are encoded using three union type IDs so the union schema identity lives in type meta (like\n",(0,s.jsx)(n.code,{children:"STRUCT/ENUM/EXT"}),") and is easy to carry inside ",(0,s.jsx)(n.code,{children:"Any"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"idl-syntax",children:"IDL syntax"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-fdl",children:"union Contact [id=0] {\n  string email = 1;\n  int32  phone = 2;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Rules:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Each union alternative MUST have a stable tag number (",(0,s.jsx)(n.code,{children:"= 1"}),", ",(0,s.jsx)(n.code,{children:"= 2"}),", ...)."]}),"\n",(0,s.jsx)(n.li,{children:"Tag numbers MUST be unique within the union and MUST NOT be reused."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"type-ids-and-type-meta",children:"Type IDs and type meta"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{style:{textAlign:"right"},children:"Type ID"}),(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Meaning"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"right"},children:"33"}),(0,s.jsx)(n.td,{children:"UNION"}),(0,s.jsx)(n.td,{children:"Union value, schema identity not embedded"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"right"},children:"34"}),(0,s.jsx)(n.td,{children:"TYPED_UNION"}),(0,s.jsx)(n.td,{children:"Union value with registered numeric type ID"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"right"},children:"35"}),(0,s.jsx)(n.td,{children:"NAMED_UNION"}),(0,s.jsx)(n.td,{children:"Union value with embedded type name / shared TypeDef"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Type meta encoding:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UNION (33)"}),": no additional type meta payload."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TYPED_UNION (34)"}),": write ",(0,s.jsx)(n.code,{children:"user_type_id"})," as varuint32 after the type ID."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"NAMED_UNION (35)"}),": followed by named type meta (namespace + type name, or shared TypeDef marker/body)."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"union-value-payload",children:"Union value payload"}),"\n",(0,s.jsx)(n.p,{children:"A union payload is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| case_id (varuint32) | case_value (Any-style value) |\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"case_id"})," is the union alternative tag number."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"case_value"})," MUST be encoded as a full xlang value:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| field_ref_meta | field_value_type_meta | field_value_bytes |\n"})}),"\n",(0,s.jsx)(n.p,{children:"This is required even for primitives so unknown alternatives can be skipped safely."}),"\n",(0,s.jsx)(n.h4,{id:"wire-layouts",children:"Wire layouts"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"UNION (schema known from context)"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| ... outer ref meta ... | type_id=UNION(33) | case_id | case_value |\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"TYPED_UNION (schema identified by numeric id)"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| ... outer ref meta ... | type_id=TYPED_UNION(34) | user_type_id | case_id | case_value |\n"})}),"\n",(0,s.jsx)(n.p,{children:"user_type_id: varuint32 numeric registration ID for the union schema."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"NAMED_UNION (schema embedded by name/typedef)"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| ... outer ref meta ... | type_id=NAMED_UNION(35) | name_or_typedef | case_id | case_value |\n"})}),"\n",(0,s.jsx)(n.h4,{id:"decoding-rules",children:"Decoding rules"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Read outer ref meta and ",(0,s.jsx)(n.code,{children:"type_id"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"TYPED_UNION"}),", read ",(0,s.jsx)(n.code,{children:"user_type_id"})," and resolve the union schema by ID."]}),"\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"NAMED_UNION"}),", read named type meta and resolve the union schema."]}),"\n",(0,s.jsxs)(n.li,{children:["Read ",(0,s.jsx)(n.code,{children:"case_id"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Read ",(0,s.jsx)(n.code,{children:"case_value"})," as Any-style value (ref meta + type meta + value)."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"case_id"})," is unknown, the decoder MUST still consume the case value using ",(0,s.jsx)(n.code,{children:"field_value_type_meta"})," and\nstandard ",(0,s.jsx)(n.code,{children:"skipValue(type_id)"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"when-to-use-each-type-id",children:"When to use each type ID"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"UNION"})," when the union schema is known from context."]}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"TYPED_UNION"})," for dynamic containers when numeric registration is available."]}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"NAMED_UNION"})," when name-based resolution is preferred or required."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"compatibility-notes",children:"Compatibility notes"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"case_id"})," is a stable identifier; added alternatives are forward compatible and unknown cases can be skipped."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"type",children:"Type"}),"\n",(0,s.jsx)(n.p,{children:"Type will be serialized using type meta format."}),"\n",(0,s.jsx)(n.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Byte Order"}),": Always use little-endian for multi-byte values"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Varint Sign Extension"}),": Ensure proper handling of signed vs unsigned varints"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reference ID Ordering"}),": IDs must be assigned in serialization order"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Field Order Consistency"}),": Must match exactly across languages in schema-consistent mode; in compatible mode, match by TypeDef field names or tag IDs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"String Encoding"}),": Use best encoding for current language"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Null Handling"}),": Different languages represent null differently"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Empty Collections"}),": Still write length (0) and header byte"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Schema Hash Calculation"}),": Must use the same fingerprint and MurmurHash3 algorithm across languages when enabled"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"language-implementation-guidelines",children:"Language Implementation Guidelines"}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/docs/specification/xlang_implementation_guide",children:"Xlang Implementation Guide"})," documentation."]})]})}function o(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>l,a:()=>t});var s=i(67294);const r={},d=s.createContext(r);function t(e){const n=s.useContext(d);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),s.createElement(d.Provider,{value:n},e.children)}}}]);