"use strict";(self.webpackChunkfory_site=self.webpackChunkfory_site||[]).push([[1490],{2925:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var r=i(85893),t=i(11151);const a={title:"Java Serialization Guide",sidebar_position:0,id:"java_serialization",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},s=void 0,o={id:"docs/guide/java_serialization",title:"Java Serialization Guide",description:"When only java object serialization needed, this mode will have better performance compared to cross-language object",source:"@site/docs/docs/guide/java_serialization_guide.md",sourceDirName:"docs/guide",slug:"/docs/guide/java_serialization",permalink:"/docs/next/docs/guide/java_serialization",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/fory-site/tree/main/docs/docs/guide/java_serialization_guide.md",tags:[],version:"current",sidebarPosition:0,frontMatter:{title:"Java Serialization Guide",sidebar_position:0,id:"java_serialization",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},sidebar:"docsSidebar",previous:{title:"Usage",permalink:"/docs/next/docs/start/usage"},next:{title:"Python Serialization",permalink:"/docs/next/docs/guide/python_serialization"}},l={},c=[{value:"Quick Start",id:"quick-start",level:2},{value:"ForyBuilder options",id:"forybuilder-options",level:2},{value:"Advanced Usage",id:"advanced-usage",level:2},{value:"Fory creation",id:"fory-creation",level:3},{value:"Handling Class Schema Evolution in Serialization",id:"handling-class-schema-evolution-in-serialization",level:3},{value:"Compression",id:"compression",level:3},{value:"Array Compression",id:"array-compression",level:3},{value:"How Array Compression Works",id:"how-array-compression-works",level:4},{value:"Configuration and Registration",id:"configuration-and-registration",level:4},{value:"Object deep copy",id:"object-deep-copy",level:3},{value:"Cross-Language Serialization",id:"cross-language-serialization",level:3},{value:"Enable Cross-Language Mode",id:"enable-cross-language-mode",level:4},{value:"Register Types for Cross-Language Compatibility",id:"register-types-for-cross-language-compatibility",level:4},{value:"Cross-Language Example: Java \u2194 Python",id:"cross-language-example-java--python",level:4},{value:"Handling Circular and Shared References",id:"handling-circular-and-shared-references",level:4},{value:"Type Mapping Considerations",id:"type-mapping-considerations",level:4},{value:"Performance Considerations",id:"performance-considerations",level:4},{value:"Cross-Language Best Practices",id:"cross-language-best-practices",level:4},{value:"Troubleshooting Cross-Language Serialization",id:"troubleshooting-cross-language-serialization",level:4},{value:"Implement a customized serializer",id:"implement-a-customized-serializer",level:3}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"When only java object serialization needed, this mode will have better performance compared to cross-language object\ngraph serialization."}),"\n",(0,r.jsx)(n.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,r.jsxs)(n.p,{children:["Note that fory creation is not cheap, the ",(0,r.jsx)(n.strong,{children:"fory instances should be reused between serializations"})," instead of creating\nit everytime.\nYou should keep fory to a static global variable, or instance variable of some singleton object or limited objects."]}),"\n",(0,r.jsx)(n.p,{children:"Fory for single-thread usage:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"import java.util.List;\nimport java.util.Arrays;\n\nimport org.apache.fory.*;\nimport org.apache.fory.config.*;\n\npublic class Example {\n  public static void main(String[] args) {\n    SomeClass object = new SomeClass();\n    // Note that Fory instances should be reused between\n    // multiple serializations of different objects.\n    Fory fory = Fory.builder().withLanguage(Language.JAVA)\n      .requireClassRegistration(true)\n      .build();\n    // Registering types can reduce class name serialization overhead, but not mandatory.\n    // If class registration enabled, all custom types must be registered.\n    fory.register(SomeClass.class);\n    byte[] bytes = fory.serialize(object);\n    System.out.println(fory.deserialize(bytes));\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Fory for multiple-thread usage:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"import java.util.List;\nimport java.util.Arrays;\n\nimport org.apache.fory.*;\nimport org.apache.fory.config.*;\n\npublic class Example {\n  public static void main(String[] args) {\n    SomeClass object = new SomeClass();\n    // Note that Fory instances should be reused between\n    // multiple serializations of different objects.\n    ThreadSafeFory fory = new ThreadLocalFory(classLoader -> {\n      Fory f = Fory.builder().withLanguage(Language.JAVA)\n        .withClassLoader(classLoader).build();\n      f.register(SomeClass.class);\n      return f;\n    });\n    byte[] bytes = fory.serialize(object);\n    System.out.println(fory.deserialize(bytes));\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Fory instances reuse example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"import java.util.List;\nimport java.util.Arrays;\n\nimport org.apache.fory.*;\nimport org.apache.fory.config.*;\n\npublic class Example {\n  // reuse fory.\n  private static final ThreadSafeFory fory = new ThreadLocalFory(classLoader -> {\n    Fory f = Fory.builder().withLanguage(Language.JAVA)\n      .withClassLoader(classLoader).build();\n    f.register(SomeClass.class);\n    return f;\n  });\n\n  public static void main(String[] args) {\n    SomeClass object = new SomeClass();\n    byte[] bytes = fory.serialize(object);\n    System.out.println(fory.deserialize(bytes));\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"forybuilder-options",children:"ForyBuilder options"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Option Name"}),(0,r.jsx)(n.th,{children:"Description"}),(0,r.jsx)(n.th,{children:"Default Value"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"timeRefIgnored"})}),(0,r.jsxs)(n.td,{children:["Whether to ignore reference tracking of all time types registered in ",(0,r.jsx)(n.code,{children:"TimeSerializers"})," and subclasses of those types when ref tracking is enabled. If ignored, ref tracking of every time type can be enabled by invoking ",(0,r.jsx)(n.code,{children:"Fory#registerSerializer(Class, Serializer)"}),". For example, ",(0,r.jsx)(n.code,{children:"fory.registerSerializer(Date.class, new DateSerializer(fory, true))"}),". Note that enabling ref tracking should happen before serializer codegen of any types which contain time fields. Otherwise, those fields will still skip ref tracking."]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"compressInt"})}),(0,r.jsx)(n.td,{children:"Enables or disables int compression for smaller size."}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"compressLong"})}),(0,r.jsx)(n.td,{children:"Enables or disables long compression for smaller size."}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"compressIntArray"})}),(0,r.jsx)(n.td,{children:"Enables or disables SIMD-accelerated compression for int arrays when values can fit in smaller data types. Requires Java 16+."}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"compressLongArray"})}),(0,r.jsx)(n.td,{children:"Enables or disables SIMD-accelerated compression for long arrays when values can fit in smaller data types. Requires Java 16+."}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"compressString"})}),(0,r.jsx)(n.td,{children:"Enables or disables string compression for smaller size."}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"false"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"classLoader"})}),(0,r.jsxs)(n.td,{children:["The classloader should not be updated; Fory caches class metadata. Use ",(0,r.jsx)(n.code,{children:"LoaderBinding"})," or ",(0,r.jsx)(n.code,{children:"ThreadSafeFory"})," for classloader updates."]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Thread.currentThread().getContextClassLoader()"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"compatibleMode"})}),(0,r.jsxs)(n.td,{children:["Type forward/backward compatibility config. Also Related to ",(0,r.jsx)(n.code,{children:"checkClassVersion"})," config. ",(0,r.jsx)(n.code,{children:"SCHEMA_CONSISTENT"}),": Class schema must be consistent between serialization peer and deserialization peer. ",(0,r.jsx)(n.code,{children:"COMPATIBLE"}),": Class schema can be different between serialization peer and deserialization peer. They can add/delete fields independently. ",(0,r.jsx)(n.a,{href:"#class-inconsistency-and-class-version-check",children:"See more"}),"."]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"CompatibleMode.SCHEMA_CONSISTENT"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"checkClassVersion"})}),(0,r.jsxs)(n.td,{children:["Determines whether to check the consistency of the class schema. If enabled, Fory checks, writes, and checks consistency using the ",(0,r.jsx)(n.code,{children:"classVersionHash"}),". It will be automatically disabled when ",(0,r.jsx)(n.code,{children:"CompatibleMode#COMPATIBLE"})," is enabled. Disabling is not recommended unless you can ensure the class won't evolve."]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"false"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"checkJdkClassSerializable"})}),(0,r.jsxs)(n.td,{children:["Enables or disables checking of ",(0,r.jsx)(n.code,{children:"Serializable"})," interface for classes under ",(0,r.jsx)(n.code,{children:"java.*"}),". If a class under ",(0,r.jsx)(n.code,{children:"java.*"})," is not ",(0,r.jsx)(n.code,{children:"Serializable"}),", Fory will throw an ",(0,r.jsx)(n.code,{children:"UnsupportedOperationException"}),"."]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"registerGuavaTypes"})}),(0,r.jsxs)(n.td,{children:["Whether to pre-register Guava types such as ",(0,r.jsx)(n.code,{children:"RegularImmutableMap"}),"/",(0,r.jsx)(n.code,{children:"RegularImmutableList"}),". These types are not public API, but seem pretty stable."]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"requireClassRegistration"})}),(0,r.jsx)(n.td,{children:"Disabling may allow unknown classes to be deserialized, potentially causing security risks."}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"requireClassRegistration"})}),(0,r.jsx)(n.td,{children:"Set max depth for deserialization, when depth exceeds, an exception will be thrown. This can be used to refuse deserialization DDOS attack."}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"50"})})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["| ",(0,r.jsx)(n.code,{children:"suppressClassRegistrationWarnings"})," | Whether to suppress class registration warnings. The warnings can be used for security audit, but may be annoying, this suppression will be enabled by default. | ",(0,r.jsx)(n.code,{children:"true"})," |\n| ",(0,r.jsx)(n.code,{children:"metaShareEnabled"})," | Enables or disables meta share mode. | ",(0,r.jsx)(n.code,{children:"true"})," if ",(0,r.jsx)(n.code,{children:"CompatibleMode.Compatible"})," is set, otherwise false. |\n| ",(0,r.jsx)(n.code,{children:"scopedMetaShareEnabled"})," | Scoped meta share focuses on a single serialization process. Metadata created or identified during this process is exclusive to it and is not shared with by other serializations. | ",(0,r.jsx)(n.code,{children:"true"})," if ",(0,r.jsx)(n.code,{children:"CompatibleMode.Compatible"})," is set, otherwise false. |\n| ",(0,r.jsx)(n.code,{children:"metaCompressor"})," | Set a compressor for meta compression. Note that the passed MetaCompressor should be thread-safe. By default, a ",(0,r.jsx)(n.code,{children:"Deflater"})," based compressor ",(0,r.jsx)(n.code,{children:"DeflaterMetaCompressor"})," will be used. Users can pass other compressor such as ",(0,r.jsx)(n.code,{children:"zstd"})," for better compression rate. | ",(0,r.jsx)(n.code,{children:"DeflaterMetaCompressor"})," |\n| ",(0,r.jsx)(n.code,{children:"deserializeNonexistentClass"})," | Enables or disables deserialization/skipping of data for non-existent classes. | ",(0,r.jsx)(n.code,{children:"true"})," if ",(0,r.jsx)(n.code,{children:"CompatibleMode.Compatible"})," is set, otherwise false. |\n| ",(0,r.jsx)(n.code,{children:"codeGenEnabled"})," | Disabling may result in faster initial serialization but slower subsequent serializations. | ",(0,r.jsx)(n.code,{children:"true"})," |\n| ",(0,r.jsx)(n.code,{children:"asyncCompilationEnabled"})," | If enabled, serialization uses interpreter mode first and switches to JIT serialization after async serializer JIT for a class is finished. | ",(0,r.jsx)(n.code,{children:"false"})," |\n| ",(0,r.jsx)(n.code,{children:"scalaOptimizationEnabled"})," | Enables or disables Scala-specific serialization optimization. | ",(0,r.jsx)(n.code,{children:"false"})," |\n| ",(0,r.jsx)(n.code,{children:"copyRef"})," | When disabled, the copy performance will be better. But fory deep copy will ignore circular and shared reference. Same reference of an object graph will be copied into different objects in one ",(0,r.jsx)(n.code,{children:"Fory#copy"}),". | ",(0,r.jsx)(n.code,{children:"true"})," |\n| ",(0,r.jsx)(n.code,{children:"serializeEnumByName"})," | When Enabled, fory serialize enum by name instead of ordinal. | ",(0,r.jsx)(n.code,{children:"false"})," |"]}),"\n",(0,r.jsx)(n.h2,{id:"advanced-usage",children:"Advanced Usage"}),"\n",(0,r.jsx)(n.h3,{id:"fory-creation",children:"Fory creation"}),"\n",(0,r.jsx)(n.p,{children:"Single thread fory:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"Fory fory = Fory.builder()\n  .withLanguage(Language.JAVA)\n  // enable reference tracking for shared/circular reference.\n  // Disable it will have better performance if no duplicate reference.\n  .withRefTracking(false)\n  .withCompatibleMode(CompatibleMode.SCHEMA_CONSISTENT)\n  // enable type forward/backward compatibility\n  // disable it for small size and better performance.\n  // .withCompatibleMode(CompatibleMode.COMPATIBLE)\n  // enable async multi-threaded compilation.\n  .withAsyncCompilation(true)\n  .build();\nbyte[] bytes = fory.serialize(object);\nSystem.out.println(fory.deserialize(bytes));\n"})}),"\n",(0,r.jsx)(n.p,{children:"Thread-safe fory:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ThreadSafeFory fory = Fory.builder()\n  .withLanguage(Language.JAVA)\n  // enable reference tracking for shared/circular reference.\n  // Disable it will have better performance if no duplicate reference.\n  .withRefTracking(false)\n  // compress int for smaller size\n  // .withIntCompressed(true)\n  // compress long for smaller size\n  // .withLongCompressed(true)\n  .withCompatibleMode(CompatibleMode.SCHEMA_CONSISTENT)\n  // enable type forward/backward compatibility\n  // disable it for small size and better performance.\n  // .withCompatibleMode(CompatibleMode.COMPATIBLE)\n  // enable async multi-threaded compilation.\n  .withAsyncCompilation(true)\n  .buildThreadSafeFory();\nbyte[] bytes = fory.serialize(object);\nSystem.out.println(fory.deserialize(bytes));\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Note that calling ",(0,r.jsx)(n.code,{children:"buildThreadSafeFory()"})," on ",(0,r.jsx)(n.code,{children:"ForyBuilder"})," will create an instance of ",(0,r.jsx)(n.code,{children:"ThreadLocalFory"}),".\nThis may not be appropriate in environments where virtual threads are used, as each thread will create its own fory instance, a relatively expensive operation.\nAn alternative for virtual threads is to use ",(0,r.jsx)(n.code,{children:"buildThreadSafeForyPool"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"handling-class-schema-evolution-in-serialization",children:"Handling Class Schema Evolution in Serialization"}),"\n",(0,r.jsx)(n.p,{children:"In many systems, the schema of a class used for serialization may change over time. For instance, fields within a class\nmay be added or removed. When serialization and deserialization processes use different versions of jars, the schema of\nthe class being deserialized may differ from the one used during serialization."}),"\n",(0,r.jsxs)(n.p,{children:["By default, Fory serializes objects using the ",(0,r.jsx)(n.code,{children:"CompatibleMode.SCHEMA_CONSISTENT"})," mode. This mode assumes that the\ndeserialization process uses the same class schema as the serialization process, minimizing payload overhead.\nHowever, if there is a schema inconsistency, deserialization will fail."]}),"\n",(0,r.jsxs)(n.p,{children:["If the schema is expected to change, to make deserialization succeed, i.e. schema forward/backward compatibility.\nUsers must configure Fory to use ",(0,r.jsx)(n.code,{children:"CompatibleMode.COMPATIBLE"}),". This can be done using the\n",(0,r.jsx)(n.code,{children:"ForyBuilder#withCompatibleMode(CompatibleMode.COMPATIBLE)"})," method.\nIn this compatible mode, deserialization can handle schema changes such as missing or extra fields, allowing it to\nsucceed even when the serialization and deserialization processes have different class schemas."]}),"\n",(0,r.jsx)(n.p,{children:"Here is an example of creating Fory to support schema evolution:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"Fory fory = Fory.builder()\n  .withCompatibleMode(CompatibleMode.COMPATIBLE)\n  .build();\n\nbyte[] bytes = fory.serialize(object);\nSystem.out.println(fory.deserialize(bytes));\n"})}),"\n",(0,r.jsx)(n.p,{children:"This compatible mode involves serializing class metadata into the serialized output. Despite Fory's use of\nsophisticated compression techniques to minimize overhead, there is still some additional space cost associated with\nclass metadata."}),"\n",(0,r.jsxs)(n.p,{children:["To further reduce metadata costs, Fory introduces a class metadata sharing mechanism, which allows the metadata to be\nsent to the deserialization process only once. For more details, please refer to the ",(0,r.jsx)(n.a,{href:"https://fory.apache.org/docs/specification/fory_java_serialization_spec#meta-share",children:"Meta Sharing"})," specification."]}),"\n",(0,r.jsx)(n.h3,{id:"compression",children:"Compression"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"ForyBuilder#withIntCompressed"}),"/",(0,r.jsx)(n.code,{children:"ForyBuilder#withLongCompressed"})," can be used to compress int/long for smaller size.\nNormally compress int is enough."]}),"\n",(0,r.jsx)(n.p,{children:"Both compression are enabled by default, if the serialized is not important, for example, you use flatbuffers for\nserialization before, which doesn't compress anything, then you should disable compression. If your data are all\nnumbers,\nthe compression may bring 80% performance regression."}),"\n",(0,r.jsx)(n.p,{children:"For int compression, fory use 1~5 bytes for encoding. First bit in every byte indicate whether has next byte. if first\nbit is set, then next byte will be read util first bit of next byte is unset."}),"\n",(0,r.jsx)(n.p,{children:"For long compression, fory support two encoding:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Fory SLI(Small long as int) Encoding (",(0,r.jsx)(n.strong,{children:"used by default"}),"):","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If long is in ",(0,r.jsx)(n.code,{children:"[-1073741824, 1073741823]"}),", encode as 4 bytes int: ",(0,r.jsx)(n.code,{children:"| little-endian: ((int) value) << 1 |"})]}),"\n",(0,r.jsxs)(n.li,{children:["Otherwise write as 9 bytes: ",(0,r.jsx)(n.code,{children:"| 0b1 | little-endian 8bytes long |"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Fory PVL(Progressive Variable-length Long) Encoding:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"First bit in every byte indicate whether has next byte. if first bit is set, then next byte will be read util\nfirst bit of next byte is unset."}),"\n",(0,r.jsxs)(n.li,{children:["Negative number will be converted to positive number by ",(0,r.jsx)(n.code,{children:"(v << 1) ^ (v >> 63)"})," to reduce cost of small negative\nnumbers."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["If a number are ",(0,r.jsx)(n.code,{children:"long"})," type, it can't be represented by smaller bytes mostly, the compression won't get good enough\nresult,\nnot worthy compared to performance cost. Maybe you should try to disable long compression if you find it didn't bring\nmuch\nspace savings."]}),"\n",(0,r.jsx)(n.h3,{id:"array-compression",children:"Array Compression"}),"\n",(0,r.jsxs)(n.p,{children:["Fory supports SIMD-accelerated compression for primitive arrays (",(0,r.jsx)(n.code,{children:"int[]"})," and ",(0,r.jsx)(n.code,{children:"long[]"}),") when array values can fit in smaller data types. This feature is available on Java 16+ and uses the Vector API for optimal performance."]}),"\n",(0,r.jsx)(n.h4,{id:"how-array-compression-works",children:"How Array Compression Works"}),"\n",(0,r.jsx)(n.p,{children:"Array compression analyzes arrays to determine if values can be stored using fewer bytes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"int[]"})," \u2192 ",(0,r.jsx)(n.code,{children:"byte[]"})]}),": When all values are in range [-128, 127] (75% size reduction)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"int[]"})," \u2192 ",(0,r.jsx)(n.code,{children:"short[]"})]}),": When all values are in range [-32768, 32767] (50% size reduction)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"long[]"})," \u2192 ",(0,r.jsx)(n.code,{children:"int[]"})]}),": When all values fit in integer range (50% size reduction)"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"configuration-and-registration",children:"Configuration and Registration"}),"\n",(0,r.jsx)(n.p,{children:"To enable array compression you must explicitly register the serializers:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"Fory fory = Fory.builder()\n  .withLanguage(Language.JAVA)\n  // Enable int array compression\n  .withIntArrayCompressed(true)\n  // Enable long array compression\n  .withLongArrayCompressed(true)\n  .build();\n\n// You must explicitly register compressed array serializers\nCompressedArraySerializers.registerSerializers(fory);\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note"}),": The ",(0,r.jsx)(n.code,{children:"fory-simd"})," module must be included in your dependencies for compressed array serializers to be available."]}),"\n",(0,r.jsx)(n.p,{children:"For Maven:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<dependency>\n  <groupId>org.apache.fory</groupId>\n  <artifactId>fory-simd</artifactId>\n  <version>0.13.0</version>\n</dependency>\n"})}),"\n",(0,r.jsx)(n.h3,{id:"object-deep-copy",children:"Object deep copy"}),"\n",(0,r.jsx)(n.p,{children:"Deep copy example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"Fory fory = Fory.builder().withRefCopy(true).build();\nSomeClass a = xxx;\nSomeClass copied = fory.copy(a);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Make fory deep copy ignore circular and shared reference, this deep copy mode will ignore circular and shared reference.\nSame reference of an object graph will be copied into different objects in one ",(0,r.jsx)(n.code,{children:"Fory#copy"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"Fory fory = Fory.builder().withRefCopy(false).build();\nSomeClass a = xxx;\nSomeClass copied = fory.copy(a);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"cross-language-serialization",children:"Cross-Language Serialization"}),"\n",(0,r.jsx)(n.p,{children:"Apache Fory\u2122 supports seamless data exchange between Java and other languages (Python, Rust, Go, JavaScript, etc.) through the xlang serialization format. This enables multi-language microservices, polyglot data pipelines, and cross-platform data sharing."}),"\n",(0,r.jsx)(n.h4,{id:"enable-cross-language-mode",children:"Enable Cross-Language Mode"}),"\n",(0,r.jsxs)(n.p,{children:["To serialize data for consumption by other languages, use ",(0,r.jsx)(n.code,{children:"Language.XLANG"})," mode:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"import org.apache.fory.*;\nimport org.apache.fory.config.*;\n\n// Create Fory instance with XLANG mode\nFory fory = Fory.builder()\n    .withLanguage(Language.XLANG)\n    .withRefTracking(true)  // Enable reference tracking for complex graphs\n    .build();\n"})}),"\n",(0,r.jsx)(n.h4,{id:"register-types-for-cross-language-compatibility",children:"Register Types for Cross-Language Compatibility"}),"\n",(0,r.jsxs)(n.p,{children:["Types must be registered with ",(0,r.jsx)(n.strong,{children:"consistent IDs or names"})," across all languages. Fory supports two registration methods:"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"1. Register by ID (Recommended for Performance)"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public record Person(String name, int age) {}\n\n// Register with numeric ID - faster and more compact\nfory.register(Person.class, 1);\n\nPerson person = new Person("Alice", 30);\nbyte[] bytes = fory.serialize(person);\n// bytes can be deserialized by Python, Rust, Go, etc.\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Benefits"}),": Faster serialization, smaller binary size\n",(0,r.jsx)(n.strong,{children:"Trade-offs"}),": Requires coordination to avoid ID conflicts across teams/services"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"2. Register by Name (Recommended for Flexibility)"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public record Person(String name, int age) {}\n\n// Register with string name - more flexible\nfory.register(Person.class, "example.Person");\n\nPerson person = new Person("Alice", 30);\nbyte[] bytes = fory.serialize(person);\n// bytes can be deserialized by Python, Rust, Go, etc.\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Benefits"}),": Less prone to conflicts, easier management across teams, no coordination needed\n",(0,r.jsx)(n.strong,{children:"Trade-offs"}),": Slightly larger binary size due to string encoding"]}),"\n",(0,r.jsx)(n.h4,{id:"cross-language-example-java--python",children:"Cross-Language Example: Java \u2194 Python"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Java (Serializer)"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'import org.apache.fory.*;\nimport org.apache.fory.config.*;\n\npublic record Person(String name, int age) {}\n\npublic class Example {\n    public static void main(String[] args) {\n        Fory fory = Fory.builder()\n            .withLanguage(Language.XLANG)\n            .withRefTracking(true)\n            .build();\n\n        // Register with consistent name\n        fory.register(Person.class, "example.Person");\n\n        Person person = new Person("Bob", 25);\n        byte[] bytes = fory.serialize(person);\n\n        // Send bytes to Python service via network/file/queue\n    }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Python (Deserializer)"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import pyfory\nfrom dataclasses import dataclass\n\n@dataclass\nclass Person:\n    name: str\n    age: pyfory.int32\n\n# Create Fory in xlang mode\nfory = pyfory.Fory(ref_tracking=True)\n\n# Register with the SAME name as Java\nfory.register_type(Person, typename="example.Person")\n\n# Deserialize bytes from Java\nperson = fory.deserialize(bytes_from_java)\nprint(f"{person.name}, {person.age}")  # Output: Bob, 25\n'})}),"\n",(0,r.jsx)(n.h4,{id:"handling-circular-and-shared-references",children:"Handling Circular and Shared References"}),"\n",(0,r.jsx)(n.p,{children:"Cross-language mode supports circular and shared references when reference tracking is enabled:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public class Node {\n    public String value;\n    public Node next;\n    public Node parent;\n}\n\nFory fory = Fory.builder()\n    .withLanguage(Language.XLANG)\n    .withRefTracking(true)  // Required for circular references\n    .build();\n\nfory.register(Node.class, "example.Node");\n\n// Create circular reference\nNode node1 = new Node();\nnode1.value = "A";\nNode node2 = new Node();\nnode2.value = "B";\nnode1.next = node2;\nnode2.parent = node1;  // Circular reference\n\nbyte[] bytes = fory.serialize(node1);\n// Python/Rust/Go can correctly deserialize this with circular references preserved\n'})}),"\n",(0,r.jsx)(n.h4,{id:"type-mapping-considerations",children:"Type Mapping Considerations"}),"\n",(0,r.jsx)(n.p,{children:"Not all Java types have equivalents in other languages. When using xlang mode:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.strong,{children:"primitive types"})," (",(0,r.jsx)(n.code,{children:"int"}),", ",(0,r.jsx)(n.code,{children:"long"}),", ",(0,r.jsx)(n.code,{children:"double"}),", ",(0,r.jsx)(n.code,{children:"String"}),") for maximum compatibility"]}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.strong,{children:"standard collections"})," (",(0,r.jsx)(n.code,{children:"List"}),", ",(0,r.jsx)(n.code,{children:"Map"}),", ",(0,r.jsx)(n.code,{children:"Set"}),") instead of language-specific ones"]}),"\n",(0,r.jsxs)(n.li,{children:["Avoid ",(0,r.jsx)(n.strong,{children:"Java-specific types"})," like ",(0,r.jsx)(n.code,{children:"Optional"}),", ",(0,r.jsx)(n.code,{children:"BigDecimal"})," (unless the target language supports them)"]}),"\n",(0,r.jsxs)(n.li,{children:["See ",(0,r.jsx)(n.a,{href:"https://fory.apache.org/docs/specification/xlang_type_mapping",children:"Type Mapping Guide"})," for complete compatibility matrix"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Compatible Types"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public record UserData(\n    String name,           // \u2705 Compatible\n    int age,               // \u2705 Compatible\n    List<String> tags,     // \u2705 Compatible\n    Map<String, Integer> scores  // \u2705 Compatible\n) {}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problematic Types"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public record UserData(\n    Optional<String> name,    // \u274c Not cross-language compatible\n    BigDecimal balance,       // \u274c Limited support\n    EnumSet<Status> statuses  // \u274c Java-specific collection\n) {}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,r.jsx)(n.p,{children:"Cross-language mode has additional overhead compared to Java-only mode:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type metadata encoding"}),": Adds extra bytes per type"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type resolution"}),": Requires name/ID lookup during deserialization"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"For best performance"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.strong,{children:"ID-based registration"})," when possible (smaller encoding)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Disable reference tracking"})," if you don't need circular references (",(0,r.jsx)(n.code,{children:"withRefTracking(false)"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Java mode"})," (",(0,r.jsx)(n.code,{children:"Language.JAVA"}),") when only Java serialization is needed"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"cross-language-best-practices",children:"Cross-Language Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consistent Registration"}),": Ensure all services register types with identical IDs/names"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Version Compatibility"}),": Use compatible mode for schema evolution across services"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"troubleshooting-cross-language-serialization",children:"Troubleshooting Cross-Language Serialization"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:'"Type not registered" errors'}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Verify type is registered with same ID/name on both sides"}),"\n",(0,r.jsx)(n.li,{children:"Check if type name has typos or case differences"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:'"Type mismatch" errors'}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Ensure field types are compatible across languages"}),"\n",(0,r.jsxs)(n.li,{children:["Review ",(0,r.jsx)(n.a,{href:"https://fory.apache.org/docs/next/specification/xlang_type_mapping",children:"Type Mapping Guide"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Data corruption or unexpected values"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Verify both sides use ",(0,r.jsx)(n.code,{children:"Language.XLANG"})," mode"]}),"\n",(0,r.jsx)(n.li,{children:"Ensure both sides have compatible Fory versions"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"See Also"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://fory.apache.org/docs/next/specification/fory_xlang_serialization_spec",children:"Cross-Language Serialization Specification"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://fory.apache.org/docs/next/specification/xlang_type_mapping",children:"Type Mapping Reference"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/next/docs/guide/python_serialization#cross-language-serialization",children:"Python Cross-Language Guide"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/next/docs/guide/rust_serialization#-cross-language-serialization",children:"Rust Cross-Language Guide"})}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"implement-a-customized-serializer",children:"Implement a customized serializer"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\nIn some cases, you may want to implement a serializer for your type, especially some class customize serialization by\nJDK `writeObject/writeReplace/readObject/readResolve`, which is very inefficient. For example, if you don't want\nfollowing `Foo#writeObject` got invoked, you can take following `FooSerializer` as an example:\n\n```java\nclass Foo {\n  public long f1;\n\n  private void writeObject(ObjectOutputStream s) throws IOException {\n    System.out.println(f1);\n    s.defaultWriteObject();\n  }\n}\n\nclass FooSerializer extends Serializer<Foo> {\n  public FooSerializer(Fory fory) {\n    super(fory, Foo.class);\n  }\n\n  @Override\n  public void write(MemoryBuffer buffer, Foo value) {\n    buffer.writeInt64(value.f1);\n  }\n\n  @Override\n  public Foo read(MemoryBuffer buffer) {\n    Foo foo = new Foo();\n    foo.f1 = buffer.readInt64();\n    return foo;\n  }\n}\n```\n\nRegister serializer:\n\n```java\nFory fory = getFory();\nfory.registerSerializer(Foo.class, new FooSerializer(fory));\n```\n\n### Implement Collection Serializer\n\nSimilar to maps, when implementing a serializer for a custom Collection type, you must extend `CollectionSerializer` or `CollectionLikeSerializer`.\nThe key difference between these two is that `CollectionLikeSerializer` can serialize a class which has a collection-like structure but is not a java Collection subtype.\n\nFor collection serializer, this is a special parameter `supportCodegenHook` needs be configured:\n\n- When `true`:\n  - Enables optimized access to collection elements and JIT compilation for better performance\n  - Direct serialization invocation and inline for map key-value items without dynamic serializer dispatch cost.\n  - Better performance for standard collection types\n  - Recommended for most collections\n\n- When `false`:\n  - Uses interfaced-based element access and dynamic serializer dispatch for elements, which have higher cost\n  - More flexible for custom collection types\n  - Required when collection has special serialization needs\n  - Handles complex collection implementations\n\n#### Implement Collection Serializer with JIT support\n\nWhen implementing a Collection serializer with JIT support, you can leverage Fory's existing binary format and collection serialization infrastructure. The key is to properly implement the `onCollectionWrite` and `newCollection` methods to handle metadata while letting Fory handle the element serialization.\n\nHere's an example:\n\n```java\npublic class CustomCollectionSerializer<T extends Collection> extends CollectionSerializer<T> {\n    public CustomCollectionSerializer(Fory fory, Class<T> cls) {\n        // supportCodegenHook controls whether to use JIT compilation\n        super(fory, cls, true);\n    }\n\n    @Override\n    public Collection onCollectionWrite(MemoryBuffer buffer, T value) {\n        // Write collection size\n        buffer.writeVarUint32Small7(value.size());\n        // Write any additional collection metadata\n        return value;\n    }\n\n    @Override\n    public Collection newCollection(MemoryBuffer buffer) {\n        // Create new collection instance\n        Collection collection = super.newCollection(buffer);\n        // Read and set collection size\n        int numElements = getAndClearNumElements();\n        setNumElements(numElements);\n        return collection;\n    }\n}\n```\n\nNote that please invoke `setNumElements` when implementing `newCollection` to let fory know how many elements to deserialize.\n\n#### Implement a totally-customzied Collection Serializer without JIT\n\nSometimes you need to serialize a collection type that uses primitive arrays or has special requirements.\nIn such cases, you can implement a serializer with JIT disabled and directly override the `write` and `read` methods.\n\nThis approach:\n\n- Gives you full control over serialization\n- Works well with primitive arrays\n- Bypasses collection iteration overhead\n- Allows direct memory access\n\nHere's an example of a custom integer list backed by a primitive array:\n\n```java\nclass IntList extends AbstractCollection<Integer> {\n    private final int[] elements;\n    private final int size;\n\n    public IntList(int size) {\n        this.elements = new int[size];\n        this.size = size;\n    }\n\n    public IntList(int[] elements, int size) {\n        this.elements = elements;\n        this.size = size;\n    }\n\n    @Override\n    public Iterator<Integer> iterator() {\n        return new Iterator<Integer>() {\n            private int index = 0;\n\n            @Override\n            public boolean hasNext() {\n                return index < size;\n            }\n\n            @Override\n            public Integer next() {\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                return elements[index++];\n            }\n        };\n    }\n\n    @Override\n    public int size() {\n        return size;\n    }\n\n    public int get(int index) {\n        if (index >= size) {\n            throw new IndexOutOfBoundsException();\n        }\n        return elements[index];\n    }\n\n    public void set(int index, int value) {\n        if (index >= size) {\n            throw new IndexOutOfBoundsException();\n        }\n        elements[index] = value;\n    }\n\n    public int[] getElements() {\n        return elements;\n    }\n}\n\nclass IntListSerializer extends CollectionLikeSerializer<IntList> {\n    public IntListSerializer(Fory fory) {\n        // Disable JIT since we're handling serialization directly\n        super(fory, IntList.class, false);\n    }\n\n    @Override\n    public void write(MemoryBuffer buffer, IntList value) {\n        // Write size\n        buffer.writeVarUint32Small7(value.size());\n\n        // Write elements directly as primitive ints\n        int[] elements = value.getElements();\n        for (int i = 0; i < value.size(); i++) {\n            buffer.writeVarInt32(elements[i]);\n        }\n    }\n\n    @Override\n    public IntList read(MemoryBuffer buffer) {\n        // Read size\n        int size = buffer.readVarUint32Small7();\n\n        // Create array and read elements\n        int[] elements = new int[size];\n        for (int i = 0; i < size; i++) {\n            elements[i] = buffer.readVarInt32();\n        }\n\n        return new IntList(elements, size);\n    }\n\n    // These methods are not used when JIT is disabled\n    @Override\n    public Collection onCollectionWrite(MemoryBuffer buffer, IntList value) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Collection newCollection(MemoryBuffer buffer) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public IntList onCollectionRead(Collection collection) {\n        throw new UnsupportedOperationException();\n    }\n}\n```\n\nKey Points:\n\n1. **Primitive Array Storage**:\n   - Uses `int[]` for direct storage\n   - Avoids boxing/unboxing overhead\n   - Provides efficient memory layout\n   - Enables direct array access\n\n2. **Direct Serialization**:\n   - Write size first\n   - Write primitive values directly\n   - No iteration overhead\n   - No boxing/unboxing during serialization\n\n3. **Direct Deserialization**:\n   - Read size first\n   - Create primitive array\n   - Read values directly into array\n   - Create list with populated array\n\n4. **Disabled JIT**:\n   - Set `supportCodegenHook=false`\n   - Override `write`/`read` methods\n   - Skip collection view pattern\n   - Full control over serialization format\n\nWhen to Use: this approach is best when:\n\n- Working with primitive types\n- Need maximum performance\n- Want to minimize memory overhead\n- Have special serialization requirements\n\nUsage Example:\n\n```java\n// Create and populate list\nIntList list = new IntList(3);\nlist.set(0, 1);\nlist.set(1, 2);\nlist.set(2, 3);\n\n// Serialize\nbyte[] bytes = fory.serialize(list);\n\n// Deserialize\nIntList newList = (IntList) fory.deserialize(bytes);\n```\n\nThis implementation is particularly efficient for scenarios where:\n\n- You're working exclusively with integers\n- Performance is critical\n- Memory efficiency is important\n- Serialization overhead needs to be minimized\n\nRemember that while this approach gives up some of Fory's optimizations, it can provide better performance for specific use cases involving primitive types and direct array access.\n\n#### Implement Serializer for Collection-like Types\n\nSometimes you may want to implement a serializer for a type that behaves like a collection but isn't a standard Java Collection. This section demonstrates how to implement a serializer for such types.\n\nThe key principles for collection-like type serialization are:\n\n1. Extend `CollectionLikeSerializer` for custom collection-like types\n2. Enable JIT optimization with `supportCodegenHook`\n3. Provide efficient element access through views\n4. Maintain proper size tracking\n\nHere's an example:\n\n```java\nclass CustomCollectionLike {\n    private final Object[] elements;\n    private final int size;\n\n    public CustomCollectionLike(int size) {\n        this.elements = new Object[size];\n        this.size = size;\n    }\n\n    // Constructor for wrapping existing array\n    public CustomCollectionLike(Object[] elements, int size) {\n        this.elements = elements;\n        this.size = size;\n    }\n\n    public Object get(int index) {\n        if (index >= size) {\n            throw new IndexOutOfBoundsException();\n        }\n        return elements[index];\n    }\n\n    public int size() {\n        return size;\n    }\n\n    public Object[] getElements() {\n        return elements;\n    }\n}\n\n// A view class that extends AbstractCollection for simpler implementation\nclass CollectionView extends AbstractCollection<Object> {\n    private final Object[] elements;\n    private final int size;\n    private int writeIndex;\n\n    // Constructor for serialization (wrapping existing array)\n    public CollectionView(CustomCollectionLike collection) {\n        this.elements = collection.getElements();\n        this.size = collection.size();\n    }\n\n    // Constructor for deserialization\n    public CollectionView(int size) {\n        this.size = size;\n        this.elements = new Object[size];\n    }\n\n    @Override\n    public Iterator<Object> iterator() {\n        return new Iterator<Object>() {\n            private int index = 0;\n\n            @Override\n            public boolean hasNext() {\n                return index < size;\n            }\n\n            @Override\n            public Object next() {\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                return elements[index++];\n            }\n        };\n    }\n\n    @Override\n    public boolean add(Object element) {\n        if (writeIndex >= size) {\n            throw new IllegalStateException(\"Collection is full\");\n        }\n        elements[writeIndex++] = element;\n        return true;\n    }\n\n    @Override\n    public int size() {\n        return size;\n    }\n\n    public Object[] getElements() {\n        return elements;\n    }\n}\n\nclass CustomCollectionSerializer extends CollectionLikeSerializer<CustomCollectionLike> {\n    public CustomCollectionSerializer(Fory fory) {\n        super(fory, CustomCollectionLike.class, true);\n    }\n\n    @Override\n    public Collection onCollectionWrite(MemoryBuffer buffer, CustomCollectionLike value) {\n        buffer.writeVarUint32Small7(value.size());\n        return new CollectionView(value);\n    }\n\n    @Override\n    public Collection newCollection(MemoryBuffer buffer) {\n        int numElements = buffer.readVarUint32Small7();\n        setNumElements(numElements);\n        return new CollectionView(numElements);\n    }\n\n    @Override\n    public CustomCollectionLike onCollectionRead(Collection collection) {\n        CollectionView view = (CollectionView) collection;\n        return new CustomCollectionLike(view.getElements(), view.size());\n    }\n}\n```\n\nKey takeways:\n\n1. **Collection Structure**:\n   - Array-based storage for elements\n   - Fixed size after creation\n   - Direct element access\n   - Size tracking\n\n2. **View Implementation**:\n   - Extends `AbstractCollection` for simplicity\n   - Provides iterator for element access\n   - Implements `add()` for deserialization\n   - Shares array reference with original type\n\n3. **Serializer Features**:\n   - Uses `supportCodegenHook=true` for JIT optimization\n   - Shares array references when possible\n   - Maintains proper size tracking\n   - Uses view pattern for serialization\n\n4. **Performance Aspects**:\n   - Direct array access\n   - Minimal object creation\n   - Array sharing between instances\n   - Efficient iteration\n\nNote that this implementation provides better performance at the cost of flexibility. Consider your specific use case when choosing this approach.\n\n### Implement Map Serializer\n\nWhen implementing a serializer for a custom Map type, you must extend `MapSerializer` or `MapLikeSerializer`. The key difference between these two is that `MapLikeSerializer` can serialize a class which has a map-like structure but is not a java Map subtype.\n\nSimilar to collection serializer, this is a special parameter `supportCodegenHook` needs be configured:\n\n- When `true`:\n  - Enables optimized access to map elements and JIT compilation for better performance\n  - Direct serialization invocation and inline for map key-value items without dynamic serializer dispatch cost.\n  - Better performance for standard map types\n  - Recommended for most maps\n\n- When `false`:\n  - Uses interfaced-based element access and dynamic serializer dispatch for elements, which have higher cost\n  - More flexible for custom map types\n  - Required when map has special serialization needs\n  - Handles complex map implementations\n\n#### Implement Map Serializer with JIT support\n\nWhen implementing a Map serializer with JIT support, you can leverage Fory's existing chunk-based binary format and map serialization infrastructure. The key is to properly implement the `onMapWrite` and `newMap` methods to handle metadata while letting Fory handle the map key-value serialization.\n\nHere's an example of implementing a custom map serializer:\n\n```java\npublic class CustomMapSerializer<T extends Map> extends MapSerializer<T> {\n    public CustomMapSerializer(Fory fory, Class<T> cls) {\n        // supportCodegenHook is a critical parameter that determines serialization behavior\n        super(fory, cls, true);\n    }\n\n    @Override\n    public Map onMapWrite(MemoryBuffer buffer, T value) {\n        // Write map size\n        buffer.writeVarUint32Small7(value.size());\n        // Write any additional map metadata here\n        return value;\n    }\n\n    @Override\n    public Map newMap(MemoryBuffer buffer) {\n        // Read map size\n        int numElements = buffer.readVarUint32Small7();\n        setNumElements(numElements);\n        // Create and return new map instance\n        T map = (T) new HashMap(numElements);\n        fory.getRefResolver().reference(map);\n        return map;\n    }\n}\n```\n\nNote that please invoke `setNumElements` when implementing `newMap` to let fory know how many elements to deserialize.\n\n#### Implement a totally-customzied Map Serializer without JIT\n\nSometimes you may need complete control over the serialization process, or your map type might have special requirements that don't fit the standard patterns. In such cases, you can implement a serializer with `supportCodegenHook=false` and directly override the `write` and `read` methods.\n\nThis approach:\n\n- Gives you full control over serialization\n- Allows custom binary format\n- Bypasses the standard map serialization pattern\n- May be simpler for special cases\n\nHere's an example:\n\n```java\nclass FixedValueMap extends AbstractMap<String, Integer> {\n    private final Set<String> keys;\n    private final int fixedValue;\n\n    public FixedValueMap(Set<String> keys, int fixedValue) {\n        this.keys = keys;\n        this.fixedValue = fixedValue;\n    }\n\n    @Override\n    public Set<Entry<String, Integer>> entrySet() {\n        Set<Entry<String, Integer>> entries = new HashSet<>();\n        for (String key : keys) {\n            entries.add(new SimpleEntry<>(key, fixedValue));\n        }\n        return entries;\n    }\n\n    @Override\n    public Integer get(Object key) {\n        return keys.contains(key) ? fixedValue : null;\n    }\n\n    public Set<String> getKeys() {\n        return keys;\n    }\n\n    public int getFixedValue() {\n        return fixedValue;\n    }\n}\n\nclass FixedValueMapSerializer extends MapLikeSerializer<FixedValueMap> {\n    public FixedValueMapSerializer(Fory fory) {\n        // Disable codegen since we're handling serialization directly\n        super(fory, FixedValueMap.class, false);\n    }\n\n    @Override\n    public void write(MemoryBuffer buffer, FixedValueMap value) {\n        // Write the fixed value\n        buffer.writeInt32(value.getFixedValue());\n        // Write the number of keys\n        buffer.writeVarUint32Small7(value.getKeys().size());\n        // Write each key\n        for (String key : value.getKeys()) {\n            buffer.writeString(key);\n        }\n    }\n\n    @Override\n    public FixedValueMap read(MemoryBuffer buffer) {\n        // Read the fixed value\n        int fixedValue = buffer.readInt32();\n        // Read the number of keys\n        int size = buffer.readVarUint32Small7();\n        Set<String> keys = new HashSet<>(size);\n        for (int i = 0; i < size; i++) {\n            keys.add(buffer.readString());\n        }\n        return new FixedValueMap(keys, fixedValue);\n    }\n\n    // These methods are not used when supportCodegenHook is false\n    @Override\n    public Map onMapWrite(MemoryBuffer buffer, FixedValueMap value) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public FixedValueMap onMapRead(Map map) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public FixedValueMap onMapCopy(Map map) {\n        throw new UnsupportedOperationException();\n    }\n}\n```\n\nKey Points:\n\n1. **Disable Codegen**:\n   - Set `supportCodegenHook=false` in constructor\n   - Fory will use your `write`/`read` methods directly\n   - No JIT optimization will be applied\n   - Full control over serialization format\n\n2. **Write Method**:\n   - Handle all serialization manually\n   - Write custom fields first\n   - Write map entries in your preferred format\n   - Control the exact binary layout\n\n3. **Read Method**:\n   - Handle all deserialization manually\n   - Read in same order as written\n   - Create and populate map instance\n   - Restore custom fields\n\n4. **Unused Methods**:\n   - `onMapWrite`, `onMapRead`, `onMapCopy` are not used\n   - Can throw `UnsupportedOperationException`\n   - Only `write` and `read` are important\n\nWhen to Use: this approach is best when\n\n- Map has custom fields or metadata\n- Special serialization format is needed\n- Complete control over binary format is required\n- Standard map patterns don't fit\n\nTrade-offs\n\n1. **Advantages**:\n   - Complete control over serialization\n   - Custom binary format possible\n   - Simpler implementation for special cases\n   - Direct handling of custom fields\n\n2. **Disadvantages**:\n   - No JIT optimization\n   - Potentially lower performance\n   - Manual handling of all serialization\n   - More code to maintain\n\nRemember that disabling codegen means giving up some performance optimizations that Fory provides. Only use this approach when the standard map serialization pattern doesn't meet your needs.\n\n#### Implement Serializer for Map-like Types\n\nSometimes you may want to implement a serializer for a type that behaves like a map but isn't a standard Java map. This section demonstrates how to implement a serializer for such types.\n\nThe key principles for map-like type serialization are:\n\n1. Extend `MapLikeSerializer` for custom collection-like types\n2. Enable JIT optimization with `supportCodegenHook`\n3. Provide efficient element access through views\n4. Maintain proper size tracking\n\nHere's a complete example:\n\n```java\n// It's better to make it to implements the java.util.Map interface, in this way we don't have to implement such serializers by ourself.\nclass CustomMapLike {\n    private final Object[] keyArray;\n    private final Object[] valueArray;\n    private final int size;\n\n    // Constructor for creating new instance\n    public CustomMapLike(int initialCapacity) {\n        this.keyArray = new Object[initialCapacity];\n        this.valueArray = new Object[initialCapacity];\n        this.size = 0;\n    }\n\n    // Constructor for wrapping existing arrays\n    public CustomMapLike(Object[] keyArray, Object[] valueArray, int size) {\n        this.keyArray = keyArray;\n        this.valueArray = valueArray;\n        this.size = size;\n    }\n\n    public Integer get(String key) {\n        for (int i = 0; i < size; i++) {\n            if (key.equals(keyArray[i])) {\n                return (Integer) valueArray[i];\n            }\n        }\n        return null;\n    }\n\n    public int size() {\n        return size;\n    }\n\n    public Object[] getKeyArray() {\n        return keyArray;\n    }\n\n    public Object[] getValueArray() {\n        return valueArray;\n    }\n}\n\nclass MapView extends AbstractMap<Object, Object> {\n    private final Object[] keyArray;\n    private final Object[] valueArray;\n    private final int size;\n    private int writeIndex;\n\n    // Constructor for serialization (wrapping existing CustomMapLike)\n    public MapView(CustomMapLike mapLike) {\n        this.size = mapLike.size();\n        this.keyArray = mapLike.getKeyArray();\n        this.valueArray = mapLike.getValueArray();\n    }\n\n    // Constructor for deserialization\n    public MapView(int size) {\n        this.size = size;\n        this.keyArray = new Object[size];\n        this.valueArray = new Object[size];\n    }\n\n    @Override\n    public Set<Entry<Object, Object>> entrySet() {\n        return new AbstractSet<Entry<Object, Object>>() {\n            @Override\n            public Iterator<Entry<Object, Object>> iterator() {\n                return new Iterator<Entry<Object, Object>>() {\n                    private int index = 0;\n\n                    @Override\n                    public boolean hasNext() {\n                        return index < size;\n                    }\n\n                    @Override\n                    public Entry<Object, Object> next() {\n                        if (!hasNext()) {\n                            throw new NoSuchElementException();\n                        }\n                        final int currentIndex = index++;\n                        return new SimpleEntry<>(\n                            keyArray[currentIndex],\n                            valueArray[currentIndex]\n                        );\n                    }\n                };\n            }\n\n            @Override\n            public int size() {\n                return size;\n            }\n        };\n    }\n\n    @Override\n    public Object put(Object key, Object value) {\n        if (writeIndex >= size) {\n            throw new IllegalStateException(\"Map is full\");\n        }\n        keyArray[writeIndex] = key;\n        valueArray[writeIndex] = value;\n        writeIndex++;\n        return null;\n    }\n\n    public Object[] getKeyArray() {\n        return keyArray;\n    }\n\n    public Object[] getValueArray() {\n        return valueArray;\n    }\n\n    public int size() {\n        return size;\n    }\n}\n\nclass CustomMapLikeSerializer extends MapLikeSerializer<CustomMapLike> {\n    public CustomMapLikeSerializer(Fory fory) {\n        super(fory, CustomMapLike.class, true);\n    }\n\n    @Override\n    public Map onMapWrite(MemoryBuffer buffer, CustomMapLike value) {\n        buffer.writeVarUint32Small7(value.size());\n        // Return a zero-copy view using the same underlying arrays\n        return new MapView(value);\n    }\n\n    @Override\n    public Map newMap(MemoryBuffer buffer) {\n        int numElements = buffer.readVarUint32Small7();\n        setNumElements(numElements);\n        // Create a view with new arrays for deserialization\n        return new MapView(numElements);\n    }\n\n    @Override\n    public CustomMapLike onMapRead(Map map) {\n        MapView view = (MapView) map;\n        // Just pass the arrays directly - no copying needed\n        return new CustomMapLike(view.getKeyArray(), view.getValueArray(), view.size());\n    }\n\n    @Override\n    public CustomMapLike onMapCopy(Map map) {\n        MapView view = (MapView) map;\n        // Just pass the arrays directly - no copying needed\n        return new CustomMapLike(view.getKeyArray(), view.getValueArray(), view.size());\n    }\n}\n```\n\n### Register Custom Serializers\n\nAfter implementing your custom serializer, register it with Fory:\n\n```java\nFory fory = Fory.builder()\n    .withLanguage(Language.JAVA)\n    .build();\n\n// Register map serializer\nfory.registerSerializer(CustomMap.class, new CustomMapSerializer<>(fory, CustomMap.class));\n\n// Register collection serializer\nfory.registerSerializer(CustomCollection.class, new CustomCollectionSerializer<>(fory, CustomCollection.class));\n```\n\nNote that when implementing custom map or collection serializers:\n\n1. Always extend the appropriate base class (`MapSerializer`/`MapLikeSerializer` for maps, `CollectionSerializer`/`CollectionLikeSerializer` for collections)\n2. Consider the impact of `supportCodegenHook` on performance and functionality\n3. Properly handle reference tracking if needed\n4. Implement proper size management using `setNumElements` and `getAndClearNumElements` when `supportCodegenHook` is `true`\n\nBesides registering serializes, one can also implement `java.io.Externalizable` for a class to customize serialization logic, such type will be serialized by fory `ExternalizableSerializer`.\n\n### Memory Allocation Customization\n\nFory provides a `MemoryAllocator` interface that allows you to customize how memory buffers are allocated and grown during serialization operations. This can be useful for performance optimization, memory pooling, or debugging memory usage.\n\n#### MemoryAllocator Interface\n\nThe `MemoryAllocator` interface defines two key methods:\n\n```java\npublic interface MemoryAllocator {\n  /**\n   * Allocates a new MemoryBuffer with the specified initial capacity.\n   */\n  MemoryBuffer allocate(int initialCapacity);\n\n  /**\n   * Grows an existing buffer to accommodate the new capacity.\n   * The implementation must grow the buffer in-place by modifying\n   * the existing buffer instance.\n   */\n  MemoryBuffer grow(MemoryBuffer buffer, int newCapacity);\n}\n```\n\n#### Using Custom Memory Allocators\n\nYou can set a global memory allocator that will be used by all `MemoryBuffer` instances:\n\n```java\n// Create a custom allocator\nMemoryAllocator customAllocator = new MemoryAllocator() {\n  @Override\n  public MemoryBuffer allocate(int initialCapacity) {\n    // Add extra capacity for debugging or pooling\n    return MemoryBuffer.fromByteArray(new byte[initialCapacity + 100]);\n  }\n\n  @Override\n  public MemoryBuffer grow(MemoryBuffer buffer, int newCapacity) {\n    if (newCapacity <= buffer.size()) {\n      return buffer;\n    }\n\n    // Custom growth strategy - add 100% extra capacity\n    int newSize = (int) (newCapacity * 2);\n    byte[] data = new byte[newSize];\n    buffer.copyToUnsafe(0, data, Platform.BYTE_ARRAY_OFFSET, buffer.size());\n    buffer.initHeapBuffer(data, 0, data.length);\n    return buffer;\n  }\n};\n\n// Set the custom allocator globally\nMemoryBuffer.setGlobalAllocator(customAllocator);\n\n// All subsequent MemoryBuffer allocations will use your custom allocator\nFory fory = Fory.builder().withLanguage(Language.JAVA).build();\nbyte[] bytes = fory.serialize(someObject); // Uses custom allocator\n```\n\n#### Default Memory Allocator Behavior\n\nThe default allocator uses the following growth strategy:\n\n- For buffers smaller than `BUFFER_GROW_STEP_THRESHOLD` (100MB): multiply capacity by 2\n- For larger buffers: multiply capacity by 1.5 (capped at `Integer.MAX_VALUE - 8`)\n\nThis provides a balance between avoiding frequent reallocations and preventing excessive memory usage.\n\n#### Use Cases\n\nCustom memory allocators are useful for:\n\n- **Memory Pooling**: Reuse allocated buffers to reduce GC pressure\n- **Performance Tuning**: Use different growth strategies based on your workload\n- **Debugging**: Add logging or tracking to monitor memory usage\n- **Off-heap Memory**: Integrate with off-heap memory management systems\n\n### Security\n\n#### Class Registration\n\n`ForyBuilder#requireClassRegistration` can be used to disable class registration, this will allow to deserialize objects\nunknown types,\nmore flexible but **may be insecure if the classes contains malicious code**.\n\n**Do not disable class registration unless you can ensure your environment is secure**.\nMalicious code in `init/equals/hashCode` can be executed when deserializing unknown/untrusted types when this option\ndisabled.\n\nClass registration can not only reduce security risks, but also avoid classname serialization cost.\n\nYou can register class with API `Fory#register`.\n\nNote that class registration order is important, serialization and deserialization peer\nshould have same registration order.\n\n```java\nFory fory = xxx;\nfory.register(SomeClass.class);\nfory.register(SomeClass1.class, 200);\n```\n\nIf you invoke `ForyBuilder#requireClassRegistration(false)` to disable class registration check,\nyou can set `org.apache.fory.resolver.ClassChecker` by `ClassResolver#setClassChecker` to control which classes are\nallowed\nfor serialization. For example, you can allow classes started with `org.example.*` by:\n\n```java\nFory fory = xxx;\nfory.getClassResolver().setClassChecker(\n  (classResolver, className) -> className.startsWith(\"org.example.\"));\n```\n\n```java\nAllowListChecker checker = new AllowListChecker(AllowListChecker.CheckLevel.STRICT);\nThreadSafeFory fory = new ThreadLocalFory(classLoader -> {\n  Fory f = Fory.builder().requireClassRegistration(true).withClassLoader(classLoader).build();\n  f.getClassResolver().setClassChecker(checker);\n  checker.addListener(f.getClassResolver());\n  return f;\n});\nchecker.allowClass(\"org.example.*\");\n```\n\nFory also provided a `org.apache.fory.resolver.AllowListChecker` which is allowed/disallowed list based checker to\nsimplify\nthe customization of class check mechanism. You can use this checker or implement more sophisticated checker by\nyourself.\n\n#### Limit max deserization depth\n\nFory also provides a `ForyBuilder#withMaxDepth` to limit max deserialization depth. The default max depth is 50.\n\nIf max depth is reached, Fory will throw `ForyException`. This can be used to prevent malicious data from causing stack overflow or other issues.\n\n### Register class by name\n\nRegister class by id will have better performance and smaller space overhead. But in some cases, management for a bunch\nof type id is complex. In such cases, registering class by name using API\n`register(Class<?> cls, String namespace, String typeName)` is recommended.\n\n```java\nfory.register(Foo.class, \"demo\", \"Foo\");\n```\n\nIf there are no duplicate name for type, `namespace` can be left as empty to reduce serialized size.\n\n**Do not use this API to register class since it will increase serialized size a lot compared to register\nclass by id**\n\n### Zero-Copy Serialization\n\n```java\nimport org.apache.fory.*;\nimport org.apache.fory.config.*;\nimport org.apache.fory.serializer.BufferObject;\nimport org.apache.fory.memory.MemoryBuffer;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class ZeroCopyExample {\n  // Note that fory instance should be reused instead of creation every time.\n  static Fory fory = Fory.builder()\n    .withLanguage(Language.JAVA)\n    .build();\n\n  // mvn exec:java -Dexec.mainClass=\"io.ray.fory.examples.ZeroCopyExample\"\n  public static void main(String[] args) {\n    List<Object> list = Arrays.asList(\"str\", new byte[1000], new int[100], new double[100]);\n    Collection<BufferObject> bufferObjects = new ArrayList<>();\n    byte[] bytes = fory.serialize(list, e -> !bufferObjects.add(e));\n    List<MemoryBuffer> buffers = bufferObjects.stream()\n      .map(BufferObject::toBuffer).collect(Collectors.toList());\n    System.out.println(fory.deserialize(bytes, buffers));\n  }\n}\n```\n\n### Meta Sharing\n\nFory supports share type metadata (class name, field name, final field type information, etc.) between multiple\nserializations in a context (ex. TCP connection), and this information will be sent to the peer during the first\nserialization in the context. Based on this metadata, the peer can rebuild the same deserializer, which avoids\ntransmitting metadata for subsequent serializations and reduces network traffic pressure and supports type\nforward/backward compatibility automatically.\n\n```java\n// Fory.builder()\n//   .withLanguage(Language.JAVA)\n//   .withRefTracking(false)\n//   // share meta across serialization.\n//   .withMetaContextShare(true)\n// Not thread-safe fory.\nMetaContext context = xxx;\nfory.getSerializationContext().setMetaContext(context);\nbyte[] bytes = fory.serialize(o);\n// Not thread-safe fory.\nMetaContext context = xxx;\nfory.getSerializationContext().setMetaContext(context);\nfory.deserialize(bytes);\n\n// Thread-safe fory\nfory.setClassLoader(beanA.getClass().getClassLoader());\nbyte[] serialized = fory.execute(\n  f -> {\n    f.getSerializationContext().setMetaContext(context);\n    return f.serialize(beanA);\n  }\n);\n// thread-safe fory\nfory.setClassLoader(beanA.getClass().getClassLoader());\nObject newObj = fory.execute(\n  f -> {\n    f.getSerializationContext().setMetaContext(context);\n    return f.deserialize(serialized);\n  }\n);\n```\n\nNote that `MetaContext` is not thread-safe and cannot be reused across instances of fory or multiple threads.\nIn cases of multi-threading, a separate `MetaContext` must be created for each fory instance.\n\n### Deserialize non-existent classes\n\nFory support deserializing non-existent classes, this feature can be enabled\nby `ForyBuilder#deserializeNonexistentClass(true)`. When enabled, and metadata sharing enabled, Fory will store\nthe deserialized data of this type in a lazy subclass of Map. By using the lazy map implemented by Fory, the rebalance\ncost of filling map during deserialization can be avoided, which further improves performance. If this data is sent to\nanother process and the class exists in this process, the data will be deserialized into the object of this type without\nlosing any information.\n\nIf metadata sharing is not enabled, the new class data will be skipped and an `NonexistentSkipClass` stub object will be\nreturned.\n\n### Copy/Map object from one type to another type\n\nFory support mapping object from one type to another type.\n\n> Notes:\n>\n> 1. This mapping will execute a deep copy, all mapped fields are serialized into binary and\n>    deserialized from that binary to map into another type.\n> 2. All struct types must be registered with same ID, otherwise Fory can not mapping to correct struct type.\n>    Be careful when you use `Fory#register(Class)`, because fory will allocate an auto-grown ID which might be\n>    inconsistent if you register classes with different order between Fory instance.\n\n```java\npublic class StructMappingExample {\n  static class Struct1 {\n    int f1;\n    String f2;\n\n    public Struct1(int f1, String f2) {\n      this.f1 = f1;\n      this.f2 = f2;\n    }\n  }\n\n  static class Struct2 {\n    int f1;\n    String f2;\n    double f3;\n  }\n\n  static ThreadSafeFory fory1 = Fory.builder()\n    .withCompatibleMode(CompatibleMode.COMPATIBLE).buildThreadSafeFory();\n  static ThreadSafeFory fory2 = Fory.builder()\n    .withCompatibleMode(CompatibleMode.COMPATIBLE).buildThreadSafeFory();\n\n  static {\n    fory1.register(Struct1.class);\n    fory2.register(Struct2.class);\n  }\n\n  public static void main(String[] args) {\n    Struct1 struct1 = new Struct1(10, \"abc\");\n    Struct2 struct2 = (Struct2) fory2.deserialize(fory1.serialize(struct1));\n    Assert.assertEquals(struct2.f1, struct1.f1);\n    Assert.assertEquals(struct2.f2, struct1.f2);\n    struct1 = (Struct1) fory1.deserialize(fory2.serialize(struct2));\n    Assert.assertEquals(struct1.f1, struct2.f1);\n    Assert.assertEquals(struct1.f2, struct2.f2);\n  }\n}\n```\n\n## Migration\n\n### JDK migration\n\nIf you use jdk serialization before, and you can't upgrade your client and server at the same time, which is common for\nonline application. Fory provided an util method `org.apache.fory.serializer.JavaSerializer.serializedByJDK` to check\nwhether\nthe binary are generated by jdk serialization, you use following pattern to make exiting serialization protocol-aware,\nthen upgrade serialization to fory in an async rolling-up way:\n\n```java\nif (JavaSerializer.serializedByJDK(bytes)) {\n  ObjectInputStream objectInputStream=xxx;\n  return objectInputStream.readObject();\n} else {\n  return fory.deserialize(bytes);\n}\n```\n\n### Upgrade fory\n\nCurrently binary compatibility is ensured for minor versions only. For example, if you are using fory`v0.2.0`, binary\ncompatibility will\nbe provided if you upgrade to fory `v0.2.1`. But if upgrade to fory `v0.4.1`, no binary compatibility are ensured.\nMost of the time there is no need to upgrade fory to newer major version, the current version is fast and compact\nenough,\nand we provide some minor fix for recent older versions.\n\nBut if you do want to upgrade fory for better performance and smaller size, you need to write fory version as header to\nserialized data\nusing code like following to keep binary compatibility:\n\n```java\nMemoryBuffer buffer = xxx;\nbuffer.writeVarInt32(2);\nfory.serialize(buffer, obj);\n```\n\nThen for deserialization, you need:\n\n```java\nMemoryBuffer buffer = xxx;\nint foryVersion = buffer.readVarInt32();\nFory fory = getFory(foryVersion);\nfory.deserialize(buffer);\n```\n\n`getFory` is a method to load corresponding fory, you can shade and relocate different version of fory to different\npackage, and load fory by version.\n\nIf you upgrade fory by minor version, or you won't have data serialized by older fory, you can upgrade fory directly,\nno need to `versioning` the data.\n\n## Trouble shooting\n\n### Class inconsistency and class version check\n\nIf you create fory without setting `CompatibleMode` to `org.apache.fory.config.CompatibleMode.COMPATIBLE`, and you got a\nstrange\nserialization error, it may be caused by class inconsistency between serialization peer and deserialization peer.\n\nIn such cases, you can invoke `ForyBuilder#withClassVersionCheck` to create fory to validate it, if deserialization\nthrows `org.apache.fory.exception.ClassNotCompatibleException`, it shows class are inconsistent, and you should create\nfory with\n`ForyBuilder#withCompaibleMode(CompatibleMode.COMPATIBLE)`.\n\n`CompatibleMode.COMPATIBLE` has more performance and space cost, do not set it by default if your classes are always\nconsistent between serialization and deserialization.\n\n### Deserialize POJO into another type\n\nFory allows you to serialize one POJO and deserialize it into a different POJO. The different POJO means the schema inconsistency. Users must to configure Fory with\n`CompatibleMode` set to `org.apache.fory.config.CompatibleMode.COMPATIBLE`.\n\n```java\npublic class DeserializeIntoType {\n  static class Struct1 {\n    int f1;\n    String f2;\n\n    public Struct1(int f1, String f2) {\n      this.f1 = f1;\n      this.f2 = f2;\n    }\n  }\n\n  static class Struct2 {\n    int f1;\n    String f2;\n    double f3;\n  }\n\n  static ThreadSafeFory fory = Fory.builder()\n    .withCompatibleMode(CompatibleMode.COMPATIBLE).buildThreadSafeFory();\n\n  public static void main(String[] args) {\n    Struct1 struct1 = new Struct1(10, \"abc\");\n    byte[] data = fory.serializeJavaObject(struct1);\n    Struct2 struct2 = (Struct2) fory.deserializeJavaObject(bytes, Struct2.class);\n  }\n}\n```\n\n### Use wrong API for deserialization\n\nIf you serialize an object by invoking `Fory#serialize`, you should invoke `Fory#deserialize` for deserialization\ninstead of\n`Fory#deserializeJavaObject`.\n\nIf you serialize an object by invoking `Fory#serializeJavaObject`, you should invoke `Fory#deserializeJavaObject` for\ndeserialization instead of `Fory#deserializeJavaObjectAndClass`/`Fory#deserialize`.\n\nIf you serialize an object by invoking `Fory#serializeJavaObjectAndClass`, you should\ninvoke `Fory#deserializeJavaObjectAndClass` for deserialization instead\nof `Fory#deserializeJavaObject`/`Fory#deserialize`.\n"})})]})}function u(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>o,a:()=>s});var r=i(67294);const t={},a=r.createContext(t);function s(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);