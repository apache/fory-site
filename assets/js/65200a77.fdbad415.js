"use strict";(self.webpackChunkfory_site=self.webpackChunkfory_site||[]).push([[26112],{88781:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>t,contentTitle:()=>l,default:()=>h,frontMatter:()=>d,metadata:()=>c,toc:()=>o});var r=i(85893),s=i(11151);const d={title:"Field Configuration",sidebar_position:5,id:"field_configuration",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},l=void 0,c={id:"guide/rust/field_configuration",title:"Field Configuration",description:"This page explains how to configure field-level metadata for serialization in Rust.",source:"@site/versioned_docs/version-0.15/guide/rust/field-configuration.md",sourceDirName:"guide/rust",slug:"/guide/rust/field_configuration",permalink:"/docs/guide/rust/field_configuration",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/fory-site/tree/main/docs/guide/rust/field-configuration.md",tags:[],version:"0.15",sidebarPosition:5,frontMatter:{title:"Field Configuration",sidebar_position:5,id:"field_configuration",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},sidebar:"docsSidebar",previous:{title:"Custom Serializers",permalink:"/docs/guide/rust/custom_serializers"},next:{title:"Shared & Circular References",permalink:"/docs/guide/rust/references"}},t={},o=[{value:"Overview",id:"overview",level:2},{value:"Basic Syntax",id:"basic-syntax",level:2},{value:"Available Options",id:"available-options",level:2},{value:"Field ID (<code>id = N</code>)",id:"field-id-id--n",level:3},{value:"Skipping Fields (<code>skip</code>)",id:"skipping-fields-skip",level:3},{value:"Nullable (<code>nullable</code>)",id:"nullable-nullable",level:3},{value:"Reference Tracking (<code>ref</code>)",id:"reference-tracking-ref",level:3},{value:"Encoding (<code>encoding</code>)",id:"encoding-encoding",level:3},{value:"Compress (<code>compress</code>)",id:"compress-compress",level:3},{value:"Type Classification",id:"type-classification",level:2},{value:"Complete Example",id:"complete-example",level:2},{value:"Compile-Time Validation",id:"compile-time-validation",level:2},{value:"Cross-Language Compatibility",id:"cross-language-compatibility",level:2},{value:"Schema Evolution",id:"schema-evolution",level:2},{value:"Default Values",id:"default-values",level:2},{value:"Default Values Summary",id:"default-values-summary",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Options Reference",id:"options-reference",level:2},{value:"Related Topics",id:"related-topics",level:2}];function a(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"This page explains how to configure field-level metadata for serialization in Rust."}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(n.p,{children:["Apache Fory\u2122 provides the ",(0,r.jsx)(n.code,{children:"#[fory(...)]"})," attribute macro to specify optional field-level metadata at compile time. This enables:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tag IDs"}),": Assign compact numeric IDs to minimize struct field meta size overhead"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Nullability"}),": Control whether fields can be null"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reference Tracking"}),": Enable reference tracking for shared ownership types"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Field Skipping"}),": Exclude fields from serialization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Encoding Control"}),": Specify how integers are encoded (varint, fixed, tagged)"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"basic-syntax",children:"Basic Syntax"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"#[fory(...)]"})," attribute is placed on individual struct fields:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use fory::ForyObject;\n\n#[derive(ForyObject)]\nstruct Person {\n    #[fory(id = 0)]\n    name: String,\n\n    #[fory(id = 1)]\n    age: i32,\n\n    #[fory(id = 2, nullable)]\n    nickname: Option<String>,\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Multiple options are separated by commas."}),"\n",(0,r.jsx)(n.h2,{id:"available-options",children:"Available Options"}),"\n",(0,r.jsxs)(n.h3,{id:"field-id-id--n",children:["Field ID (",(0,r.jsx)(n.code,{children:"id = N"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"Assigns a numeric ID to a field to minimize struct field meta size overhead:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[derive(ForyObject)]\nstruct User {\n    #[fory(id = 0)]\n    id: i64,\n\n    #[fory(id = 1)]\n    name: String,\n\n    #[fory(id = 2)]\n    age: i32,\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Smaller serialized size (numeric IDs vs field names in metadata)"}),"\n",(0,r.jsx)(n.li,{children:"Allows renaming fields without breaking binary compatibility"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Recommendation"}),": It is recommended to configure field IDs for compatible mode since it reduces serialization cost."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Notes"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"IDs must be unique within a struct"}),"\n",(0,r.jsx)(n.li,{children:"IDs must be >= 0 (use -1 to explicitly opt-out of tag ID encoding)"}),"\n",(0,r.jsx)(n.li,{children:"If not specified, field name is used in metadata (larger overhead)"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"skipping-fields-skip",children:["Skipping Fields (",(0,r.jsx)(n.code,{children:"skip"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"Excludes a field from serialization:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[derive(ForyObject)]\nstruct User {\n    #[fory(id = 0)]\n    id: i64,\n\n    #[fory(id = 1)]\n    name: String,\n\n    #[fory(skip)]\n    password: String, // Not serialized\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"password"})," field will not be included in serialized output and will remain at its default value after deserialization."]}),"\n",(0,r.jsxs)(n.h3,{id:"nullable-nullable",children:["Nullable (",(0,r.jsx)(n.code,{children:"nullable"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"Controls whether null flags are written for fields:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use fory::{Fory, RcWeak};\n\n#[derive(ForyObject)]\nstruct Record {\n    // RcWeak is nullable by default, override to non-nullable\n    #[fory(id = 0, nullable = false)]\n    required_ref: RcWeak<Data>,\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Default Behavior"}),":"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Default Nullable"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Option<T>"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"RcWeak<T>"}),", ",(0,r.jsx)(n.code,{children:"ArcWeak<T>"})]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"All other types"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"false"})})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Notes"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["For ",(0,r.jsx)(n.code,{children:"Option<T>"}),", ",(0,r.jsx)(n.code,{children:"RcWeak<T>"}),", ",(0,r.jsx)(n.code,{children:"ArcWeak<T>"}),", nullable defaults to true"]}),"\n",(0,r.jsx)(n.li,{children:"For all other types, nullable defaults to false"}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"nullable = false"})," to override defaults for types that are nullable by default"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"reference-tracking-ref",children:["Reference Tracking (",(0,r.jsx)(n.code,{children:"ref"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"Controls per-field reference tracking for shared ownership types:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use std::rc::Rc;\nuse std::sync::Arc;\n\n#[derive(ForyObject)]\nstruct Container {\n    // Enable reference tracking (default for Rc/Arc)\n    #[fory(id = 0, ref = true)]\n    shared_data: Rc<Data>,\n\n    // Disable reference tracking\n    #[fory(id = 1, ref = false)]\n    unique_data: Rc<Data>,\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Default Behavior"}),":"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Default Ref Tracking"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"Rc<T>"}),", ",(0,r.jsx)(n.code,{children:"Arc<T>"})]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"RcWeak<T>"}),", ",(0,r.jsx)(n.code,{children:"ArcWeak<T>"})]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"Option<Rc<T>>"}),", ",(0,r.jsx)(n.code,{children:"Option<Arc<T>>"})]}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"true"})," (inherited)"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"All other types"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"false"})})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Cases"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Enable for fields that may be circular or shared"}),"\n",(0,r.jsx)(n.li,{children:"Disable for fields that are always unique (optimization)"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"encoding-encoding",children:["Encoding (",(0,r.jsx)(n.code,{children:"encoding"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"Controls how integer fields are encoded:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[derive(ForyObject)]\nstruct Metrics {\n    // Variable-length encoding (smaller for small values)\n    #[fory(id = 0, encoding = "varint")]\n    count: i64,\n\n    // Fixed-length encoding (consistent size)\n    #[fory(id = 1, encoding = "fixed")]\n    timestamp: i64,\n\n    // Tagged encoding (includes type tag, u64 only)\n    #[fory(id = 2, encoding = "tagged")]\n    value: u64,\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Supported Encodings"}),":"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Options"}),(0,r.jsx)(n.th,{children:"Default"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"i32"}),", ",(0,r.jsx)(n.code,{children:"u32"})]}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"varint"}),", ",(0,r.jsx)(n.code,{children:"fixed"})]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"varint"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"i64"}),", ",(0,r.jsx)(n.code,{children:"u64"})]}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"varint"}),", ",(0,r.jsx)(n.code,{children:"fixed"}),", ",(0,r.jsx)(n.code,{children:"tagged"})]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"varint"})})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"When to Use"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"varint"}),": Best for values that are often small (default)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fixed"}),": Best for values that use full range (e.g., timestamps, hashes)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"tagged"}),": When type information needs to be preserved (u64 only)"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"compress-compress",children:["Compress (",(0,r.jsx)(n.code,{children:"compress"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"A convenience shorthand for controlling integer encoding:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[derive(ForyObject)]\nstruct Data {\n    // compress = true -> varint encoding (default)\n    #[fory(id = 0, compress)]\n    small_value: i32,\n\n    // compress = false -> fixed encoding\n    #[fory(id = 1, compress = false)]\n    fixed_value: u32,\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Notes"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"compress"})," or ",(0,r.jsx)(n.code,{children:"compress = true"})," is equivalent to ",(0,r.jsx)(n.code,{children:'encoding = "varint"'})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"compress = false"})," is equivalent to ",(0,r.jsx)(n.code,{children:'encoding = "fixed"'})]}),"\n",(0,r.jsxs)(n.li,{children:["If both ",(0,r.jsx)(n.code,{children:"compress"})," and ",(0,r.jsx)(n.code,{children:"encoding"})," are specified, they must not conflict"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"type-classification",children:"Type Classification"}),"\n",(0,r.jsx)(n.p,{children:"Fory classifies field types to determine default behavior:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Type Class"}),(0,r.jsx)(n.th,{children:"Examples"}),(0,r.jsx)(n.th,{children:"Default Nullable"}),(0,r.jsx)(n.th,{children:"Default Ref"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Primitive"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"i8"}),", ",(0,r.jsx)(n.code,{children:"i32"}),", ",(0,r.jsx)(n.code,{children:"f64"}),", ",(0,r.jsx)(n.code,{children:"bool"})]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"false"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"false"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Option"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Option<T>"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"false"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Rc"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Rc<T>"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"false"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Arc"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Arc<T>"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"false"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"RcWeak"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"RcWeak<T>"})," (fory type)"]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"ArcWeak"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"ArcWeak<T>"})," (fory type)"]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Other"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"String"}),", ",(0,r.jsx)(n.code,{children:"Vec<T>"}),", user types"]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"false"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"false"})})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Special Case"}),": ",(0,r.jsx)(n.code,{children:"Option<Rc<T>>"})," and ",(0,r.jsx)(n.code,{children:"Option<Arc<T>>"})," inherit the inner type's ref tracking behavior."]}),"\n",(0,r.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use fory::ForyObject;\nuse std::rc::Rc;\n\n#[derive(ForyObject, Default)]\nstruct Document {\n    // Required fields with tag IDs\n    #[fory(id = 0)]\n    title: String,\n\n    #[fory(id = 1)]\n    version: i32,\n\n    // Optional field (nullable by default for Option)\n    #[fory(id = 2)]\n    description: Option<String>,\n\n    // Reference-tracked shared pointer\n    #[fory(id = 3)]\n    parent: Rc<Document>,\n\n    // Nullable + reference-tracked\n    #[fory(id = 4, nullable)]\n    related: Option<Rc<Document>>,\n\n    // Counter with varint encoding (small values)\n    #[fory(id = 5, encoding = "varint")]\n    view_count: u64,\n\n    // Timestamp with fixed encoding (full range values)\n    #[fory(id = 6, encoding = "fixed")]\n    created_at: i64,\n\n    // Skip sensitive field\n    #[fory(skip)]\n    internal_state: String,\n}\n\nfn main() {\n    let fory = fory::Fory::default();\n\n    let doc = Document {\n        title: "My Document".to_string(),\n        version: 1,\n        description: Some("A sample document".to_string()),\n        parent: Rc::new(Document::default()),\n        related: None, // Allowed because nullable\n        view_count: 42,\n        created_at: 1704067200,\n        internal_state: "secret".to_string(), // Will be skipped\n    };\n\n    let bytes = fory.serialize(&doc);\n    let decoded: Document = fory.deserialize(&bytes).unwrap();\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"compile-time-validation",children:"Compile-Time Validation"}),"\n",(0,r.jsx)(n.p,{children:"Invalid configurations are caught at compile time:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// Error: duplicate field IDs\n#[derive(ForyObject)]\nstruct Bad {\n    #[fory(id = 0)]\n    field1: String,\n\n    #[fory(id = 0)]  // Compile error: duplicate id\n    field2: String,\n}\n\n// Error: invalid id value\n#[derive(ForyObject)]\nstruct Bad2 {\n    #[fory(id = -2)]  // Compile error: id must be >= -1\n    field: String,\n}\n\n// Error: conflicting encoding attributes\n#[derive(ForyObject)]\nstruct Bad3 {\n    #[fory(compress = true, encoding = "fixed")]  // Compile error: conflict\n    field: i32,\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"cross-language-compatibility",children:"Cross-Language Compatibility"}),"\n",(0,r.jsx)(n.p,{children:"When serializing data to be read by other languages (Java, C++, Go, Python), use field configuration to match encoding expectations:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[derive(ForyObject)]\nstruct CrossLangData {\n    // Matches Java Integer with varint\n    #[fory(id = 0, encoding = "varint")]\n    int_var: i32,\n\n    // Matches Java Integer with fixed\n    #[fory(id = 1, encoding = "fixed")]\n    int_fixed: i32,\n\n    // Matches Java Long with tagged encoding\n    #[fory(id = 2, encoding = "tagged")]\n    long_tagged: u64,\n\n    // Nullable pointer matches Java nullable reference\n    #[fory(id = 3, nullable)]\n    optional: Option<String>,\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"schema-evolution",children:"Schema Evolution"}),"\n",(0,r.jsx)(n.p,{children:"Compatible mode supports schema evolution. It is recommended to configure field IDs to reduce serialization cost:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// Version 1\n#[derive(ForyObject)]\nstruct DataV1 {\n    #[fory(id = 0)]\n    id: i64,\n\n    #[fory(id = 1)]\n    name: String,\n}\n\n// Version 2: Added new field\n#[derive(ForyObject)]\nstruct DataV2 {\n    #[fory(id = 0)]\n    id: i64,\n\n    #[fory(id = 1)]\n    name: String,\n\n    #[fory(id = 2)]\n    email: Option<String>,  // New nullable field\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Data serialized with V1 can be deserialized with V2 (new field will be ",(0,r.jsx)(n.code,{children:"None"}),")."]}),"\n",(0,r.jsx)(n.p,{children:"Alternatively, field IDs can be omitted (field names will be used in metadata with larger overhead):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[derive(ForyObject)]\nstruct Data {\n    id: i64,\n    name: String,\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"default-values",children:"Default Values"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Nullable"}),": ",(0,r.jsx)(n.code,{children:"Option<T>"}),", ",(0,r.jsx)(n.code,{children:"RcWeak<T>"}),", and ",(0,r.jsx)(n.code,{children:"ArcWeak<T>"})," are nullable by default; all other types are non-nullable"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Ref tracking"}),": ",(0,r.jsx)(n.code,{children:"Rc<T>"}),", ",(0,r.jsx)(n.code,{children:"Arc<T>"}),", ",(0,r.jsx)(n.code,{children:"RcWeak<T>"}),", and ",(0,r.jsx)(n.code,{children:"ArcWeak<T>"})," enable ref tracking by default; all other types are disabled"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["You ",(0,r.jsx)(n.strong,{children:"need to configure fields"})," when:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A field can be None (use ",(0,r.jsx)(n.code,{children:"Option<T>"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["A field needs reference tracking for shared/circular objects (use ",(0,r.jsx)(n.code,{children:"ref = true"}),")"]}),"\n",(0,r.jsx)(n.li,{children:"Integer types need specific encoding for cross-language compatibility"}),"\n",(0,r.jsx)(n.li,{children:"You want to reduce metadata size (use field IDs)"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// Xlang mode: explicit configuration required\n#[derive(ForyObject)]\nstruct User {\n    #[fory(id = 0)]\n    name: String,                    // Non-nullable by default\n\n    #[fory(id = 1)]\n    email: Option<String>,           // Nullable (Option<T>)\n\n    #[fory(id = 2, ref = true)]\n    friend: Rc<User>,                // Ref tracking (default for Rc)\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"default-values-summary",children:"Default Values Summary"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Default Nullable"}),(0,r.jsx)(n.th,{children:"Default Ref Tracking"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:["Primitives, ",(0,r.jsx)(n.code,{children:"String"})]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"false"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"false"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Option<T>"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"false"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"Rc<T>"}),", ",(0,r.jsx)(n.code,{children:"Arc<T>"})]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"false"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"RcWeak<T>"}),", ",(0,r.jsx)(n.code,{children:"ArcWeak<T>"})]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"true"})})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Configure field IDs"}),": Recommended for compatible mode to reduce serialization cost"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Use ",(0,r.jsx)(n.code,{children:"skip"})," for sensitive data"]}),": Passwords, tokens, internal state"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Enable ref tracking for shared objects"}),": When the same pointer appears multiple times"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Disable ref tracking for unique fields"}),": Optimization when you know the field is unique"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Choose appropriate encoding"}),": ",(0,r.jsx)(n.code,{children:"varint"})," for small values, ",(0,r.jsx)(n.code,{children:"fixed"})," for full-range values"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Keep IDs stable"}),": Once assigned, don't change field IDs"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"options-reference",children:"Options Reference"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Option"}),(0,r.jsx)(n.th,{children:"Syntax"}),(0,r.jsx)(n.th,{children:"Description"}),(0,r.jsx)(n.th,{children:"Valid For"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"id"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"id = N"})}),(0,r.jsx)(n.td,{children:"Field tag ID to reduce metadata size"}),(0,r.jsx)(n.td,{children:"All fields"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"skip"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"skip"})}),(0,r.jsx)(n.td,{children:"Exclude field from serialization"}),(0,r.jsx)(n.td,{children:"All fields"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"nullable"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"nullable"})," or ",(0,r.jsx)(n.code,{children:"nullable = bool"})]}),(0,r.jsx)(n.td,{children:"Control null flag writing"}),(0,r.jsx)(n.td,{children:"All fields"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"ref"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"ref"})," or ",(0,r.jsx)(n.code,{children:"ref = bool"})]}),(0,r.jsx)(n.td,{children:"Control reference tracking"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"Rc"}),", ",(0,r.jsx)(n.code,{children:"Arc"}),", weak types"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"encoding"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:'encoding = "varint/fixed/tagged"'})}),(0,r.jsx)(n.td,{children:"Integer encoding method"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"i32"}),", ",(0,r.jsx)(n.code,{children:"u32"}),", ",(0,r.jsx)(n.code,{children:"i64"}),", ",(0,r.jsx)(n.code,{children:"u64"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"compress"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"compress"})," or ",(0,r.jsx)(n.code,{children:"compress = bool"})]}),(0,r.jsx)(n.td,{children:"Shorthand for varint/fixed"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"i32"}),", ",(0,r.jsx)(n.code,{children:"u32"})]})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"basic_serialization",children:"Basic Serialization"})," - Getting started with Fory serialization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"schema_evolution",children:"Schema Evolution"})," - Compatible mode and schema evolution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"cross_language",children:"Cross-Language"})," - Interoperability with Java, C++, Go, Python"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>c,a:()=>l});var r=i(67294);const s={},d=r.createContext(s);function l(e){const n=r.useContext(d);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(d.Provider,{value:n},e.children)}}}]);