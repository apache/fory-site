"use strict";(self.webpackChunkfory_site=self.webpackChunkfory_site||[]).push([[79513],{59898:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>l,toc:()=>d});var i=r(85893),t=r(11151);const s={title:"Polymorphic Serialization",sidebar_position:5,id:"polymorphism",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},o=void 0,l={id:"guide/cpp/polymorphism",title:"Polymorphic Serialization",description:"Apache Fory\u2122 supports polymorphic serialization through smart pointers (std::uniqueptr), enabling dynamic dispatch and type flexibility for inheritance hierarchies.",source:"@site/versioned_docs/version-0.15/guide/cpp/polymorphism.md",sourceDirName:"guide/cpp",slug:"/guide/cpp/polymorphism",permalink:"/docs/guide/cpp/polymorphism",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/fory-site/tree/main/docs/guide/cpp/polymorphism.md",tags:[],version:"0.15",sidebarPosition:5,frontMatter:{title:"Polymorphic Serialization",sidebar_position:5,id:"polymorphism",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},sidebar:"docsSidebar",previous:{title:"Type Registration",permalink:"/docs/guide/cpp/type_registration"},next:{title:"Custom Serializers",permalink:"/docs/guide/cpp/custom_serializers"}},a={},d=[{value:"Supported Polymorphic Types",id:"supported-polymorphic-types",level:2},{value:"Basic Polymorphic Serialization",id:"basic-polymorphic-serialization",level:2},{value:"Type Registration for Polymorphism",id:"type-registration-for-polymorphism",level:2},{value:"Automatic Polymorphism Detection",id:"automatic-polymorphism-detection",level:2},{value:"Controlling Dynamic Dispatch",id:"controlling-dynamic-dispatch",level:2},{value:"Field Configuration Without Wrapper Types",id:"field-configuration-without-wrapper-types",level:3},{value:"std::unique_ptr Polymorphism",id:"stdunique_ptr-polymorphism",level:2},{value:"Collections of Polymorphic Objects",id:"collections-of-polymorphic-objects",level:2},{value:"Reference Tracking",id:"reference-tracking",level:2},{value:"Nested Polymorphism Depth Limit",id:"nested-polymorphism-depth-limit",level:2},{value:"Nullability for Polymorphic Fields",id:"nullability-for-polymorphic-fields",level:2},{value:"Combining Polymorphism with Other Features",id:"combining-polymorphism-with-other-features",level:2},{value:"Polymorphism + Reference Tracking",id:"polymorphism--reference-tracking",level:3},{value:"Polymorphism + Schema Evolution",id:"polymorphism--schema-evolution",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Related Topics",id:"related-topics",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Apache Fory\u2122 supports polymorphic serialization through smart pointers (",(0,i.jsx)(n.code,{children:"std::shared_ptr"})," and ",(0,i.jsx)(n.code,{children:"std::unique_ptr"}),"), enabling dynamic dispatch and type flexibility for inheritance hierarchies."]}),"\n",(0,i.jsx)(n.h2,{id:"supported-polymorphic-types",children:"Supported Polymorphic Types"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"std::shared_ptr<Base>"})," - Shared ownership with polymorphic dispatch"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"std::unique_ptr<Base>"})," - Exclusive ownership with polymorphic dispatch"]}),"\n",(0,i.jsxs)(n.li,{children:["Collections: ",(0,i.jsx)(n.code,{children:"std::vector<std::shared_ptr<Base>>"}),", ",(0,i.jsx)(n.code,{children:"std::map<K, std::unique_ptr<Base>>"})]}),"\n",(0,i.jsxs)(n.li,{children:["Optional: ",(0,i.jsx)(n.code,{children:"std::optional<std::shared_ptr<Base>>"})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"basic-polymorphic-serialization",children:"Basic Polymorphic Serialization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include "fory/serialization/fory.h"\n\nusing namespace fory::serialization;\n\n// Define base class with virtual methods\nstruct Animal {\n  virtual ~Animal() = default;\n  virtual std::string speak() const = 0;\n  int32_t age = 0;\n};\nFORY_STRUCT(Animal, age);\n\n// Define derived classes\nstruct Dog : Animal {\n  std::string speak() const override { return "Woof!"; }\n  std::string breed;\n};\nFORY_STRUCT(Dog, age, breed);\n\nstruct Cat : Animal {\n  std::string speak() const override { return "Meow!"; }\n  std::string color;\n};\nFORY_STRUCT(Cat, age, color);\n\n// Struct with polymorphic field\nstruct Zoo {\n  std::shared_ptr<Animal> star_animal;\n};\nFORY_STRUCT(Zoo, star_animal);\n\nint main() {\n  auto fory = Fory::builder().track_ref(true).build();\n\n  // Register all types with unique type IDs\n  fory.register_struct<Zoo>(100);\n  fory.register_struct<Dog>(101);\n  fory.register_struct<Cat>(102);\n\n  // Create object with polymorphic field\n  Zoo zoo;\n  zoo.star_animal = std::make_shared<Dog>();\n  zoo.star_animal->age = 3;\n  static_cast<Dog*>(zoo.star_animal.get())->breed = "Labrador";\n\n  // Serialize\n  auto bytes_result = fory.serialize(zoo);\n  assert(bytes_result.ok());\n\n  // Deserialize - runtime type is preserved\n  auto decoded_result = fory.deserialize<Zoo>(bytes_result.value());\n  assert(decoded_result.ok());\n\n  auto decoded = std::move(decoded_result).value();\n  assert(decoded.star_animal->speak() == "Woof!");\n  assert(decoded.star_animal->age == 3);\n\n  auto* dog_ptr = dynamic_cast<Dog*>(decoded.star_animal.get());\n  assert(dog_ptr != nullptr);\n  assert(dog_ptr->breed == "Labrador");\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"type-registration-for-polymorphism",children:"Type Registration for Polymorphism"}),"\n",(0,i.jsx)(n.p,{children:"For polymorphic serialization, register derived types with unique type IDs:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// Register with numeric type ID\nfory.register_struct<Derived1>(100);\nfory.register_struct<Derived2>(101);\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Why type ID registration?"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Compact binary representation"}),"\n",(0,i.jsx)(n.li,{children:"Fast type lookup and dispatch"}),"\n",(0,i.jsx)(n.li,{children:"Consistent with non-polymorphic type registration"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"automatic-polymorphism-detection",children:"Automatic Polymorphism Detection"}),"\n",(0,i.jsxs)(n.p,{children:["Fory automatically detects polymorphic types using ",(0,i.jsx)(n.code,{children:"std::is_polymorphic<T>"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"struct Base {\n  virtual ~Base() = default;  // Virtual destructor makes it polymorphic\n  int32_t value = 0;\n};\n\nstruct NonPolymorphic {\n  int32_t value = 0;  // No virtual methods\n};\n\n// Polymorphic field - type info written automatically\nstruct Container1 {\n  std::shared_ptr<Base> ptr;  // Auto-detected as polymorphic\n};\n\n// Non-polymorphic field - no type info written\nstruct Container2 {\n  std::shared_ptr<NonPolymorphic> ptr;  // Not polymorphic\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"controlling-dynamic-dispatch",children:"Controlling Dynamic Dispatch"}),"\n",(0,i.jsxs)(n.p,{children:["Use ",(0,i.jsx)(n.code,{children:"fory::dynamic<V>"})," to override automatic polymorphism detection:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"struct Animal {\n  virtual ~Animal() = default;\n  virtual std::string speak() const = 0;\n};\n\nstruct Pet {\n  // Auto-detected: type info written (Animal has virtual methods)\n  std::shared_ptr<Animal> animal1;\n\n  // Force dynamic: type info written explicitly\n  fory::field<std::shared_ptr<Animal>, 0, fory::dynamic<true>> animal2;\n\n  // Force non-dynamic: skip type info (faster but no runtime subtyping)\n  fory::field<std::shared_ptr<Animal>, 1, fory::dynamic<false>> animal3;\n};\nFORY_STRUCT(Pet, animal1, animal2, animal3);\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["When to use ",(0,i.jsx)(n.code,{children:"fory::dynamic<false>"}),":"]})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"You know the runtime type will always match the declared type"}),"\n",(0,i.jsx)(n.li,{children:"Performance is critical and you don't need subtype support"}),"\n",(0,i.jsx)(n.li,{children:"Working with monomorphic data despite having a polymorphic base class"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"field-configuration-without-wrapper-types",children:"Field Configuration Without Wrapper Types"}),"\n",(0,i.jsxs)(n.p,{children:["Use ",(0,i.jsx)(n.code,{children:"FORY_FIELD_CONFIG"})," to configure fields without ",(0,i.jsx)(n.code,{children:"fory::field<>"})," wrapper:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"struct Zoo {\n  std::shared_ptr<Animal> star;      // Auto-detected as polymorphic\n  std::shared_ptr<Animal> backup;    // Nullable polymorphic field\n  std::shared_ptr<Animal> mascot;    // Non-dynamic (no subtype dispatch)\n};\nFORY_STRUCT(Zoo, star, backup, mascot);\n\n// Configure fields with tag IDs and options\nFORY_FIELD_CONFIG(Zoo,\n    (star, fory::F(0)),                    // Tag ID 0, default options\n    (backup, fory::F(1).nullable()),       // Tag ID 1, allow nullptr\n    (mascot, fory::F(2).dynamic(false))    // Tag ID 2, disable polymorphism\n);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.a,{href:"field_configuration",children:"Field Configuration"})," for complete details on ",(0,i.jsx)(n.code,{children:"fory::nullable"}),", ",(0,i.jsx)(n.code,{children:"fory::ref"}),", and other field-level options"]}),"\n",(0,i.jsx)(n.h2,{id:"stdunique_ptr-polymorphism",children:"std::unique_ptr Polymorphism"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"std::unique_ptr"})," works the same way as ",(0,i.jsx)(n.code,{children:"std::shared_ptr"})," for polymorphic types:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'struct Container {\n  std::unique_ptr<Animal> pet;\n};\nFORY_STRUCT(Container, pet);\n\nauto fory = Fory::builder().track_ref(true).build();\nfory.register_struct<Container>(200);\nfory.register_struct<Dog>(201);\n\nContainer container;\ncontainer.pet = std::make_unique<Dog>();\nstatic_cast<Dog*>(container.pet.get())->breed = "Beagle";\n\nauto bytes = fory.serialize(container).value();\nauto decoded = fory.deserialize<Container>(bytes).value();\n\n// Runtime type preserved\nauto* dog = dynamic_cast<Dog*>(decoded.pet.get());\nassert(dog != nullptr);\nassert(dog->breed == "Beagle");\n'})}),"\n",(0,i.jsx)(n.h2,{id:"collections-of-polymorphic-objects",children:"Collections of Polymorphic Objects"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'#include <vector>\n#include <map>\n\nstruct AnimalShelter {\n  std::vector<std::shared_ptr<Animal>> animals;\n  std::map<std::string, std::unique_ptr<Animal>> registry;\n};\nFORY_STRUCT(AnimalShelter, animals, registry);\n\nauto fory = Fory::builder().track_ref(true).build();\nfory.register_struct<AnimalShelter>(100);\nfory.register_struct<Dog>(101);\nfory.register_struct<Cat>(102);\n\nAnimalShelter shelter;\nshelter.animals.push_back(std::make_shared<Dog>());\nshelter.animals.push_back(std::make_shared<Cat>());\nshelter.registry["pet1"] = std::make_unique<Dog>();\n\nauto bytes = fory.serialize(shelter).value();\nauto decoded = fory.deserialize<AnimalShelter>(bytes).value();\n\n// All runtime types preserved\nassert(dynamic_cast<Dog*>(decoded.animals[0].get()) != nullptr);\nassert(dynamic_cast<Cat*>(decoded.animals[1].get()) != nullptr);\nassert(dynamic_cast<Dog*>(decoded.registry["pet1"].get()) != nullptr);\n'})}),"\n",(0,i.jsx)(n.h2,{id:"reference-tracking",children:"Reference Tracking"}),"\n",(0,i.jsxs)(n.p,{children:["Reference tracking for ",(0,i.jsx)(n.code,{children:"std::shared_ptr"})," works the same with polymorphic types.\nSee ",(0,i.jsx)(n.a,{href:"supported_types",children:"Supported Types"})," for details and examples."]}),"\n",(0,i.jsx)(n.h2,{id:"nested-polymorphism-depth-limit",children:"Nested Polymorphism Depth Limit"}),"\n",(0,i.jsx)(n.p,{children:"To prevent stack overflow from deeply nested polymorphic structures, Fory limits the maximum dynamic nesting depth:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"struct Container {\n  virtual ~Container() = default;\n  int32_t value = 0;\n  std::shared_ptr<Container> nested;\n};\nFORY_STRUCT(Container, value, nested);\n\n// Default max_dyn_depth is 5\nauto fory1 = Fory::builder().build();\nassert(fory1.config().max_dyn_depth == 5);\n\n// Increase limit for deeper nesting\nauto fory2 = Fory::builder().max_dyn_depth(10).build();\nfory2.register_struct<Container>(1);\n\n// Create deeply nested structure\nauto level3 = std::make_shared<Container>();\nlevel3->value = 3;\n\nauto level2 = std::make_shared<Container>();\nlevel2->value = 2;\nlevel2->nested = level3;\n\nauto level1 = std::make_shared<Container>();\nlevel1->value = 1;\nlevel1->nested = level2;\n\n// Serialization succeeds\nauto bytes = fory2.serialize(level1).value();\n\n// Deserialization succeeds with sufficient depth\nauto decoded = fory2.deserialize<std::shared_ptr<Container>>(bytes).value();\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Depth exceeded error:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"auto fory_shallow = Fory::builder().max_dyn_depth(2).build();\nfory_shallow.register_struct<Container>(1);\n\n// 3 levels exceeds max_dyn_depth=2\nauto result = fory_shallow.deserialize<std::shared_ptr<Container>>(bytes);\nassert(!result.ok());  // Fails with depth exceeded error\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"When to adjust:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Increase ",(0,i.jsx)(n.code,{children:"max_dyn_depth"})]}),": For legitimate deeply nested polymorphic data structures"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Decrease ",(0,i.jsx)(n.code,{children:"max_dyn_depth"})]}),": For stricter security requirements or shallow data structures"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"nullability-for-polymorphic-fields",children:"Nullability for Polymorphic Fields"}),"\n",(0,i.jsxs)(n.p,{children:["By default, ",(0,i.jsx)(n.code,{children:"std::shared_ptr<T>"})," and ",(0,i.jsx)(n.code,{children:"std::unique_ptr<T>"})," fields are treated as\nnon-nullable in the schema. To allow ",(0,i.jsx)(n.code,{children:"nullptr"}),", wrap the field with\n",(0,i.jsx)(n.code,{children:"fory::field<>"})," (or ",(0,i.jsx)(n.code,{children:"FORY_FIELD_TAGS"}),") and opt in with ",(0,i.jsx)(n.code,{children:"fory::nullable"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"struct Pet {\n  // Non-nullable (default)\n  std::shared_ptr<Animal> primary;\n\n  // Nullable via explicit field metadata\n  fory::field<std::shared_ptr<Animal>, 0, fory::nullable> optional;\n};\nFORY_STRUCT(Pet, primary, optional);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.a,{href:"field_configuration",children:"Field Configuration"})," for more details."]}),"\n",(0,i.jsx)(n.h2,{id:"combining-polymorphism-with-other-features",children:"Combining Polymorphism with Other Features"}),"\n",(0,i.jsx)(n.h3,{id:"polymorphism--reference-tracking",children:"Polymorphism + Reference Tracking"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"struct GraphNode {\n  virtual ~GraphNode() = default;\n  int32_t id = 0;\n  std::vector<std::shared_ptr<GraphNode>> neighbors;\n};\nFORY_STRUCT(GraphNode, id, neighbors);\n\nstruct WeightedNode : GraphNode {\n  double weight = 0.0;\n};\nFORY_STRUCT(WeightedNode, id, neighbors, weight);\n\n// Enable ref tracking to handle shared references and cycles\nauto fory = Fory::builder().track_ref(true).build();\nfory.register_struct<GraphNode>(100);\nfory.register_struct<WeightedNode>(101);\n\n// Create cyclic graph\nauto node1 = std::make_shared<WeightedNode>();\nnode1->id = 1;\n\nauto node2 = std::make_shared<WeightedNode>();\nnode2->id = 2;\n\nnode1->neighbors.push_back(node2);\nnode2->neighbors.push_back(node1);  // Cycle\n\nauto bytes = fory.serialize(node1).value();\nauto decoded = fory.deserialize<std::shared_ptr<GraphNode>>(bytes).value();\n// Cycle handled correctly\n"})}),"\n",(0,i.jsx)(n.h3,{id:"polymorphism--schema-evolution",children:"Polymorphism + Schema Evolution"}),"\n",(0,i.jsx)(n.p,{children:"Use compatible mode for schema evolution with polymorphic types:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"auto fory = Fory::builder()\n    .compatible(true)  // Enable schema evolution\n    .track_ref(true)\n    .build();\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use type ID registration"})," for polymorphic types:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"fory.register_struct<DerivedType>(100);\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Enable reference tracking"})," for polymorphic types:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"auto fory = Fory::builder().track_ref(true).build();\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Virtual destructors required"}),": Ensure base classes have virtual destructors:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"struct Base {\n  virtual ~Base() = default;  // Required for polymorphism\n};\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Register all concrete types"})," before serialization/deserialization:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"fory.register_struct<Derived1>(100);\nfory.register_struct<Derived2>(101);\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:["Use ",(0,i.jsx)(n.code,{children:"dynamic_cast"})]})," to downcast after deserialization:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"auto* derived = dynamic_cast<DerivedType*>(base_ptr.get());\nif (derived) {\n  // Use derived-specific members\n}\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:["Adjust ",(0,i.jsx)(n.code,{children:"max_dyn_depth"})]})," based on your data structure depth:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"auto fory = Fory::builder().max_dyn_depth(10).build();\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:["Use ",(0,i.jsx)(n.code,{children:"fory::nullable"})]})," for optional polymorphic fields:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"fory::field<std::shared_ptr<Base>, 0, fory::nullable> optional_ptr;\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'auto bytes_result = fory.serialize(obj);\nif (!bytes_result.ok()) {\n  std::cerr << "Serialization failed: "\n            << bytes_result.error().to_string() << std::endl;\n  return;\n}\n\nauto decoded_result = fory.deserialize<MyType>(bytes_result.value());\nif (!decoded_result.ok()) {\n  std::cerr << "Deserialization failed: "\n            << decoded_result.error().to_string() << std::endl;\n  return;\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Common errors:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type not registered"}),": Register all concrete types with unique IDs before use"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Depth exceeded"}),": Increase ",(0,i.jsx)(n.code,{children:"max_dyn_depth"})," for deeply nested structures"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type ID conflict"}),": Ensure each type has a unique type ID across all registered types"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Polymorphic serialization overhead:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Type metadata written for each polymorphic object (~16-32 bytes)"}),"\n",(0,i.jsx)(n.li,{children:"Dynamic type resolution during deserialization"}),"\n",(0,i.jsx)(n.li,{children:"Virtual function calls for runtime dispatch"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Optimization tips:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:["Use ",(0,i.jsx)(n.code,{children:"fory::dynamic<false>"})]})," when runtime type matches declared type:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"fory::field<std::shared_ptr<Base>, 0, fory::dynamic<false>> fixed_type;\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Minimize nesting depth"})," to reduce metadata overhead"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Batch polymorphic objects"})," in collections rather than individual fields"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Consider non-polymorphic alternatives"})," when polymorphism isn't needed:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"std::variant<Dog, Cat> animal;  // Type-safe union instead of polymorphism\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"type_registration",children:"Type Registration"})," - Registering types for serialization"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"field_configuration",children:"Field Configuration"})," - Field-level metadata and options"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"supported_types",children:"Supported Types"})," - Smart pointers and collections"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"configuration",children:"Configuration"})," - ",(0,i.jsx)(n.code,{children:"max_dyn_depth"})," and other settings"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"basic_serialization",children:"Basic Serialization"})," - Core serialization concepts"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},11151:(e,n,r)=>{r.d(n,{Z:()=>l,a:()=>o});var i=r(67294);const t={},s=i.createContext(t);function o(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);