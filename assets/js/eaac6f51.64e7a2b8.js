"use strict";(self.webpackChunkfory_site=self.webpackChunkfory_site||[]).push([[75722],{45909:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>d});var r=i(85893),t=i(11151);const s={title:"Basic Serialization",sidebar_position:2,id:"basic_serialization",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},a=void 0,o={id:"guide/cpp/basic_serialization",title:"Basic Serialization",description:"This page covers basic object graph serialization and the core serialization APIs.",source:"@site/docs/guide/cpp/basic-serialization.md",sourceDirName:"guide/cpp",slug:"/guide/cpp/basic_serialization",permalink:"/docs/next/guide/cpp/basic_serialization",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/fory-site/tree/main/docs/guide/cpp/basic-serialization.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Basic Serialization",sidebar_position:2,id:"basic_serialization",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},sidebar:"docsSidebar",previous:{title:"Configuration",permalink:"/docs/next/guide/cpp/configuration"},next:{title:"Schema Evolution",permalink:"/docs/next/guide/cpp/schema_evolution"}},l={},d=[{value:"Object Graph Serialization",id:"object-graph-serialization",level:2},{value:"Serialization APIs",id:"serialization-apis",level:2},{value:"Serialize to New Vector",id:"serialize-to-new-vector",level:3},{value:"Serialize to Existing Buffer",id:"serialize-to-existing-buffer",level:3},{value:"Deserialize from Byte Array",id:"deserialize-from-byte-array",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"The FORY_STRUCT Macro",id:"the-fory_struct-macro",level:2},{value:"External / Third-Party Types",id:"external--third-party-types",level:2},{value:"Inherited Fields",id:"inherited-fields",level:2},{value:"Nested Structs",id:"nested-structs",level:2},{value:"Performance Tips",id:"performance-tips",level:2},{value:"Related Topics",id:"related-topics",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"This page covers basic object graph serialization and the core serialization APIs."}),"\n",(0,r.jsx)(n.h2,{id:"object-graph-serialization",children:"Object Graph Serialization"}),"\n",(0,r.jsxs)(n.p,{children:["Apache Fory\u2122 provides automatic serialization of complex object graphs, preserving the structure and relationships between objects. The ",(0,r.jsx)(n.code,{children:"FORY_STRUCT"})," macro generates efficient serialization code at compile time, eliminating runtime overhead."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key capabilities:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Nested struct serialization with arbitrary depth"}),"\n",(0,r.jsx)(n.li,{children:"Collection types (vector, set, map)"}),"\n",(0,r.jsxs)(n.li,{children:["Optional fields with ",(0,r.jsx)(n.code,{children:"std::optional<T>"})]}),"\n",(0,r.jsxs)(n.li,{children:["Smart pointers (",(0,r.jsx)(n.code,{children:"std::shared_ptr"}),", ",(0,r.jsx)(n.code,{children:"std::unique_ptr"}),")"]}),"\n",(0,r.jsx)(n.li,{children:"Automatic handling of primitive types and strings"}),"\n",(0,r.jsx)(n.li,{children:"Efficient binary encoding with variable-length integers"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'#include "fory/serialization/fory.h"\n#include <vector>\n#include <map>\n\nusing namespace fory::serialization;\n\n// Define structs\nstruct Address {\n  std::string street;\n  std::string city;\n  std::string country;\n\n  bool operator==(const Address &other) const {\n    return street == other.street && city == other.city &&\n           country == other.country;\n  }\n};\nFORY_STRUCT(Address, street, city, country);\n\nstruct Person {\n  std::string name;\n  int32_t age;\n  Address address;\n  std::vector<std::string> hobbies;\n  std::map<std::string, std::string> metadata;\n\n  bool operator==(const Person &other) const {\n    return name == other.name && age == other.age &&\n           address == other.address && hobbies == other.hobbies &&\n           metadata == other.metadata;\n  }\n};\nFORY_STRUCT(Person, name, age, address, hobbies, metadata);\n\nint main() {\n  auto fory = Fory::builder().xlang(true).build();\n  fory.register_struct<Address>(100);\n  fory.register_struct<Person>(200);\n\n  Person person{\n      "John Doe",\n      30,\n      {"123 Main St", "New York", "USA"},\n      {"reading", "coding"},\n      {{"role", "developer"}}\n  };\n\n  auto result = fory.serialize(person);\n  auto decoded = fory.deserialize<Person>(result.value());\n  assert(person == decoded.value());\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"serialization-apis",children:"Serialization APIs"}),"\n",(0,r.jsx)(n.h3,{id:"serialize-to-new-vector",children:"Serialize to New Vector"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"auto fory = Fory::builder().xlang(true).build();\nfory.register_struct<MyStruct>(1);\n\nMyStruct obj{/* ... */};\n\n// Serialize - returns Result<std::vector<uint8_t>, Error>\nauto result = fory.serialize(obj);\nif (result.ok()) {\n  std::vector<uint8_t> bytes = std::move(result).value();\n  // Use bytes...\n} else {\n  // Handle error\n  std::cerr << result.error().to_string() << std::endl;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"serialize-to-existing-buffer",children:"Serialize to Existing Buffer"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Serialize to existing Buffer (fastest path)\nBuffer buffer;\nauto result = fory.serialize_to(buffer, obj);\nif (result.ok()) {\n  size_t bytes_written = result.value();\n  // buffer now contains serialized data\n}\n\n// Serialize to existing vector (zero-copy)\nstd::vector<uint8_t> output;\nauto result = fory.serialize_to(output, obj);\nif (result.ok()) {\n  size_t bytes_written = result.value();\n  // output now contains serialized data\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"deserialize-from-byte-array",children:"Deserialize from Byte Array"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Deserialize from raw pointer\nauto result = fory.deserialize<MyStruct>(data_ptr, data_size);\nif (result.ok()) {\n  MyStruct obj = std::move(result).value();\n}\n\n// Deserialize from vector\nstd::vector<uint8_t> data = /* ... */;\nauto result = fory.deserialize<MyStruct>(data);\n\n// Deserialize from Buffer (updates reader_index)\nBuffer buffer(data);\nauto result = fory.deserialize<MyStruct>(buffer);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsxs)(n.p,{children:["Fory uses a ",(0,r.jsx)(n.code,{children:"Result<T, Error>"})," type for error handling:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'auto result = fory.serialize(obj);\n\n// Check if operation succeeded\nif (result.ok()) {\n  auto value = std::move(result).value();\n  // Use value...\n} else {\n  Error error = result.error();\n  std::cerr << "Error: " << error.to_string() << std::endl;\n}\n\n// Or use FORY_TRY macro for early return\nFORY_TRY(bytes, fory.serialize(obj));\n// Use bytes directly...\n'})}),"\n",(0,r.jsx)(n.p,{children:"Common error types:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Error::type_mismatch"})," - Type ID mismatch during deserialization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Error::invalid_data"})," - Invalid or corrupted data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Error::buffer_out_of_bound"})," - Buffer overflow/underflow"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Error::type_error"})," - Type registration error"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"the-fory_struct-macro",children:"The FORY_STRUCT Macro"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"FORY_STRUCT"})," macro registers a class for serialization (struct works the\nsame way):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"class MyStruct {\npublic:\n  int32_t x;\n  std::string y;\n  std::vector<int32_t> z;\n  FORY_STRUCT(MyStruct, x, y, z);\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Private fields are supported when the macro is placed in a ",(0,r.jsx)(n.code,{children:"public:"})," section:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"class PrivateUser {\npublic:\n  PrivateUser(int32_t id, std::string name) : id_(id), name_(std::move(name)) {}\n\n  bool operator==(const PrivateUser &other) const {\n    return id_ == other.id_ && name_ == other.name_;\n  }\n\nprivate:\n  int32_t id_ = 0;\n  std::string name_;\n\npublic:\n  FORY_STRUCT(PrivateUser, id_, name_);\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"The macro:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Generates compile-time field metadata"}),"\n",(0,r.jsx)(n.li,{children:"Enables member or ADL (Argument-Dependent Lookup) discovery for serialization"}),"\n",(0,r.jsx)(n.li,{children:"Creates efficient serialization code via template specialization"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Requirements:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Must be declared inside the class definition (struct works the same way) or\nat namespace scope"}),"\n",(0,r.jsx)(n.li,{children:"Must be placed after all field declarations (when used inside the class)"}),"\n",(0,r.jsxs)(n.li,{children:["When used inside a class, the macro must be placed in a ",(0,r.jsx)(n.code,{children:"public:"})," section"]}),"\n",(0,r.jsx)(n.li,{children:"All listed fields must be serializable types"}),"\n",(0,r.jsx)(n.li,{children:"Field order in the macro is not important"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"external--third-party-types",children:"External / Third-Party Types"}),"\n",(0,r.jsxs)(n.p,{children:["When you cannot modify a third-party type, use ",(0,r.jsx)(n.code,{children:"FORY_STRUCT"})," at namespace\nscope. This only works with ",(0,r.jsx)(n.strong,{children:"public"})," fields."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"namespace thirdparty {\nstruct Foo {\n  int32_t id;\n  std::string name;\n};\n\nFORY_STRUCT(Foo, id, name);\n} // namespace thirdparty\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Limitations:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Must be declared at namespace scope in the same namespace as the type"}),"\n",(0,r.jsx)(n.li,{children:"Only public fields are supported"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"inherited-fields",children:"Inherited Fields"}),"\n",(0,r.jsxs)(n.p,{children:["To include base-class fields in a derived type, use ",(0,r.jsx)(n.code,{children:"FORY_BASE(Base)"})," inside\n",(0,r.jsx)(n.code,{children:"FORY_STRUCT"}),". The base must define its own ",(0,r.jsx)(n.code,{children:"FORY_STRUCT"})," so its fields can be\nreferenced."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"struct Base {\n  int32_t a;\n  FORY_STRUCT(Base, a);\n};\n\nstruct Derived : Base {\n  int32_t b;\n  FORY_STRUCT(Derived, FORY_BASE(Base), b);\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Base fields are serialized before derived fields."}),"\n",(0,r.jsx)(n.li,{children:"Only fields visible from the derived type are supported."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"nested-structs",children:"Nested Structs"}),"\n",(0,r.jsx)(n.p,{children:"Nested structs are fully supported:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"struct Inner {\n  int32_t value;\n  FORY_STRUCT(Inner, value);\n};\n\nstruct Outer {\n  Inner inner;\n  std::string label;\n  FORY_STRUCT(Outer, inner, label);\n};\n\n// Both must be registered\nfory.register_struct<Inner>(1);\nfory.register_struct<Outer>(2);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"performance-tips",children:"Performance Tips"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Buffer Reuse"}),": Use ",(0,r.jsx)(n.code,{children:"serialize_to(buffer, obj)"})," with pre-allocated buffers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pre-registration"}),": Register all types before serialization starts"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Single-Threaded"}),": Use ",(0,r.jsx)(n.code,{children:"build()"})," instead of ",(0,r.jsx)(n.code,{children:"build_thread_safe()"})," when possible"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Disable Tracking"}),": Use ",(0,r.jsx)(n.code,{children:"track_ref(false)"})," when references aren't needed"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compact Encoding"}),": Variable-length encoding for space efficiency"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/next/guide/cpp/configuration",children:"Configuration"})," - Builder options"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/next/guide/cpp/type_registration",children:"Type Registration"})," - Registering types"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/next/guide/cpp/supported_types",children:"Supported Types"})," - All supported types"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>o,a:()=>a});var r=i(67294);const t={},s=r.createContext(t);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);