"use strict";(self.webpackChunkfory_site=self.webpackChunkfory_site||[]).push([[63519],{8942:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>d});var t=r(85893),i=r(11151);const s={title:"Trait Object Serialization",sidebar_position:6,id:"polymorphism",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},a=void 0,o={id:"guide/rust/polymorphism",title:"Trait Object Serialization",description:"Apache Fory\u2122 supports polymorphic serialization through trait objects, enabling dynamic dispatch and type flexibility.",source:"@site/versioned_docs/version-0.14/guide/rust/polymorphism.md",sourceDirName:"guide/rust",slug:"/guide/rust/polymorphism",permalink:"/docs/0.14/guide/rust/polymorphism",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/fory-site/tree/main/docs/guide/rust/polymorphism.md",tags:[],version:"0.14",sidebarPosition:6,frontMatter:{title:"Trait Object Serialization",sidebar_position:6,id:"polymorphism",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},sidebar:"docsSidebar",previous:{title:"Shared & Circular References",permalink:"/docs/0.14/guide/rust/references"},next:{title:"Schema Evolution",permalink:"/docs/0.14/guide/rust/schema_evolution"}},c={},d=[{value:"Supported Trait Object Types",id:"supported-trait-object-types",level:2},{value:"Basic Trait Object Serialization",id:"basic-trait-object-serialization",level:2},{value:"Serializing dyn Any Trait Objects",id:"serializing-dyn-any-trait-objects",level:2},{value:"Rc/Arc-Based Trait Objects in Structs",id:"rcarc-based-trait-objects-in-structs",level:2},{value:"Standalone Trait Object Serialization",id:"standalone-trait-object-serialization",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Related Topics",id:"related-topics",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Apache Fory\u2122 supports polymorphic serialization through trait objects, enabling dynamic dispatch and type flexibility."}),"\n",(0,t.jsx)(n.h2,{id:"supported-trait-object-types",children:"Supported Trait Object Types"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Box<dyn Trait>"})," - Owned trait objects"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Rc<dyn Trait>"})," - Reference-counted trait objects"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Arc<dyn Trait>"})," - Thread-safe reference-counted trait objects"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Vec<Box<dyn Trait>>"}),", ",(0,t.jsx)(n.code,{children:"HashMap<K, Box<dyn Trait>>"})," - Collections of trait objects"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"basic-trait-object-serialization",children:"Basic Trait Object Serialization"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use fory::{Fory, register_trait_type};\nuse fory::Serializer;\nuse fory::ForyObject;\n\ntrait Animal: Serializer {\n    fn speak(&self) -> String;\n    fn name(&self) -> &str;\n}\n\n#[derive(ForyObject)]\nstruct Dog { name: String, breed: String }\n\nimpl Animal for Dog {\n    fn speak(&self) -> String { "Woof!".to_string() }\n    fn name(&self) -> &str { &self.name }\n}\n\n#[derive(ForyObject)]\nstruct Cat { name: String, color: String }\n\nimpl Animal for Cat {\n    fn speak(&self) -> String { "Meow!".to_string() }\n    fn name(&self) -> &str { &self.name }\n}\n\n// Register trait implementations\nregister_trait_type!(Animal, Dog, Cat);\n\n#[derive(ForyObject)]\nstruct Zoo {\n    star_animal: Box<dyn Animal>,\n}\n\nlet mut fory = Fory::default().compatible(true);\nfory.register::<Dog>(100);\nfory.register::<Cat>(101);\nfory.register::<Zoo>(102);\n\nlet zoo = Zoo {\n    star_animal: Box::new(Dog {\n        name: "Buddy".to_string(),\n        breed: "Labrador".to_string(),\n    }),\n};\n\nlet bytes = fory.serialize(&zoo);\nlet decoded: Zoo = fory.deserialize(&bytes)?;\n\nassert_eq!(decoded.star_animal.name(), "Buddy");\nassert_eq!(decoded.star_animal.speak(), "Woof!");\n'})}),"\n",(0,t.jsx)(n.h2,{id:"serializing-dyn-any-trait-objects",children:"Serializing dyn Any Trait Objects"}),"\n",(0,t.jsxs)(n.p,{children:["Apache Fory\u2122 supports serializing ",(0,t.jsx)(n.code,{children:"Rc<dyn Any>"})," and ",(0,t.jsx)(n.code,{children:"Arc<dyn Any>"})," for runtime type dispatch:"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key points:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Works with any type that implements ",(0,t.jsx)(n.code,{children:"Serializer"})]}),"\n",(0,t.jsx)(n.li,{children:"Requires downcasting after deserialization to access the concrete type"}),"\n",(0,t.jsx)(n.li,{children:"Type information is preserved during serialization"}),"\n",(0,t.jsx)(n.li,{children:"Useful for plugin systems and dynamic type handling"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use std::rc::Rc;\nuse std::any::Any;\n\nlet dog_rc: Rc<dyn Animal> = Rc::new(Dog {\n    name: "Rex".to_string(),\n    breed: "Golden".to_string()\n});\n\n// Convert to Rc<dyn Any> for serialization\nlet dog_any: Rc<dyn Any> = dog_rc.clone();\n\n// Serialize the Any wrapper\nlet bytes = fory.serialize(&dog_any);\nlet decoded: Rc<dyn Any> = fory.deserialize(&bytes)?;\n\n// Downcast back to the concrete type\nlet unwrapped = decoded.downcast_ref::<Dog>().unwrap();\nassert_eq!(unwrapped.name, "Rex");\n'})}),"\n",(0,t.jsxs)(n.p,{children:["For thread-safe scenarios, use ",(0,t.jsx)(n.code,{children:"Arc<dyn Any>"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use std::sync::Arc;\nuse std::any::Any;\n\nlet dog_arc: Arc<dyn Animal> = Arc::new(Dog {\n    name: "Buddy".to_string(),\n    breed: "Labrador".to_string()\n});\n\n// Convert to Arc<dyn Any>\nlet dog_any: Arc<dyn Any> = dog_arc.clone();\n\nlet bytes = fory.serialize(&dog_any);\nlet decoded: Arc<dyn Any> = fory.deserialize(&bytes)?;\n\n// Downcast to concrete type\nlet unwrapped = decoded.downcast_ref::<Dog>().unwrap();\nassert_eq!(unwrapped.name, "Buddy");\n'})}),"\n",(0,t.jsx)(n.h2,{id:"rcarc-based-trait-objects-in-structs",children:"Rc/Arc-Based Trait Objects in Structs"}),"\n",(0,t.jsxs)(n.p,{children:["For fields with ",(0,t.jsx)(n.code,{children:"Rc<dyn Trait>"})," or ",(0,t.jsx)(n.code,{children:"Arc<dyn Trait>"}),", Fory automatically handles the conversion:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use std::sync::Arc;\nuse std::rc::Rc;\nuse std::collections::HashMap;\n\n#[derive(ForyObject)]\nstruct AnimalShelter {\n    animals_rc: Vec<Rc<dyn Animal>>,\n    animals_arc: Vec<Arc<dyn Animal>>,\n    registry: HashMap<String, Arc<dyn Animal>>,\n}\n\nlet mut fory = Fory::default().compatible(true);\nfory.register::<Dog>(100);\nfory.register::<Cat>(101);\nfory.register::<AnimalShelter>(102);\n\nlet shelter = AnimalShelter {\n    animals_rc: vec![\n        Rc::new(Dog { name: "Rex".to_string(), breed: "Golden".to_string() }),\n        Rc::new(Cat { name: "Mittens".to_string(), color: "Gray".to_string() }),\n    ],\n    animals_arc: vec![\n        Arc::new(Dog { name: "Buddy".to_string(), breed: "Labrador".to_string() }),\n    ],\n    registry: HashMap::from([\n        ("pet1".to_string(), Arc::new(Dog {\n            name: "Max".to_string(),\n            breed: "Shepherd".to_string()\n        }) as Arc<dyn Animal>),\n    ]),\n};\n\nlet bytes = fory.serialize(&shelter);\nlet decoded: AnimalShelter = fory.deserialize(&bytes)?;\n\nassert_eq!(decoded.animals_rc[0].name(), "Rex");\nassert_eq!(decoded.animals_arc[0].speak(), "Woof!");\n'})}),"\n",(0,t.jsx)(n.h2,{id:"standalone-trait-object-serialization",children:"Standalone Trait Object Serialization"}),"\n",(0,t.jsxs)(n.p,{children:["Due to Rust's orphan rule, ",(0,t.jsx)(n.code,{children:"Rc<dyn Trait>"})," and ",(0,t.jsx)(n.code,{children:"Arc<dyn Trait>"})," cannot implement ",(0,t.jsx)(n.code,{children:"Serializer"})," directly. For standalone serialization (not inside struct fields), the ",(0,t.jsx)(n.code,{children:"register_trait_type!"})," macro generates wrapper types."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note:"})," If you don't want to use wrapper types, you can serialize as ",(0,t.jsx)(n.code,{children:"Rc<dyn Any>"})," or ",(0,t.jsx)(n.code,{children:"Arc<dyn Any>"})," instead (see the dyn Any section above)."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"register_trait_type!"})," macro generates ",(0,t.jsx)(n.code,{children:"AnimalRc"})," and ",(0,t.jsx)(n.code,{children:"AnimalArc"})," wrapper types:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// For Rc<dyn Trait>\nlet dog_rc: Rc<dyn Animal> = Rc::new(Dog {\n    name: "Rex".to_string(),\n    breed: "Golden".to_string()\n});\nlet wrapper = AnimalRc::from(dog_rc);\n\nlet bytes = fory.serialize(&wrapper);\nlet decoded: AnimalRc = fory.deserialize(&bytes)?;\n\n// Unwrap back to Rc<dyn Animal>\nlet unwrapped: Rc<dyn Animal> = decoded.unwrap();\nassert_eq!(unwrapped.name(), "Rex");\n\n// For Arc<dyn Trait>\nlet dog_arc: Arc<dyn Animal> = Arc::new(Dog {\n    name: "Buddy".to_string(),\n    breed: "Labrador".to_string()\n});\nlet wrapper = AnimalArc::from(dog_arc);\n\nlet bytes = fory.serialize(&wrapper);\nlet decoded: AnimalArc = fory.deserialize(&bytes)?;\n\nlet unwrapped: Arc<dyn Animal> = decoded.unwrap();\nassert_eq!(unwrapped.name(), "Buddy");\n'})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["Use ",(0,t.jsx)(n.code,{children:"register_trait_type!"})]})," to register all trait implementations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Enable compatible mode"})," for trait objects: ",(0,t.jsx)(n.code,{children:".compatible(true)"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Register all concrete types"})," before serialization"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Prefer dyn Any"})," for simpler standalone serialization"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/0.14/guide/rust/references",children:"References"})," - Rc/Arc shared references"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/0.14/guide/rust/schema_evolution",children:"Schema Evolution"})," - Compatible mode"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/0.14/guide/rust/type_registration",children:"Type Registration"})," - Registering types"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},11151:(e,n,r)=>{r.d(n,{Z:()=>o,a:()=>a});var t=r(67294);const i={},s=t.createContext(i);function a(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);