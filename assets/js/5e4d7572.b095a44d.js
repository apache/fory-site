"use strict";(self.webpackChunkfory_site=self.webpackChunkfory_site||[]).push([[97445],{13399:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>o});var t=r(85893),s=r(11151);const i={title:"Row Format",sidebar_position:20,id:"row_format",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},a=void 0,c={id:"guide/cpp/row_format",title:"Row Format",description:"This page covers the row-based serialization format for high-performance, cache-friendly data access.",source:"@site/docs/guide/cpp/row-format.md",sourceDirName:"guide/cpp",slug:"/guide/cpp/row_format",permalink:"/docs/next/guide/cpp/row_format",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/fory-site/tree/main/docs/guide/cpp/row-format.md",tags:[],version:"current",sidebarPosition:20,frontMatter:{title:"Row Format",sidebar_position:20,id:"row_format",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},sidebar:"docsSidebar",previous:{title:"Cross-Language Serialization",permalink:"/docs/next/guide/cpp/cross_language"},next:{title:"Go Serialization Guide",permalink:"/docs/next/guide/go/"}},d={},o=[{value:"Overview",id:"overview",level:2},{value:"When to Use Row Format",id:"when-to-use-row-format",level:2},{value:"Quick Start",id:"quick-start",level:2},{value:"Row Encoder",id:"row-encoder",level:2},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Nested Structs",id:"nested-structs",level:3},{value:"Arrays / Lists",id:"arrays--lists",level:3},{value:"Encoding Arrays Directly",id:"encoding-arrays-directly",level:3},{value:"Row Data Access",id:"row-data-access",level:2},{value:"Row Class",id:"row-class",level:3},{value:"ArrayData Class",id:"arraydata-class",level:3},{value:"MapData Class",id:"mapdata-class",level:3},{value:"Schema and Types",id:"schema-and-types",level:2},{value:"Schema Definition",id:"schema-definition",level:3},{value:"Type System",id:"type-system",level:3},{value:"Type Inference",id:"type-inference",level:3},{value:"Row Writer",id:"row-writer",level:2},{value:"RowWriter",id:"rowwriter",level:3},{value:"ArrayWriter",id:"arraywriter",level:3},{value:"Null Values",id:"null-values",level:3},{value:"Memory Layout",id:"memory-layout",level:2},{value:"Row Layout",id:"row-layout",level:3},{value:"Array Layout",id:"array-layout",level:3},{value:"Map Layout",id:"map-layout",level:3},{value:"Performance Tips",id:"performance-tips",level:2},{value:"1. Reuse Encoders",id:"1-reuse-encoders",level:3},{value:"2. Pre-allocate Buffer",id:"2-pre-allocate-buffer",level:3},{value:"3. Batch Processing",id:"3-batch-processing",level:3},{value:"4. Zero-copy Reading",id:"4-zero-copy-reading",level:3},{value:"Supported Types Summary",id:"supported-types-summary",level:2},{value:"Related Topics",id:"related-topics",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"This page covers the row-based serialization format for high-performance, cache-friendly data access."}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"Apache Fory\u2122 Row Format is a binary format optimized for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Random Access"}),": Read any field without deserializing the entire object"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Zero-copy"}),": Direct memory access without data copying"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cache-Friendly"}),": Contiguous memory layout for CPU cache efficiency"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Columnar Conversion"}),": Easy conversion to Apache Arrow format"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Partial Serialization"}),": Serialize only needed fields"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"when-to-use-row-format",children:"When to Use Row Format"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Use Case"}),(0,t.jsx)(n.th,{children:"Row Format"}),(0,t.jsx)(n.th,{children:"Object Graph"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Analytics/OLAP"}),(0,t.jsx)(n.td,{children:"\u2705"}),(0,t.jsx)(n.td,{children:"\u274c"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Random field access"}),(0,t.jsx)(n.td,{children:"\u2705"}),(0,t.jsx)(n.td,{children:"\u274c"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Full object serialization"}),(0,t.jsx)(n.td,{children:"\u274c"}),(0,t.jsx)(n.td,{children:"\u2705"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Complex object graphs"}),(0,t.jsx)(n.td,{children:"\u274c"}),(0,t.jsx)(n.td,{children:"\u2705"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Reference tracking"}),(0,t.jsx)(n.td,{children:"\u274c"}),(0,t.jsx)(n.td,{children:"\u2705"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Cross-language (simple types)"}),(0,t.jsx)(n.td,{children:"\u2705"}),(0,t.jsx)(n.td,{children:"\u2705"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'#include "fory/encoder/row_encoder.h"\n#include "fory/row/writer.h"\n\nusing namespace fory::row;\nusing namespace fory::row::encoder;\n\nstruct Person {\n  int32_t id;\n  std::string name;\n  float score;\n  FORY_STRUCT(Person, id, name, score);\n};\n\nint main() {\n  // Create encoder\n  RowEncoder<Person> encoder;\n\n  // encode a person\n  Person person{1, "Alice", 95.5f};\n  encoder.encode(person);\n\n  // get the encoded row\n  auto row = encoder.get_writer().to_row();\n\n  // Random access to fields\n  int32_t id = row->get_int32(0);\n  std::string name = row->get_string(1);\n  float score = row->get_float(2);\n\n  assert(id == 1);\n  assert(name == "Alice");\n  assert(score == 95.5f);\n\n  return 0;\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"row-encoder",children:"Row Encoder"}),"\n",(0,t.jsx)(n.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"RowEncoder<T>"})," template class provides type-safe encoding:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'#include "fory/encoder/row_encoder.h"\n\nstruct Point {\n  double x;\n  double y;\n  FORY_STRUCT(Point, x, y);\n};\n\n// Create encoder\nRowEncoder<Point> encoder;\n\n// Access schema (for inspection)\nconst Schema& schema = encoder.get_schema();\nstd::cout << "Fields: " << schema.field_names().size() << std::endl;\n\n// encode value\nPoint p{1.0, 2.0};\nencoder.encode(p);\n\n// get result as Row\nauto row = encoder.get_writer().to_row();\n'})}),"\n",(0,t.jsx)(n.h3,{id:"nested-structs",children:"Nested Structs"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'struct Address {\n  std::string city;\n  std::string country;\n  FORY_STRUCT(Address, city, country);\n};\n\nstruct Person {\n  std::string name;\n  Address address;\n  FORY_STRUCT(Person, name, address);\n};\n\n// encode nested struct\nRowEncoder<Person> encoder;\nPerson person{"Alice", {"New York", "USA"}};\nencoder.encode(person);\n\nauto row = encoder.get_writer().to_row();\nstd::string name = row->get_string(0);\n\n// Access nested struct\nauto address_row = row->get_struct(1);\nstd::string city = address_row->get_string(0);\nstd::string country = address_row->get_string(1);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"arrays--lists",children:"Arrays / Lists"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'struct Record {\n  std::vector<int32_t> values;\n  std::string label;\n  FORY_STRUCT(Record, values, label);\n};\n\nRowEncoder<Record> encoder;\nRecord record{{1, 2, 3, 4, 5}, "test"};\nencoder.encode(record);\n\nauto row = encoder.get_writer().to_row();\nauto array = row->get_array(0);\n\nint count = array->num_elements();\nfor (int i = 0; i < count; i++) {\n  int32_t value = array->get_int32(i);\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"encoding-arrays-directly",children:"Encoding Arrays Directly"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'// encode a vector directly (not inside a struct)\nstd::vector<Person> people{\n    {"Alice", {"NYC", "USA"}},\n    {"Bob", {"London", "UK"}}\n};\n\nRowEncoder<decltype(people)> encoder;\nencoder.encode(people);\n\n// get array data\nauto array = encoder.get_writer().copy_to_array_data();\nauto first_person = array->get_struct(0);\nstd::string first_name = first_person->get_string(0);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"row-data-access",children:"Row Data Access"}),"\n",(0,t.jsx)(n.h3,{id:"row-class",children:"Row Class"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"Row"})," class provides random access to struct fields:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"class Row {\npublic:\n  // Null check\n  bool is_null_at(int i) const;\n\n  // Primitive getters\n  bool get_boolean(int i) const;\n  int8_t get_int8(int i) const;\n  int16_t get_int16(int i) const;\n  int32_t get_int32(int i) const;\n  int64_t get_int64(int i) const;\n  float get_float(int i) const;\n  double get_double(int i) const;\n\n  // String/binary getter\n  std::string get_string(int i) const;\n  std::vector<uint8_t> get_binary(int i) const;\n\n  // Nested types\n  std::shared_ptr<Row> get_struct(int i) const;\n  std::shared_ptr<ArrayData> get_array(int i) const;\n  std::shared_ptr<MapData> get_map(int i) const;\n\n  // Metadata\n  int num_fields() const;\n  SchemaPtr schema() const;\n\n  // Debug\n  std::string to_string() const;\n};\n"})}),"\n",(0,t.jsx)(n.h3,{id:"arraydata-class",children:"ArrayData Class"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ArrayData"})," class provides access to list/array elements:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"class ArrayData {\npublic:\n  // Null check\n  bool is_null_at(int i) const;\n\n  // Element count\n  int num_elements() const;\n\n  // Primitive getters (same as Row)\n  int32_t get_int32(int i) const;\n  // ... other primitives\n\n  // String getter\n  std::string get_string(int i) const;\n\n  // Nested types\n  std::shared_ptr<Row> get_struct(int i) const;\n  std::shared_ptr<ArrayData> get_array(int i) const;\n  std::shared_ptr<MapData> get_map(int i) const;\n\n  // Type info\n  ListTypePtr type() const;\n};\n"})}),"\n",(0,t.jsx)(n.h3,{id:"mapdata-class",children:"MapData Class"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"MapData"})," class provides access to map key-value pairs:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"class MapData {\npublic:\n  // Element count\n  int num_elements();\n\n  // Access keys and values as arrays\n  std::shared_ptr<ArrayData> keys_array();\n  std::shared_ptr<ArrayData> values_array();\n\n  // Type info\n  MapTypePtr type();\n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"schema-and-types",children:"Schema and Types"}),"\n",(0,t.jsx)(n.h3,{id:"schema-definition",children:"Schema Definition"}),"\n",(0,t.jsx)(n.p,{children:"Schemas define the structure of row data:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'#include "fory/row/schema.h"\n\nusing namespace fory::row;\n\n// Create schema programmatically\nauto person_schema = schema({\n    field("id", int32()),\n    field("name", utf8()),\n    field("score", float32()),\n    field("active", boolean())\n});\n\n// Access schema info\nfor (const auto& f : person_schema->fields()) {\n  std::cout << f->name() << ": " << f->type()->name() << std::endl;\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"type-system",children:"Type System"}),"\n",(0,t.jsx)(n.p,{children:"Available types for row format:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// Primitive types\nDataTypePtr boolean();    // bool\nDataTypePtr int8();       // int8_t\nDataTypePtr int16();      // int16_t\nDataTypePtr int32();      // int32_t\nDataTypePtr int64();      // int64_t\nDataTypePtr float32();    // float\nDataTypePtr float64();    // double\n\n// String and binary\nDataTypePtr utf8();       // std::string\nDataTypePtr binary();     // std::vector<uint8_t>\n\n// Complex types\nDataTypePtr list(DataTypePtr element_type);\nDataTypePtr map(DataTypePtr key_type, DataTypePtr value_type);\nDataTypePtr struct_(std::vector<FieldPtr> fields);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"type-inference",children:"Type Inference"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"RowEncodeTrait"})," template automatically infers types:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// Type inference for primitives\nRowEncodeTrait<int32_t>::Type();  // Returns int32()\nRowEncodeTrait<float>::Type();    // Returns float32()\nRowEncodeTrait<std::string>::Type();  // Returns utf8()\n\n// Type inference for collections\nRowEncodeTrait<std::vector<int32_t>>::Type();  // Returns list(int32())\n\n// Type inference for maps\nRowEncodeTrait<std::map<std::string, int32_t>>::Type();\n// Returns map(utf8(), int32())\n\n// Type inference for structs (requires FORY_STRUCT)\nRowEncodeTrait<Person>::Type();  // Returns struct_({...})\nRowEncodeTrait<Person>::Schema();  // Returns schema({...})\n"})}),"\n",(0,t.jsx)(n.h2,{id:"row-writer",children:"Row Writer"}),"\n",(0,t.jsx)(n.h3,{id:"rowwriter",children:"RowWriter"}),"\n",(0,t.jsx)(n.p,{children:"For manual row construction:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'#include "fory/row/writer.h"\n\n// Create schema\nauto my_schema = schema({\n    field("x", int32()),\n    field("y", float64()),\n    field("name", utf8())\n});\n\n// Create writer\nRowWriter writer(my_schema);\nwriter.reset();\n\n// write fields\nwriter.write(0, 42);          // x = 42\nwriter.write(1, 3.14);        // y = 3.14\nwriter.write_string(2, "test"); // name = "test"\n\n// get result\nauto row = writer.to_row();\n'})}),"\n",(0,t.jsx)(n.h3,{id:"arraywriter",children:"ArrayWriter"}),"\n",(0,t.jsx)(n.p,{children:"For manual array construction:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// Create array type\nauto array_type = list(int32());\n\n// Create writer\nArrayWriter writer(array_type);\nwriter.reset(5);  // 5 elements\n\n// write elements\nfor (int i = 0; i < 5; i++) {\n  writer.write(i, i * 10);\n}\n\n// get result\nauto array = writer.copy_to_array_data();\n"})}),"\n",(0,t.jsx)(n.h3,{id:"null-values",children:"Null Values"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// Set null at specific index\nwriter.set_null_at(2);  // Field 2 is null\n\n// Check null when reading\nif (!row->is_null_at(2)) {\n  std::string value = row->get_string(2);\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"memory-layout",children:"Memory Layout"}),"\n",(0,t.jsx)(n.h3,{id:"row-layout",children:"Row Layout"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"+------------------+--------------------+--------------------+\n|   Null Bitmap    |  Fixed-Size Data   | Variable-Size Data |\n+------------------+--------------------+--------------------+\n|   ceil(n/8) B    |     8 * n bytes    |      variable      |\n+------------------+--------------------+--------------------+\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Null Bitmap"}),": One bit per field, indicates null values"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fixed-Size Data"}),": 8 bytes per field (primitives stored directly, offset+size for variable)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Variable-Size Data"}),": Strings, arrays, nested structs"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"array-layout",children:"Array Layout"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"+------------+------------------+--------------------+--------------------+\n| Num Elems  |   Null Bitmap    |  Fixed-Size Data   | Variable-Size Data |\n+------------+------------------+--------------------+--------------------+\n|   8 bytes  |  ceil(n/8) bytes |   elem_size * n    |      variable      |\n+------------+------------------+--------------------+--------------------+\n"})}),"\n",(0,t.jsx)(n.h3,{id:"map-layout",children:"Map Layout"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"+------------------+------------------+\n|    Keys Array    |   Values Array   |\n+------------------+------------------+\n"})}),"\n",(0,t.jsx)(n.h2,{id:"performance-tips",children:"Performance Tips"}),"\n",(0,t.jsx)(n.h3,{id:"1-reuse-encoders",children:"1. Reuse Encoders"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"RowEncoder<Person> encoder;\n\n// encode multiple records\nfor (const auto& person : people) {\n  encoder.encode(person);\n  auto row = encoder.get_writer().to_row();\n  // Process row...\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-pre-allocate-buffer",children:"2. Pre-allocate Buffer"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// get buffer reference for pre-allocation\nauto& buffer = encoder.get_writer().buffer();\nbuffer->reserve(expected_size);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-batch-processing",children:"3. Batch Processing"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// Process in batches for better cache utilization\nstd::vector<Person> batch;\nbatch.reserve(BATCH_SIZE);\n\nwhile (has_more()) {\n  batch.clear();\n  fill_batch(batch);\n\n  for (const auto& person : batch) {\n    encoder.encode(person);\n    process(encoder.get_writer().to_row());\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"4-zero-copy-reading",children:"4. Zero-copy Reading"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// Point to existing buffer (zero-copy)\nRow row(schema);\nrow.point_to(buffer, offset, size);\n\n// Access fields directly from buffer\nint32_t id = row.get_int32(0);\n"})}),"\n",(0,t.jsx)(n.h2,{id:"supported-types-summary",children:"Supported Types Summary"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"C++ Type"}),(0,t.jsx)(n.th,{children:"Row Type"}),(0,t.jsx)(n.th,{children:"Fixed Size"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"bool"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"boolean()"})}),(0,t.jsx)(n.td,{children:"1 byte"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"int8_t"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"int8()"})}),(0,t.jsx)(n.td,{children:"1 byte"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"int16_t"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"int16()"})}),(0,t.jsx)(n.td,{children:"2 bytes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"int32_t"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"int32()"})}),(0,t.jsx)(n.td,{children:"4 bytes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"int64_t"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"int64()"})}),(0,t.jsx)(n.td,{children:"8 bytes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"float"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"float32()"})}),(0,t.jsx)(n.td,{children:"4 bytes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"double"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"float64()"})}),(0,t.jsx)(n.td,{children:"8 bytes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"std::string"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"utf8()"})}),(0,t.jsx)(n.td,{children:"Variable"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"std::vector<T>"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"list(T)"})}),(0,t.jsx)(n.td,{children:"Variable"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"std::map<K,V>"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"map(K,V)"})}),(0,t.jsx)(n.td,{children:"Variable"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"std::optional<T>"})}),(0,t.jsx)(n.td,{children:"Inner type"}),(0,t.jsx)(n.td,{children:"Nullable"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Struct (FORY_STRUCT)"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"struct_({...})"})}),(0,t.jsx)(n.td,{children:"Variable"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/next/guide/cpp/basic_serialization",children:"Basic Serialization"})," - Object graph serialization"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/next/guide/cpp/configuration",children:"Configuration"})," - Builder options"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/next/guide/cpp/supported_types",children:"Supported Types"})," - All supported types"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},11151:(e,n,r)=>{r.d(n,{Z:()=>c,a:()=>a});var t=r(67294);const s={},i=t.createContext(s);function a(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);