"use strict";(self.webpackChunkfory_site=self.webpackChunkfory_site||[]).push([[31536],{83766:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var i=n(85893),r=n(11151);const a={title:"\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u5668",sidebar_position:6,id:"custom_serializers",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},s=void 0,o={id:"guide/cpp/custom_serializers",title:"\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u5668",description:"\u5bf9\u4e8e\u4e0d\u652f\u6301 FORY_STRUCT \u7684\u7c7b\u578b\uff0c\u9700\u8981\u624b\u52a8\u5b9e\u73b0 Serializer \u6a21\u677f\u7279\u5316\u3002",source:"@site/i18n/zh-CN/docusaurus-plugin-content-docs/version-0.15/guide/cpp/custom-serializers.md",sourceDirName:"guide/cpp",slug:"/guide/cpp/custom_serializers",permalink:"/zh-CN/docs/guide/cpp/custom_serializers",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/fory-site/tree/main/i18n/zh-CN/docusaurus-plugin-content-docs/version-0.15/guide/cpp/custom-serializers.md",tags:[],version:"0.15",sidebarPosition:6,frontMatter:{title:"\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u5668",sidebar_position:6,id:"custom_serializers",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},sidebar:"docsSidebar",previous:{title:"\u8de8\u8bed\u8a00\u5e8f\u5217\u5316",permalink:"/zh-CN/docs/guide/cpp/cross_language"},next:{title:"\u884c\u683c\u5f0f",permalink:"/zh-CN/docs/guide/cpp/row_format"}},d={},l=[{value:"\u4f55\u65f6\u4f7f\u7528\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u5668",id:"\u4f55\u65f6\u4f7f\u7528\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u5668",level:2},{value:"\u5b9e\u73b0 Serializer \u6a21\u677f",id:"\u5b9e\u73b0-serializer-\u6a21\u677f",level:2},{value:"Required Methods",id:"required-methods",level:2},{value:"Registering Custom Serializers",id:"registering-custom-serializers",level:2},{value:"Complete Example",id:"complete-example",level:2},{value:"WriteContext Methods",id:"writecontext-methods",level:2},{value:"ReadContext Methods",id:"readcontext-methods",level:2},{value:"Delegating to Built-in Serializers",id:"delegating-to-built-in-serializers",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Related Topics",id:"related-topics",level:2}];function c(e){const t={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["\u5bf9\u4e8e\u4e0d\u652f\u6301 ",(0,i.jsx)(t.code,{children:"FORY_STRUCT"})," \u7684\u7c7b\u578b\uff0c\u9700\u8981\u624b\u52a8\u5b9e\u73b0 ",(0,i.jsx)(t.code,{children:"Serializer"})," \u6a21\u677f\u7279\u5316\u3002"]}),"\n",(0,i.jsx)(t.h2,{id:"\u4f55\u65f6\u4f7f\u7528\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u5668",children:"\u4f55\u65f6\u4f7f\u7528\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u5668"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"External types from third-party libraries"}),"\n",(0,i.jsx)(t.li,{children:"Types with special serialization requirements"}),"\n",(0,i.jsx)(t.li,{children:"Legacy data format compatibility"}),"\n",(0,i.jsx)(t.li,{children:"Performance-critical custom encoding"}),"\n",(0,i.jsx)(t.li,{children:"Cross-language interoperability with custom protocols"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"\u5b9e\u73b0-serializer-\u6a21\u677f",children:"\u5b9e\u73b0 Serializer \u6a21\u677f"}),"\n",(0,i.jsxs)(t.p,{children:["To create a custom serializer, specialize the ",(0,i.jsx)(t.code,{children:"Serializer"})," template for your type within the ",(0,i.jsx)(t.code,{children:"fory::serialization"})," namespace:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:'#include "fory/serialization/fory.h"\n\nusing namespace fory::serialization;\n\n// Define your custom type\nstruct MyExt {\n  int32_t id;\n  bool operator==(const MyExt &other) const { return id == other.id; }\n};\n\nnamespace fory {\nnamespace serialization {\n\ntemplate <>\nstruct Serializer<MyExt> {\n  // Declare as extension type for custom serialization\n  static constexpr TypeId type_id = TypeId::EXT;\n\n  // Main write method - handles null checking and type info\n  static void write(const MyExt &value, WriteContext &ctx, RefMode ref_mode,\n                    bool write_type, bool has_generics = false) {\n    (void)has_generics;\n    write_not_null_ref_flag(ctx, ref_mode);\n    if (write_type) {\n      auto result = ctx.write_any_type_info(\n          static_cast<uint32_t>(TypeId::UNKNOWN),\n          std::type_index(typeid(MyExt)));\n      if (!result.ok()) {\n        ctx.set_error(std::move(result).error());\n        return;\n      }\n    }\n    write_data(value, ctx);\n  }\n\n  // write only the data (no type info)\n  static void write_data(const MyExt &value, WriteContext &ctx) {\n    Serializer<int32_t>::write_data(value.id, ctx);\n  }\n\n  // write data with generics support\n  static void write_data_generic(const MyExt &value, WriteContext &ctx,\n                                 bool has_generics) {\n    (void)has_generics;\n    write_data(value, ctx);\n  }\n\n  // Main read method - handles null checking and type info\n  static MyExt read(ReadContext &ctx, RefMode ref_mode, bool read_type) {\n    bool has_value = read_null_only_flag(ctx, ref_mode);\n    if (ctx.has_error() || !has_value) {\n      return MyExt{};\n    }\n    if (read_type) {\n      const TypeInfo *type_info = ctx.read_any_type_info(ctx.error());\n      if (ctx.has_error()) {\n        return MyExt{};\n      }\n      if (!type_info) {\n        ctx.set_error(Error::type_error("TypeInfo for MyExt not found"));\n        return MyExt{};\n      }\n    }\n    return read_data(ctx);\n  }\n\n  // Read only the data (no type info)\n  static MyExt read_data(ReadContext &ctx) {\n    MyExt value;\n    value.id = Serializer<int32_t>::read_data(ctx);\n    return value;\n  }\n\n  // Read data with generics support\n  static MyExt read_data_generic(ReadContext &ctx, bool has_generics) {\n    (void)has_generics;\n    return read_data(ctx);\n  }\n\n  // Read with pre-resolved type info\n  static MyExt read_with_type_info(ReadContext &ctx, RefMode ref_mode,\n                                   const TypeInfo &type_info) {\n    (void)type_info;\n    return read(ctx, ref_mode, false);\n  }\n};\n\n} // namespace serialization\n} // namespace fory\n'})}),"\n",(0,i.jsx)(t.h2,{id:"required-methods",children:"Required Methods"}),"\n",(0,i.jsx)(t.p,{children:"A custom serializer must implement these static methods:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Method"}),(0,i.jsx)(t.th,{children:"Purpose"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"write"})}),(0,i.jsx)(t.td,{children:"Main serialization entry point with type info"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"write_data"})}),(0,i.jsx)(t.td,{children:"Serialize data only (no type info)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"write_data_generic"})}),(0,i.jsx)(t.td,{children:"Serialize data with generics support"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"read"})}),(0,i.jsx)(t.td,{children:"Main deserialization entry point with type info"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"read_data"})}),(0,i.jsx)(t.td,{children:"Deserialize data only (no type info)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"read_data_generic"})}),(0,i.jsx)(t.td,{children:"Deserialize data with generics support"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.code,{children:"read_with_type_info"})}),(0,i.jsx)(t.td,{children:"Deserialize with pre-resolved TypeInfo"})]})]})]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"type_id"})," constant should be set to ",(0,i.jsx)(t.code,{children:"TypeId::EXT"})," for custom extension types."]}),"\n",(0,i.jsx)(t.h2,{id:"registering-custom-serializers",children:"Registering Custom Serializers"}),"\n",(0,i.jsx)(t.p,{children:"Register your custom serializer with Fory before use:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:'auto fory = Fory::builder().xlang(true).build();\n\n// Register with numeric type ID (must match across languages)\nauto result = fory.register_extension_type<MyExt>(103);\nif (!result.ok()) {\n  std::cerr << "Failed to register: " << result.error().to_string() << std::endl;\n}\n\n// Or register with type name for named type systems\nfory.register_extension_type<MyExt>("my_ext");\n\n// Or with namespace and type name\nfory.register_extension_type<MyExt>("com.example", "MyExt");\n'})}),"\n",(0,i.jsx)(t.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:'#include "fory/serialization/fory.h"\n#include <iostream>\n\nusing namespace fory::serialization;\n\nstruct CustomType {\n  int32_t value;\n  std::string name;\n\n  bool operator==(const CustomType &other) const {\n    return value == other.value && name == other.name;\n  }\n};\n\nnamespace fory {\nnamespace serialization {\n\ntemplate <>\nstruct Serializer<CustomType> {\n  static constexpr TypeId type_id = TypeId::EXT;\n\n  static void write(const CustomType &value, WriteContext &ctx,\n                    RefMode ref_mode, bool write_type, bool has_generics = false) {\n    (void)has_generics;\n    write_not_null_ref_flag(ctx, ref_mode);\n    if (write_type) {\n      auto result = ctx.write_any_type_info(\n          static_cast<uint32_t>(TypeId::UNKNOWN),\n          std::type_index(typeid(CustomType)));\n      if (!result.ok()) {\n        ctx.set_error(std::move(result).error());\n        return;\n      }\n    }\n    write_data(value, ctx);\n  }\n\n  static void write_data(const CustomType &value, WriteContext &ctx) {\n    // write value as varint for compact encoding\n    Serializer<int32_t>::write_data(value.value, ctx);\n    // Delegate string serialization to built-in serializer\n    Serializer<std::string>::write_data(value.name, ctx);\n  }\n\n  static void write_data_generic(const CustomType &value, WriteContext &ctx,\n                                 bool has_generics) {\n    (void)has_generics;\n    write_data(value, ctx);\n  }\n\n  static CustomType read(ReadContext &ctx, RefMode ref_mode, bool read_type) {\n    bool has_value = read_null_only_flag(ctx, ref_mode);\n    if (ctx.has_error() || !has_value) {\n      return CustomType{};\n    }\n    if (read_type) {\n      const TypeInfo *type_info = ctx.read_any_type_info(ctx.error());\n      if (ctx.has_error()) {\n        return CustomType{};\n      }\n      if (!type_info) {\n        ctx.set_error(Error::type_error("TypeInfo for CustomType not found"));\n        return CustomType{};\n      }\n    }\n    return read_data(ctx);\n  }\n\n  static CustomType read_data(ReadContext &ctx) {\n    CustomType value;\n    value.value = Serializer<int32_t>::read_data(ctx);\n    value.name = Serializer<std::string>::read_data(ctx);\n    return value;\n  }\n\n  static CustomType read_data_generic(ReadContext &ctx, bool has_generics) {\n    (void)has_generics;\n    return read_data(ctx);\n  }\n\n  static CustomType read_with_type_info(ReadContext &ctx, RefMode ref_mode,\n                                        const TypeInfo &type_info) {\n    (void)type_info;\n    return read(ctx, ref_mode, false);\n  }\n};\n\n} // namespace serialization\n} // namespace fory\n\nint main() {\n  auto fory = Fory::builder().xlang(true).build();\n  fory.register_extension_type<CustomType>(100);\n\n  CustomType original{42, "test"};\n\n  auto serialized = fory.serialize(original);\n  if (!serialized.ok()) {\n    std::cerr << "Serialization failed" << std::endl;\n    return 1;\n  }\n\n  auto deserialized = fory.deserialize<CustomType>(serialized.value());\n  if (!deserialized.ok()) {\n    std::cerr << "Deserialization failed" << std::endl;\n    return 1;\n  }\n\n  assert(original == deserialized.value());\n  std::cout << "Custom serializer works!" << std::endl;\n  return 0;\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"writecontext-methods",children:"WriteContext Methods"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"WriteContext"})," provides methods for writing data:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"// Primitive types\nctx.write_uint8(value);\nctx.write_int8(value);\nctx.write_uint16(value);\n\n// Variable-length integers (compact encoding)\nctx.write_var_uint32(value);   // Unsigned varint\nctx.write_varint32(value);    // Signed zigzag varint\nctx.write_var_uint64(value);   // Unsigned varint\nctx.write_varint64(value);    // Signed zigzag varint\n\n// Tagged integers (for mixed-size encoding)\nctx.write_tagged_uint64(value);\nctx.write_tagged_int64(value);\n\n// Raw bytes\nctx.write_bytes(data_ptr, length);\n\n// Access underlying buffer for advanced operations\nctx.buffer().write_int32(value);\nctx.buffer().write_float(value);\nctx.buffer().write_double(value);\n"})}),"\n",(0,i.jsx)(t.h2,{id:"readcontext-methods",children:"ReadContext Methods"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"ReadContext"})," provides methods for reading data:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"// Primitive types (use error reference pattern)\nuint8_t u8 = ctx.read_uint8(ctx.error());\nint8_t i8 = ctx.read_int8(ctx.error());\n\n// Variable-length integers\nuint32_t u32 = ctx.read_var_uint32(ctx.error());\nint32_t i32 = ctx.read_varint32(ctx.error());\nuint64_t u64 = ctx.read_var_uint64(ctx.error());\nint64_t i64 = ctx.read_varint64(ctx.error());\n\n// Check for errors after read operations\nif (ctx.has_error()) {\n  return MyType{};  // Return default on error\n}\n\n// Access underlying buffer for advanced operations\nint32_t value = ctx.buffer().read_int32(ctx.error());\nfloat f = ctx.buffer().read_float(ctx.error());\ndouble d = ctx.buffer().read_double(ctx.error());\n"})}),"\n",(0,i.jsx)(t.h2,{id:"delegating-to-built-in-serializers",children:"Delegating to Built-in Serializers"}),"\n",(0,i.jsx)(t.p,{children:"Reuse existing serializers for nested types:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"static void write_data(const MyType &value, WriteContext &ctx) {\n  // Delegate to built-in serializers\n  Serializer<int32_t>::write_data(value.int_field, ctx);\n  Serializer<std::string>::write_data(value.string_field, ctx);\n  Serializer<std::vector<int32_t>>::write_data(value.vec_field, ctx);\n}\n\nstatic MyType read_data(ReadContext &ctx) {\n  MyType value;\n  value.int_field = Serializer<int32_t>::read_data(ctx);\n  value.string_field = Serializer<std::string>::read_data(ctx);\n  value.vec_field = Serializer<std::vector<int32_t>>::read_data(ctx);\n  return value;\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Use variable-length encoding"})," for integers that may be small"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Check errors after read operations"})," using ",(0,i.jsx)(t.code,{children:"ctx.has_error()"})]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Return default values on error"})," to maintain consistent behavior"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Delegate to built-in serializers"})," for standard types"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Match type IDs across languages"})," for cross-language compatibility"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsxs)(t.strong,{children:["Use ",(0,i.jsx)(t.code,{children:"(void)param"})]})," to suppress unused parameter warnings"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"type_registration",children:"Type Registration"})," - Registering serializers"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"basic_serialization",children:"Basic Serialization"})," - Using FORY_STRUCT macro"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"schema_evolution",children:"Schema Evolution"})," - Compatible mode"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"cross_language",children:"Cross-Language"})," - Cross-language serialization"]}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>s});var i=n(67294);const r={},a=i.createContext(r);function s(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);