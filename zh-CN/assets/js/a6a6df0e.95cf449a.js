"use strict";(self.webpackChunkfory_site=self.webpackChunkfory_site||[]).push([[40852],{91118:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>o,frontMatter:()=>r,metadata:()=>d,toc:()=>c});var s=i(85893),t=i(11151);const r={title:"Xlang Serialization Format",sidebar_position:0,id:"xlang_serialization_spec",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},l=void 0,d={id:"specification/xlang_serialization_spec",title:"Xlang Serialization Format",description:"Cross-language Serialization Specification",source:"@site/i18n/zh-CN/docusaurus-plugin-content-docs/version-0.14/specification/xlang_serialization_spec.md",sourceDirName:"specification",slug:"/specification/xlang_serialization_spec",permalink:"/zh-CN/docs/0.14/specification/xlang_serialization_spec",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/fory-site/tree/main/i18n/zh-CN/docusaurus-plugin-content-docs/version-0.14/specification/xlang_serialization_spec.md",tags:[],version:"0.14",sidebarPosition:0,frontMatter:{title:"Xlang Serialization Format",sidebar_position:0,id:"xlang_serialization_spec",license:'Licensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the "License"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n'},sidebar:"specificationSidebar",next:{title:"Java Serialization Format",permalink:"/zh-CN/docs/0.14/specification/java_serialization_spec"}},a={},c=[{value:"Cross-language Serialization Specification",id:"cross-language-serialization-specification",level:2},{value:"Type Systems",id:"type-systems",level:2},{value:"Data Types",id:"data-types",level:3},{value:"Polymorphisms",id:"polymorphisms",level:3},{value:"Type disambiguation",id:"type-disambiguation",level:3},{value:"Type ID",id:"type-id",level:3},{value:"Internal Type ID Table",id:"internal-type-id-table",level:4},{value:"Type ID Encoding for User Types",id:"type-id-encoding-for-user-types",level:4},{value:"Type mapping",id:"type-mapping",level:3},{value:"Spec overview",id:"spec-overview",level:2},{value:"Fory header",id:"fory-header",level:2},{value:"Language IDs",id:"language-ids",level:3},{value:"Meta Start Offset",id:"meta-start-offset",level:3},{value:"Reference Meta",id:"reference-meta",level:2},{value:"Reference Flags",id:"reference-flags",level:3},{value:"Reference Tracking Algorithm",id:"reference-tracking-algorithm",level:3},{value:"Reference ID Assignment",id:"reference-id-assignment",level:3},{value:"When Reference Tracking is Disabled",id:"when-reference-tracking-is-disabled",level:3},{value:"Language-Specific Considerations",id:"language-specific-considerations",level:3},{value:"Type Meta",id:"type-meta",level:2},{value:"Struct Schema consistent",id:"struct-schema-consistent",level:3},{value:"Struct Schema evolution",id:"struct-schema-evolution",level:3},{value:"Type Def",id:"type-def",level:4},{value:"Global binary header",id:"global-binary-header",level:5},{value:"Meta header",id:"meta-header",level:5},{value:"Fields meta",id:"fields-meta",level:5},{value:"Field Header",id:"field-header",level:6},{value:"Field Type Info",id:"field-type-info",level:6},{value:"Field Name",id:"field-name",level:6},{value:"Field order",id:"field-order",level:6},{value:"Extended Type Meta with Inheritance support",id:"extended-type-meta-with-inheritance-support",level:2},{value:"Schema consistent",id:"schema-consistent",level:3},{value:"Schema Evolution",id:"schema-evolution",level:3},{value:"Meta header",id:"meta-header-1",level:4},{value:"Single layer type meta",id:"single-layer-type-meta",level:4},{value:"Other layers type meta",id:"other-layers-type-meta",level:4},{value:"Meta String",id:"meta-string",level:2},{value:"Encoding Type IDs",id:"encoding-type-ids",level:3},{value:"Character Mapping Tables",id:"character-mapping-tables",level:3},{value:"LOWER_SPECIAL (5 bits per character)",id:"lower_special-5-bits-per-character",level:4},{value:"LOWER_UPPER_DIGIT_SPECIAL (6 bits per character)",id:"lower_upper_digit_special-6-bits-per-character",level:4},{value:"Encoding Algorithms",id:"encoding-algorithms",level:3},{value:"LOWER_SPECIAL Encoding",id:"lower_special-encoding",level:4},{value:"FIRST_TO_LOWER_SPECIAL Encoding",id:"first_to_lower_special-encoding",level:4},{value:"ALL_TO_LOWER_SPECIAL Encoding",id:"all_to_lower_special-encoding",level:4},{value:"Encoding Selection Algorithm",id:"encoding-selection-algorithm",level:3},{value:"Meta String Header Format",id:"meta-string-header-format",level:3},{value:"Special Character Sets by Context",id:"special-character-sets-by-context",level:3},{value:"Deduplication",id:"deduplication",level:3},{value:"Value Format",id:"value-format",level:2},{value:"Basic types",id:"basic-types",level:3},{value:"bool",id:"bool",level:4},{value:"int8",id:"int8",level:4},{value:"int16",id:"int16",level:4},{value:"unsigned int32",id:"unsigned-int32",level:4},{value:"unsigned varint32",id:"unsigned-varint32",level:4},{value:"signed int32",id:"signed-int32",level:4},{value:"signed varint32",id:"signed-varint32",level:4},{value:"unsigned int64",id:"unsigned-int64",level:4},{value:"unsigned varint64",id:"unsigned-varint64",level:4},{value:"VarUint36Small",id:"varuint36small",level:4},{value:"signed int64",id:"signed-int64",level:4},{value:"signed varint64",id:"signed-varint64",level:4},{value:"float32",id:"float32",level:4},{value:"float64",id:"float64",level:4},{value:"string",id:"string",level:3},{value:"String Header",id:"string-header",level:4},{value:"Encoding Algorithm",id:"encoding-algorithm",level:4},{value:"Encoding Selection by Language",id:"encoding-selection-by-language",level:4},{value:"Empty String",id:"empty-string",level:4},{value:"duration",id:"duration",level:3},{value:"collection/list",id:"collectionlist",level:3},{value:"Elements Header",id:"elements-header",level:4},{value:"Type Info After Header",id:"type-info-after-header",level:4},{value:"Element Serialization Based on Header",id:"element-serialization-based-on-header",level:4},{value:"elements data",id:"elements-data",level:4},{value:"array",id:"array",level:3},{value:"primitive array",id:"primitive-array",level:4},{value:"Tensor",id:"tensor",level:4},{value:"object array",id:"object-array",level:4},{value:"map",id:"map",level:3},{value:"Map Chunk Format",id:"map-chunk-format",level:4},{value:"KV Header Bits",id:"kv-header-bits",level:4},{value:"Chunk Size",id:"chunk-size",level:4},{value:"Why Chunk-Based Format?",id:"why-chunk-based-format",level:4},{value:"Why serialize chunk by chunk?",id:"why-serialize-chunk-by-chunk",level:4},{value:"enum",id:"enum",level:3},{value:"decimal",id:"decimal",level:3},{value:"struct",id:"struct",level:3},{value:"field order",id:"field-order-1",level:4},{value:"schema consistent",id:"schema-consistent-1",level:4},{value:"Schema evolution",id:"schema-evolution-1",level:4},{value:"Type",id:"type",level:3},{value:"Implementation guidelines",id:"implementation-guidelines",level:2},{value:"How to reduce memory read/write code",id:"how-to-reduce-memory-readwrite-code",level:3},{value:"Fast deserialization for static languages without runtime codegen support",id:"fast-deserialization-for-static-languages-without-runtime-codegen-support",level:3},{value:"Implementation Checklist for New Languages",id:"implementation-checklist-for-new-languages",level:2},{value:"Phase 1: Core Infrastructure",id:"phase-1-core-infrastructure",level:3},{value:"Phase 2: Basic Type Serializers",id:"phase-2-basic-type-serializers",level:3},{value:"Phase 3: Collection Types",id:"phase-3-collection-types",level:3},{value:"Phase 4: Meta String Encoding",id:"phase-4-meta-string-encoding",level:3},{value:"Phase 5: Enum Serialization",id:"phase-5-enum-serialization",level:3},{value:"Phase 6: Struct Serialization",id:"phase-6-struct-serialization",level:3},{value:"Phase 7: Other types",id:"phase-7-other-types",level:3},{value:"Testing Strategy",id:"testing-strategy",level:3},{value:"Language-Specific Implementation Notes",id:"language-specific-implementation-notes",level:2},{value:"Java",id:"java",level:3},{value:"Python",id:"python",level:3},{value:"C++",id:"c",level:3},{value:"Rust",id:"rust",level:3},{value:"Go",id:"go",level:3},{value:"Common Pitfalls",id:"common-pitfalls",level:2}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",h5:"h5",h6:"h6",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"cross-language-serialization-specification",children:"Cross-language Serialization Specification"}),"\n",(0,s.jsx)(n.p,{children:"Apache Fory\u2122 xlang serialization enables automatic cross-language object serialization with support for shared references, circular references, and polymorphism. Unlike traditional serialization frameworks that require IDL definitions and schema compilation, Fory serializes objects directly without any intermediate steps."}),"\n",(0,s.jsx)(n.p,{children:"Key characteristics:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic"}),": No IDL definition, no schema compilation, no manual object-to-protocol conversion"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cross-language"}),": Same binary format works seamlessly across Java, Python, C++, Rust, Go, JavaScript, and more"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reference-aware"}),": Handles shared references and circular references without duplication or infinite recursion"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Polymorphic"}),": Supports object polymorphism with runtime type resolution"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This specification defines the Fory xlang binary format. The format is dynamic rather than static, which enables flexibility and ease of use at the cost of additional complexity in the wire format."}),"\n",(0,s.jsx)(n.h2,{id:"type-systems",children:"Type Systems"}),"\n",(0,s.jsx)(n.h3,{id:"data-types",children:"Data Types"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"bool: a boolean value (true or false)."}),"\n",(0,s.jsx)(n.li,{children:"int8: a 8-bit signed integer."}),"\n",(0,s.jsx)(n.li,{children:"int16: a 16-bit signed integer."}),"\n",(0,s.jsx)(n.li,{children:"int32: a 32-bit signed integer."}),"\n",(0,s.jsx)(n.li,{children:"var_int32: a 32-bit signed integer which use fory var_int32 encoding."}),"\n",(0,s.jsx)(n.li,{children:"int64: a 64-bit signed integer."}),"\n",(0,s.jsx)(n.li,{children:"var_int64: a 64-bit signed integer which use fory PVL encoding."}),"\n",(0,s.jsx)(n.li,{children:"sli_int64: a 64-bit signed integer which use fory SLI encoding."}),"\n",(0,s.jsx)(n.li,{children:"float16: a 16-bit floating point number."}),"\n",(0,s.jsx)(n.li,{children:"float32: a 32-bit floating point number."}),"\n",(0,s.jsx)(n.li,{children:"float64: a 64-bit floating point number including NaN and Infinity."}),"\n",(0,s.jsx)(n.li,{children:"string: a text string encoded using Latin1/UTF16/UTF-8 encoding."}),"\n",(0,s.jsx)(n.li,{children:"enum: a data type consisting of a set of named values. Rust enum with non-predefined field values are not supported as\nan enum."}),"\n",(0,s.jsx)(n.li,{children:"named_enum: an enum whose value will be serialized as the registered name."}),"\n",(0,s.jsxs)(n.li,{children:["struct: a morphic(final) type serialized by Fory Struct serializer. i.e. it doesn't have subclasses. Suppose we're\ndeserializing ",(0,s.jsx)(n.code,{children:"List<SomeClass>"}),", we can save dynamic serializer dispatch since ",(0,s.jsx)(n.code,{children:"SomeClass"})," is morphic(final)."]}),"\n",(0,s.jsx)(n.li,{children:"compatible_struct: a morphic(final) type serialized by Fory compatible Struct serializer."}),"\n",(0,s.jsxs)(n.li,{children:["named_struct: a ",(0,s.jsx)(n.code,{children:"struct"})," whose type mapping will be encoded as a name."]}),"\n",(0,s.jsxs)(n.li,{children:["named_compatible_struct: a ",(0,s.jsx)(n.code,{children:"compatible_struct"})," whose type mapping will be encoded as a name."]}),"\n",(0,s.jsx)(n.li,{children:"ext: a type which will be serialized by a customized serializer."}),"\n",(0,s.jsxs)(n.li,{children:["named_ext: an ",(0,s.jsx)(n.code,{children:"ext"})," type whose type mapping will be encoded as a name."]}),"\n",(0,s.jsx)(n.li,{children:"list: a sequence of objects."}),"\n",(0,s.jsx)(n.li,{children:"set: an unordered set of unique elements."}),"\n",(0,s.jsxs)(n.li,{children:["map: a map of key-value pairs. Mutable types such as ",(0,s.jsx)(n.code,{children:"list/map/set/array"})," are not allowed as key of map."]}),"\n",(0,s.jsx)(n.li,{children:"duration: an absolute length of time, independent of any calendar/timezone, as a count of nanoseconds."}),"\n",(0,s.jsx)(n.li,{children:"timestamp: a point in time, independent of any calendar/timezone, as a count of nanoseconds. The count is relative\nto an epoch at UTC midnight on January 1, 1970."}),"\n",(0,s.jsx)(n.li,{children:"local_date: a naive date without timezone. The count is days relative to an epoch at UTC midnight on Jan 1, 1970."}),"\n",(0,s.jsx)(n.li,{children:"decimal: exact decimal value represented as an integer value in two's complement."}),"\n",(0,s.jsx)(n.li,{children:"binary: an variable-length array of bytes."}),"\n",(0,s.jsxs)(n.li,{children:["array: only allow 1d numeric components. Other arrays will be taken as List. The implementation should support the\ninteroperability between array and list.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"bool_array: one dimensional bool array."}),"\n",(0,s.jsx)(n.li,{children:"int8_array: one dimensional int8 array."}),"\n",(0,s.jsx)(n.li,{children:"int16_array: one dimensional int16 array."}),"\n",(0,s.jsx)(n.li,{children:"int32_array: one dimensional int32 array."}),"\n",(0,s.jsx)(n.li,{children:"int64_array: one dimensional int64 array."}),"\n",(0,s.jsx)(n.li,{children:"float16_array: one dimensional half_float_16 array."}),"\n",(0,s.jsx)(n.li,{children:"float32_array: one dimensional float32 array."}),"\n",(0,s.jsx)(n.li,{children:"float64_array: one dimensional float64 array."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"union: a tagged union type that can hold one of several alternative types. The active alternative is identified by an index."}),"\n",(0,s.jsx)(n.li,{children:"none: represents an empty/unit value with no data (e.g., for empty union alternatives)."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Note:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Unsigned int/long are not added here, since not every language support those types."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"polymorphisms",children:"Polymorphisms"}),"\n",(0,s.jsx)(n.p,{children:"For polymorphism, if one non-final class is registered, and only one subclass is registered, then we can take all\nelements in List/Map have same type, thus reduce runtime check cost."}),"\n",(0,s.jsx)(n.p,{children:"Collection/Array polymorphism are not fully supported, since some languages such as golang have only one collection\ntype. If users want to get exactly the type he passed, he must pass that type when deserializing or annotate that type\nto the field of struct."}),"\n",(0,s.jsx)(n.h3,{id:"type-disambiguation",children:"Type disambiguation"}),"\n",(0,s.jsx)(n.p,{children:"Due to differences between type systems of languages, those types can't be mapped one-to-one between languages. When\ndeserializing, Fory use the target data structure type and the data type in the data jointly to determine how to\ndeserialize and populate the target data structure. For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"class Foo {\n  int[] intArray;\n  Object[] objects;\n  List<Object> objectList;\n}\n\nclass Foo2 {\n  int[] intArray;\n  List<Object> objects;\n  List<Object> objectList;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"intArray"})," has an ",(0,s.jsx)(n.code,{children:"int32_array"})," type. But both ",(0,s.jsx)(n.code,{children:"objects"})," and ",(0,s.jsx)(n.code,{children:"objectList"})," fields in the serialize data have ",(0,s.jsx)(n.code,{children:"list"})," data\ntype. When deserializing, the implementation will create an ",(0,s.jsx)(n.code,{children:"Object"})," array for ",(0,s.jsx)(n.code,{children:"objects"}),", but create a ",(0,s.jsx)(n.code,{children:"ArrayList"}),"\nfor ",(0,s.jsx)(n.code,{children:"objectList"})," to populate its elements. And the serialized data of ",(0,s.jsx)(n.code,{children:"Foo"})," can be deserialized into ",(0,s.jsx)(n.code,{children:"Foo2"})," too."]}),"\n",(0,s.jsx)(n.p,{children:"Users can also provide meta hints for fields of a type, or the type whole. Here is an example in java which use\nannotation to provide such information."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"@ForyObject(fieldsNullable = false, trackingRef = false)\nclass Foo {\n  @ForyField(trackingRef = false)\n  int[] intArray;\n  @ForyField(polymorphic = true)\n  Object object;\n  @ForyField(tagId = 1, nullable = true)\n  List<Object> objectList;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Such information can be provided in other languages too:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"cpp: use macro and template."}),"\n",(0,s.jsx)(n.li,{children:"golang: use struct tag."}),"\n",(0,s.jsx)(n.li,{children:"python: use typehint."}),"\n",(0,s.jsx)(n.li,{children:"rust: use macro."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"type-id",children:"Type ID"}),"\n",(0,s.jsxs)(n.p,{children:["All internal data types are expressed using an ID in range ",(0,s.jsx)(n.code,{children:"0~64"}),". Users can use IDs in range ",(0,s.jsx)(n.code,{children:"0~8192"})," for registering their\ncustom types (struct/ext/enum). User type IDs are in a separate namespace and combined with internal type IDs via bit shifting:\n",(0,s.jsx)(n.code,{children:"(user_type_id << 8) | internal_type_id"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"internal-type-id-table",children:"Internal Type ID Table"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Type ID"}),(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"UNKNOWN"}),(0,s.jsx)(n.td,{children:"Unknown type, used for dynamic typing"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"BOOL"}),(0,s.jsx)(n.td,{children:"Boolean value"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"INT8"}),(0,s.jsx)(n.td,{children:"8-bit signed integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"INT16"}),(0,s.jsx)(n.td,{children:"16-bit signed integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"4"}),(0,s.jsx)(n.td,{children:"INT32"}),(0,s.jsx)(n.td,{children:"32-bit signed integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"5"}),(0,s.jsx)(n.td,{children:"VAR_INT32"}),(0,s.jsx)(n.td,{children:"Variable-length encoded 32-bit signed integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"6"}),(0,s.jsx)(n.td,{children:"INT64"}),(0,s.jsx)(n.td,{children:"64-bit signed integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"7"}),(0,s.jsx)(n.td,{children:"VAR_INT64"}),(0,s.jsx)(n.td,{children:"Variable-length encoded 64-bit signed integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"8"}),(0,s.jsx)(n.td,{children:"SLI_INT64"}),(0,s.jsx)(n.td,{children:"Small Long as Int encoded 64-bit signed integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"9"}),(0,s.jsx)(n.td,{children:"FLOAT16"}),(0,s.jsx)(n.td,{children:"16-bit floating point (half precision)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"10"}),(0,s.jsx)(n.td,{children:"FLOAT32"}),(0,s.jsx)(n.td,{children:"32-bit floating point (single precision)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"11"}),(0,s.jsx)(n.td,{children:"FLOAT64"}),(0,s.jsx)(n.td,{children:"64-bit floating point (double precision)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"12"}),(0,s.jsx)(n.td,{children:"STRING"}),(0,s.jsx)(n.td,{children:"UTF-8/UTF-16/Latin1 encoded string"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"13"}),(0,s.jsx)(n.td,{children:"ENUM"}),(0,s.jsx)(n.td,{children:"Enum registered by numeric ID"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"14"}),(0,s.jsx)(n.td,{children:"NAMED_ENUM"}),(0,s.jsx)(n.td,{children:"Enum registered by namespace + type name"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"15"}),(0,s.jsx)(n.td,{children:"STRUCT"}),(0,s.jsx)(n.td,{children:"Struct registered by numeric ID (schema consistent)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"16"}),(0,s.jsx)(n.td,{children:"COMPATIBLE_STRUCT"}),(0,s.jsx)(n.td,{children:"Struct with schema evolution support (by ID)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"17"}),(0,s.jsx)(n.td,{children:"NAMED_STRUCT"}),(0,s.jsx)(n.td,{children:"Struct registered by namespace + type name"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"18"}),(0,s.jsx)(n.td,{children:"NAMED_COMPATIBLE_STRUCT"}),(0,s.jsx)(n.td,{children:"Struct with schema evolution (by name)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"19"}),(0,s.jsx)(n.td,{children:"EXT"}),(0,s.jsx)(n.td,{children:"Extension type registered by numeric ID"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"20"}),(0,s.jsx)(n.td,{children:"NAMED_EXT"}),(0,s.jsx)(n.td,{children:"Extension type registered by namespace + type name"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"21"}),(0,s.jsx)(n.td,{children:"LIST"}),(0,s.jsx)(n.td,{children:"Ordered collection (List, Array, Vector)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"22"}),(0,s.jsx)(n.td,{children:"SET"}),(0,s.jsx)(n.td,{children:"Unordered collection of unique elements"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"23"}),(0,s.jsx)(n.td,{children:"MAP"}),(0,s.jsx)(n.td,{children:"Key-value mapping"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"24"}),(0,s.jsx)(n.td,{children:"DURATION"}),(0,s.jsx)(n.td,{children:"Time duration (seconds + nanoseconds)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"25"}),(0,s.jsx)(n.td,{children:"TIMESTAMP"}),(0,s.jsx)(n.td,{children:"Point in time (nanoseconds since epoch)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"26"}),(0,s.jsx)(n.td,{children:"LOCAL_DATE"}),(0,s.jsx)(n.td,{children:"Date without timezone (days since epoch)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"27"}),(0,s.jsx)(n.td,{children:"DECIMAL"}),(0,s.jsx)(n.td,{children:"Arbitrary precision decimal"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"28"}),(0,s.jsx)(n.td,{children:"BINARY"}),(0,s.jsx)(n.td,{children:"Raw binary data"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"29"}),(0,s.jsx)(n.td,{children:"ARRAY"}),(0,s.jsx)(n.td,{children:"Generic array type"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"30"}),(0,s.jsx)(n.td,{children:"BOOL_ARRAY"}),(0,s.jsx)(n.td,{children:"1D boolean array"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"31"}),(0,s.jsx)(n.td,{children:"INT8_ARRAY"}),(0,s.jsx)(n.td,{children:"1D int8 array"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"32"}),(0,s.jsx)(n.td,{children:"INT16_ARRAY"}),(0,s.jsx)(n.td,{children:"1D int16 array"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"33"}),(0,s.jsx)(n.td,{children:"INT32_ARRAY"}),(0,s.jsx)(n.td,{children:"1D int32 array"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"34"}),(0,s.jsx)(n.td,{children:"INT64_ARRAY"}),(0,s.jsx)(n.td,{children:"1D int64 array"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"35"}),(0,s.jsx)(n.td,{children:"FLOAT16_ARRAY"}),(0,s.jsx)(n.td,{children:"1D float16 array"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"36"}),(0,s.jsx)(n.td,{children:"FLOAT32_ARRAY"}),(0,s.jsx)(n.td,{children:"1D float32 array"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"37"}),(0,s.jsx)(n.td,{children:"FLOAT64_ARRAY"}),(0,s.jsx)(n.td,{children:"1D float64 array"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"38"}),(0,s.jsx)(n.td,{children:"UNION"}),(0,s.jsx)(n.td,{children:"Tagged union type (one of several alternatives)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"39"}),(0,s.jsx)(n.td,{children:"NONE"}),(0,s.jsx)(n.td,{children:"Empty/unit type (no data)"})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"type-id-encoding-for-user-types",children:"Type ID Encoding for User Types"}),"\n",(0,s.jsx)(n.p,{children:"When registering user types (struct/ext/enum), the full type ID combines user ID and internal type ID:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Full Type ID = (user_type_id << 8) | internal_type_id\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"User ID"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Internal ID"}),(0,s.jsx)(n.th,{children:"Full Type ID"}),(0,s.jsx)(n.th,{children:"Decimal"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"STRUCT"}),(0,s.jsx)(n.td,{children:"15"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"(0 << 8) | 15"})}),(0,s.jsx)(n.td,{children:"15"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"ENUM"}),(0,s.jsx)(n.td,{children:"13"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"(0 << 8) | 13"})}),(0,s.jsx)(n.td,{children:"13"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"STRUCT"}),(0,s.jsx)(n.td,{children:"15"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"(1 << 8) | 15"})}),(0,s.jsx)(n.td,{children:"271"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"COMPATIBLE_STRUCT"}),(0,s.jsx)(n.td,{children:"16"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"(1 << 8) | 16"})}),(0,s.jsx)(n.td,{children:"272"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"NAMED_STRUCT"}),(0,s.jsx)(n.td,{children:"17"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"(2 << 8) | 17"})}),(0,s.jsx)(n.td,{children:"529"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"When reading type IDs:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Extract internal type: ",(0,s.jsx)(n.code,{children:"internal_type_id = full_type_id & 0xFF"})]}),"\n",(0,s.jsxs)(n.li,{children:["Extract user type ID: ",(0,s.jsx)(n.code,{children:"user_type_id = full_type_id >> 8"})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"type-mapping",children:"Type mapping"}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/zh-CN/docs/0.14/specification/xlang_type_mapping",children:"Type mapping"})]}),"\n",(0,s.jsx)(n.h2,{id:"spec-overview",children:"Spec overview"}),"\n",(0,s.jsx)(n.p,{children:"Here is the overall format:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| fory header | object ref meta | object type meta | object value data |\n"})}),"\n",(0,s.jsx)(n.p,{children:"The data are serialized using little endian byte order overall. If bytes swap is costly for some object,\nFory will write the byte order for that object into the data instead of converting it to little endian."}),"\n",(0,s.jsx)(n.h2,{id:"fory-header",children:"Fory header"}),"\n",(0,s.jsx)(n.p,{children:"Fory header format for xlang serialization:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"|    2 bytes   |        1 byte bitmap           |   1 byte   |          optional 4 bytes          |\n+--------------+--------------------------------+------------+------------------------------------+\n| magic number |  4 bits reserved | 4 bits meta |  language  | unsigned int for meta start offset |\n"})}),"\n",(0,s.jsx)(n.p,{children:"Detailed byte layout:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Byte 0-1: Magic number (0x62d4) - little endian\nByte 2:   Bitmap flags\n          - Bit 0: null flag (0x01)\n          - Bit 1: endian flag (0x02)\n          - Bit 2: xlang flag (0x04)\n          - Bit 3: oob flag (0x08)\n          - Bits 4-7: reserved\nByte 3:   Language ID (only present when xlang flag is set)\nByte 4-7: Meta start offset (only present when meta share mode is enabled)\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"magic number"}),": ",(0,s.jsx)(n.code,{children:"0x62d4"})," (2 bytes, little endian) - used to identify fory xlang serialization protocol."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"null flag"})," (bit 0): 1 when object is null, 0 otherwise. If an object is null, only this flag and endian flag are set."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"endian flag"})," (bit 1): 1 when data is encoded by little endian, 0 for big endian. Modern implementations always use little endian."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"xlang flag"})," (bit 2): 1 when serialization uses Fory xlang format, 0 when serialization uses Fory language-native format."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"oob flag"})," (bit 3): 1 when out-of-band serialization is enabled (BufferCallback is not null), 0 otherwise."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"language"}),": 1 byte indicating the source language. This allows deserializers to optimize for specific language characteristics."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"language-ids",children:"Language IDs"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Language"}),(0,s.jsx)(n.th,{children:"ID"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"XLANG"}),(0,s.jsx)(n.td,{children:"0"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"JAVA"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"PYTHON"}),(0,s.jsx)(n.td,{children:"2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"CPP"}),(0,s.jsx)(n.td,{children:"3"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"GO"}),(0,s.jsx)(n.td,{children:"4"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"JAVASCRIPT"}),(0,s.jsx)(n.td,{children:"5"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"RUST"}),(0,s.jsx)(n.td,{children:"6"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"DART"}),(0,s.jsx)(n.td,{children:"7"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"meta-start-offset",children:"Meta Start Offset"}),"\n",(0,s.jsxs)(n.p,{children:["If compatible mode is enabled, an uncompressed unsigned int32 (4 bytes, little endian) is appended to indicate the start offset of metadata. During serialization, this is initially written as a placeholder (e.g., ",(0,s.jsx)(n.code,{children:"-1"})," or ",(0,s.jsx)(n.code,{children:"0"}),"), then updated after all objects are serialized and metadata is collected."]}),"\n",(0,s.jsx)(n.h2,{id:"reference-meta",children:"Reference Meta"}),"\n",(0,s.jsx)(n.p,{children:"Reference tracking handles whether the object is null, and whether to track reference for the object by writing\ncorresponding flags and maintaining internal state."}),"\n",(0,s.jsx)(n.h3,{id:"reference-flags",children:"Reference Flags"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Flag"}),(0,s.jsx)(n.th,{children:"Byte Value (int8)"}),(0,s.jsx)(n.th,{children:"Hex"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"NULL FLAG"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"-3"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"0xFD"})}),(0,s.jsx)(n.td,{children:"Object is null. No further bytes are written for this object."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"REF FLAG"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"-2"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"0xFE"})}),(0,s.jsx)(n.td,{children:"Object was already serialized. Followed by unsigned varint32 reference ID."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"NOT_NULL VALUE FLAG"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"-1"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"0xFF"})}),(0,s.jsx)(n.td,{children:"Object is non-null but reference tracking is disabled for this type. Object data follows immediately."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"REF VALUE FLAG"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"0"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"0x00"})}),(0,s.jsx)(n.td,{children:"Object is referencable and this is its first occurrence. Object data follows. Assigns next reference ID."})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"reference-tracking-algorithm",children:"Reference Tracking Algorithm"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Writing:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function write_ref_or_null(buffer, obj):\n    if obj is null:\n        buffer.write_int8(NULL_FLAG)      // -3\n        return true  // done, no more data to write\n\n    if reference_tracking_enabled:\n        ref_id = lookup_written_objects(obj)\n        if ref_id exists:\n            buffer.write_int8(REF_FLAG)   // -2\n            buffer.write_varuint32(ref_id)\n            return true  // done, reference written\n        else:\n            buffer.write_int8(REF_VALUE_FLAG)  // 0\n            add_to_written_objects(obj, next_ref_id++)\n            return false  // continue to serialize object data\n    else:\n        buffer.write_int8(NOT_NULL_VALUE_FLAG)  // -1\n        return false  // continue to serialize object data\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Reading:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function read_ref_or_null(buffer):\n    flag = buffer.read_int8()\n    switch flag:\n        case NULL_FLAG (-3):\n            return (null, true)  // null object, done\n        case REF_FLAG (-2):\n            ref_id = buffer.read_varuint32()\n            obj = get_from_read_objects(ref_id)\n            return (obj, true)  // referenced object, done\n        case NOT_NULL_VALUE_FLAG (-1):\n            return (null, false)  // non-null, continue reading\n        case REF_VALUE_FLAG (0):\n            reserve_ref_slot()  // will be filled after reading\n            return (null, false)  // non-null, continue reading\n"})}),"\n",(0,s.jsx)(n.h3,{id:"reference-id-assignment",children:"Reference ID Assignment"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Reference IDs are assigned sequentially starting from ",(0,s.jsx)(n.code,{children:"0"})]}),"\n",(0,s.jsxs)(n.li,{children:["The ID is assigned when ",(0,s.jsx)(n.code,{children:"REF_VALUE_FLAG"})," is written (first occurrence)"]}),"\n",(0,s.jsx)(n.li,{children:"Objects are stored in a list/map indexed by their reference ID"}),"\n",(0,s.jsx)(n.li,{children:"For reading, a placeholder slot is reserved before deserializing the object, then filled after"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"when-reference-tracking-is-disabled",children:"When Reference Tracking is Disabled"}),"\n",(0,s.jsxs)(n.p,{children:["When reference tracking is disabled globally or for specific types, only the ",(0,s.jsx)(n.code,{children:"NULL"})," and ",(0,s.jsx)(n.code,{children:"NOT_NULL VALUE"})," flags\nwill be used for reference meta. This reduces overhead for types that are known not to have references."]}),"\n",(0,s.jsx)(n.h3,{id:"language-specific-considerations",children:"Language-Specific Considerations"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Languages with nullable and reference types by default (Java, Python, JavaScript):"})}),"\n",(0,s.jsx)(n.p,{children:"In xlang mode, for cross-language compatibility:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["All fields are treated as ",(0,s.jsx)(n.strong,{children:"not-null"})," by default"]}),"\n",(0,s.jsxs)(n.li,{children:["Reference tracking is ",(0,s.jsx)(n.strong,{children:"disabled"})," by default"]}),"\n",(0,s.jsx)(n.li,{children:"Users can explicitly mark fields as nullable or enable reference tracking via annotations"}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Optional"})," types (e.g., ",(0,s.jsx)(n.code,{children:"java.util.Optional"}),", ",(0,s.jsx)(n.code,{children:"typing.Optional"}),") are treated as nullable"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Annotation examples:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// Java: use @ForyField annotation\npublic class MyClass {\n    @ForyField(nullable = true, ref = true)\n    private Object refField;\n\n    @ForyField(nullable = false)\n    private String requiredField;\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# Python: use typing with fory field descriptors\nfrom pyfory import Fory, ForyField\n\nclass MyClass:\n    ref_field: ForyField(SomeType, nullable=True, ref=True)\n    required_field: ForyField(str, nullable=False)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Languages with non-nullable types by default:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Language"}),(0,s.jsx)(n.th,{children:"Null Representation"}),(0,s.jsx)(n.th,{children:"Reference Tracking Support"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Rust"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Option::None"})}),(0,s.jsxs)(n.td,{children:["Via ",(0,s.jsx)(n.code,{children:"Rc<T>"}),", ",(0,s.jsx)(n.code,{children:"Arc<T>"}),", ",(0,s.jsx)(n.code,{children:"Weak<T>"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"C++"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"std::nullopt"}),", ",(0,s.jsx)(n.code,{children:"nullptr"})]}),(0,s.jsxs)(n.td,{children:["Via ",(0,s.jsx)(n.code,{children:"std::shared_ptr<T>"}),", ",(0,s.jsx)(n.code,{children:"weak_ptr<T>"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Go"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"nil"})," interface/pointer"]}),(0,s.jsx)(n.td,{children:"Via pointer/interface types"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Important:"})," For languages like Rust that don't have implicit reference semantics, reference tracking must use\nexplicit smart pointers (",(0,s.jsx)(n.code,{children:"Rc"}),", ",(0,s.jsx)(n.code,{children:"Arc"}),")."]}),"\n",(0,s.jsx)(n.h2,{id:"type-meta",children:"Type Meta"}),"\n",(0,s.jsx)(n.p,{children:"For every type to be serialized, it have a type id to indicate its type."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"basic types: the type id"}),"\n",(0,s.jsxs)(n.li,{children:["enum:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Type.ENUM"})," + registered id"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Type.NAMED_ENUM"})," + registered namespace+typename"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["list: ",(0,s.jsx)(n.code,{children:"Type.List"})]}),"\n",(0,s.jsxs)(n.li,{children:["set: ",(0,s.jsx)(n.code,{children:"Type.SET"})]}),"\n",(0,s.jsxs)(n.li,{children:["map: ",(0,s.jsx)(n.code,{children:"Type.MAP"})]}),"\n",(0,s.jsxs)(n.li,{children:["ext:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Type.EXT"})," + registered id"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Type.NAMED_EXT"})," + registered namespace+typename"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["struct:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Type.STRUCT"})," + struct meta"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Type.NAMED_STRUCT"})," + struct meta"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Every type must be registered with an ID or name first. The registration can be used for security check and type\nidentification."}),"\n",(0,s.jsx)(n.p,{children:"Struct is a special type, depending whether schema compatibility is enabled, Fory will write struct meta\ndifferently."}),"\n",(0,s.jsx)(n.h3,{id:"struct-schema-consistent",children:"Struct Schema consistent"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If schema consistent mode is enabled globally when creating fory, type meta will be written as a fory unsigned varint\nof ",(0,s.jsx)(n.code,{children:"type_id"}),". Schema evolution related meta will be ignored."]}),"\n",(0,s.jsxs)(n.li,{children:["If schema evolution mode is enabled globally when creating fory, and current class is configured to use schema\nconsistent mode like ",(0,s.jsx)(n.code,{children:"struct"})," vs ",(0,s.jsx)(n.code,{children:"table"})," in flatbuffers:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Type meta will be add to ",(0,s.jsx)(n.code,{children:"captured_type_defs"}),": ",(0,s.jsx)(n.code,{children:"captured_type_defs[type def stub] = map size"})," ahead when\nregistering type."]}),"\n",(0,s.jsxs)(n.li,{children:["Get index of the meta in ",(0,s.jsx)(n.code,{children:"captured_type_defs"}),", write that index as ",(0,s.jsx)(n.code,{children:"| unsigned varint: index |"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"struct-schema-evolution",children:"Struct Schema evolution"}),"\n",(0,s.jsx)(n.p,{children:"If schema evolution mode is enabled globally when creating fory, and enabled for current type, type meta will be written\nusing one of the following mode. Which mode to use is configured when creating fory."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Normal mode(meta share not enabled):"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If type meta hasn't been written before, add ",(0,s.jsx)(n.code,{children:"type def"}),"\nto ",(0,s.jsx)(n.code,{children:"captured_type_defs"}),": ",(0,s.jsx)(n.code,{children:"captured_type_defs[type def] = map size"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Get index of the meta in ",(0,s.jsx)(n.code,{children:"captured_type_defs"}),", write that index as ",(0,s.jsx)(n.code,{children:"| unsigned varint: index |"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["After finished the serialization of the object graph, fory will start to write ",(0,s.jsx)(n.code,{children:"captured_type_defs"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Firstly, set current to ",(0,s.jsx)(n.code,{children:"meta start offset"})," of fory header"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Then write ",(0,s.jsx)(n.code,{children:"captured_type_defs"})," one by one:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"buffer.write_var_uint32(len(writting_type_defs) - len(schema_consistent_type_def_stubs))\nfor type_meta in writting_type_defs:\n    if not type_meta.is_stub():\n        type_meta.write_type_def(buffer)\nwriting_type_defs = copy(schema_consistent_type_def_stubs)\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Meta share mode: the writing steps are same as the normal mode, but ",(0,s.jsx)(n.code,{children:"captured_type_defs"})," will be shared across\nmultiple serializations of different objects. For example, suppose we have a batch to serialize:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"captured_type_defs = {}\nstream = ...\n# add `Type1` to `captured_type_defs` and write `Type1`\nfory.serialize(stream, [Type1()])\n# add `Type2` to `captured_type_defs` and write `Type2`, `Type1` is written before.\nfory.serialize(stream, [Type1(), Type2()])\n# `Type1` and `Type2` are written before, no need to write meta.\nfory.serialize(stream, [Type1(), Type2()])\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Streaming mode(streaming mode doesn't support meta share):"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"If type meta hasn't been written before, the data will be written as:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| unsigned varint: 0b11111111 | type def |\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"If type meta has been written before, the data will be written as:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| unsigned varint: written index << 1 |\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"written index"})," is the id in ",(0,s.jsx)(n.code,{children:"captured_type_defs"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["With this mode, ",(0,s.jsx)(n.code,{children:"meta start offset"})," can be omitted."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"The normal mode and meta share mode will forbid streaming writing since it needs to look back for update the start\noffset after the whole object graph writing and meta collecting is finished. Only in this way we can ensure\ndeserialization failure in meta share mode doesn't lost shared meta."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"type-def",children:"Type Def"}),"\n",(0,s.jsx)(n.p,{children:"Here we mainly describe the meta layout for schema evolution mode:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"|    8 bytes header    |   variable bytes   |  variable bytes   |\n+----------------------+--------------------+-------------------+\n| global binary header |    meta header     |    fields meta    |\n"})}),"\n",(0,s.jsx)(n.p,{children:"For languages which support inheritance, if parent class and subclass has fields with same name, using field in\nsubclass."}),"\n",(0,s.jsx)(n.h5,{id:"global-binary-header",children:"Global binary header"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"50 bits hash + 1bit compress flag + write fields meta + 12 bits meta size"}),". Right is the lower bits."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["lower 12 bits are used to encode meta size. If meta size ",(0,s.jsx)(n.code,{children:">= 0b1111_1111_1111"}),", then write\n",(0,s.jsx)(n.code,{children:"meta_ size - 0b1111_1111_1111"})," next."]}),"\n",(0,s.jsx)(n.li,{children:"13rd bit is used to indicate whether to write fields meta. When this class is schema-consistent or use registered\nserializer, fields meta will be skipped. Class Meta will be used for share namespace + type name only."}),"\n",(0,s.jsx)(n.li,{children:"14rd bit is used to indicate whether meta is compressed."}),"\n",(0,s.jsxs)(n.li,{children:["Other 50 bits is used to store the unique hash of ",(0,s.jsx)(n.code,{children:"flags + all layers class meta"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h5,{id:"meta-header",children:"Meta header"}),"\n",(0,s.jsx)(n.p,{children:"Meta header is a 8 bits number value."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Lowest 5 digits ",(0,s.jsx)(n.code,{children:"0b00000~0b11110"})," are used to record num fields. ",(0,s.jsx)(n.code,{children:"0b11111"})," is preserved to indicate that Fory need to\nread more bytes for length using Fory unsigned int encoding. Note that num_fields is the number of compatible fields.\nUsers can use tag id to mark some fields as compatible fields in schema consistent context. In such cases, schema\nconsistent fields will be serialized first, then compatible fields will be serialized next. At deserialization,\nFory will use fields info of those fields which aren't annotated by tag id for deserializing schema consistent\nfields, then use fields info in meta for deserializing compatible fields."]}),"\n",(0,s.jsx)(n.li,{children:"The 6th bit: 0 for registered by id, 1 for registered by name."}),"\n",(0,s.jsx)(n.li,{children:"Remaining 2 bits are reserved for future extension."}),"\n"]}),"\n",(0,s.jsx)(n.h5,{id:"fields-meta",children:"Fields meta"}),"\n",(0,s.jsx)(n.p,{children:"Format:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"|   field info: variable bytes    | variable bytes  | ... |\n+---------------------------------+-----------------+-----+\n| header + type info + field name | next field info | ... |\n"})}),"\n",(0,s.jsx)(n.h6,{id:"field-header",children:"Field Header"}),"\n",(0,s.jsx)(n.p,{children:"Field Header is 8 bits, annotation can be used to provide more specific info. If annotation not exists, fory will infer\nthose info automatically."}),"\n",(0,s.jsx)(n.p,{children:"The format for field header is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"2 bits field name encoding + 4 bits size + nullability flag + ref tracking flag\n"})}),"\n",(0,s.jsx)(n.p,{children:"Detailed spec:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["2 bits field name encoding:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["encoding: ",(0,s.jsx)(n.code,{children:"UTF8/ALL_TO_LOWER_SPECIAL/LOWER_UPPER_DIGIT_SPECIAL/TAG_ID"})]}),"\n",(0,s.jsxs)(n.li,{children:["If tag id is used, field name will be written by an unsigned varint tag id, and 2 bits encoding will be ",(0,s.jsx)(n.code,{children:"11"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["size of field name:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"4 bits size: 0~14"})," will be used to indicate length ",(0,s.jsx)(n.code,{children:"1~15"}),", the value ",(0,s.jsx)(n.code,{children:"15"})," indicates to read more bytes,\nthe encoding will encode ",(0,s.jsx)(n.code,{children:"size - 15"})," as a varint next."]}),"\n",(0,s.jsxs)(n.li,{children:["If encoding is ",(0,s.jsx)(n.code,{children:"TAG_ID"}),", then num_bytes of field name will be used to store tag id."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"ref tracking: when set to 1, ref tracking will be enabled for this field."}),"\n",(0,s.jsx)(n.li,{children:"nullability: when set to 1, this field can be null."}),"\n"]}),"\n",(0,s.jsx)(n.h6,{id:"field-type-info",children:"Field Type Info"}),"\n",(0,s.jsx)(n.p,{children:"Field type info is written as unsigned int8. Detailed id spec is:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["For struct registered by id, it will be ",(0,s.jsx)(n.code,{children:"Type.STRUCT"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["For struct registered by name, it will be ",(0,s.jsx)(n.code,{children:"Type.NAMED_STRUCT"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["For enum registered by id, it will be ",(0,s.jsx)(n.code,{children:"Type.ENUM"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["For enum registered by name, it will be ",(0,s.jsx)(n.code,{children:"Type.NAMED_ENUM"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["For ext type registered by id, it will be ",(0,s.jsx)(n.code,{children:"Type.EXT"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["For ext type registered by name, it will be ",(0,s.jsx)(n.code,{children:"Type.NAMED_EXT"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["For list/set type, it will be written as ",(0,s.jsx)(n.code,{children:"Type.LIST/SET"}),", then write element type recursively."]}),"\n",(0,s.jsxs)(n.li,{children:["For 1D primitive array type, it will be written as ",(0,s.jsx)(n.code,{children:"Type.XXX_ARRAY"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["For multi-dimensional primitive array type with same size on each dim, it will be written as ",(0,s.jsx)(n.code,{children:"Type.TENSOR"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["For other array type, it will be written as ",(0,s.jsx)(n.code,{children:"Type.LIST"}),", then write element type recursively."]}),"\n",(0,s.jsxs)(n.li,{children:["For map type, it will be written as ",(0,s.jsx)(n.code,{children:"Type.MAP"}),", then write key and value type recursively."]}),"\n",(0,s.jsx)(n.li,{children:"For other types supported by fory directly, it will be fory type id for that type."}),"\n",(0,s.jsxs)(n.li,{children:["For other types not determined at compile time, write ",(0,s.jsx)(n.code,{children:"Type.UNKNOWN"})," instead. For such types, actual type\nwill be written when serializing such field values."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Polymorphism spec:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"struct/named_struct/ext/named_ext"})," are taken as polymorphic, the meta for those types are written separately\ninstead of inlining here to reduce meta space cost if object of this type is serialized in current object graph\nmultiple times, and the field value may be null too."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"enum"})," is taken as morphic, if deserialization doesn't have this field, or the type is not enum, enum value\nwill be skipped."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"list/map/set"})," are taken as morphic, when serializing values of those type, the concrete types won't be written\nagain."]}),"\n",(0,s.jsx)(n.li,{children:"Other types that fory supported are taken as morphic too."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"List/Set/Map nested type spec:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"list"}),": ",(0,s.jsx)(n.code,{children:"| list type id | nested type id << 2 + nullability flag + ref tracking flag | ... multi-layer type info |"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"set"}),": ",(0,s.jsx)(n.code,{children:"| set type id | nested type id << 2 + nullability flag + ref tracking flag | ... multi-layer type info |"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"map"}),": ",(0,s.jsx)(n.code,{children:"| set type id | key type info | value type info |"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Key type format: ",(0,s.jsx)(n.code,{children:"| nested type id << 2 + nullability flag + ref tracking flag | ... multi-layer type info |"})]}),"\n",(0,s.jsxs)(n.li,{children:["Value type format: ",(0,s.jsx)(n.code,{children:"| nested type id << 2 + nullability flag + ref tracking flag | ... multi-layer type info |"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h6,{id:"field-name",children:"Field Name"}),"\n",(0,s.jsx)(n.p,{children:"If tag id is set, tag id will be used instead. Otherwise meta string of field name will be written instead."}),"\n",(0,s.jsx)(n.h6,{id:"field-order",children:"Field order"}),"\n",(0,s.jsx)(n.p,{children:"Field order are left as implementation details, which is not exposed to specification, the deserialization need to\nresort fields based on Fory fields sort algorithms. In this way, fory can compute statistics for field names or types and\nusing a more compact encoding."}),"\n",(0,s.jsx)(n.h2,{id:"extended-type-meta-with-inheritance-support",children:"Extended Type Meta with Inheritance support"}),"\n",(0,s.jsx)(n.p,{children:"If one want to support inheritance for struct, one can implement following spec."}),"\n",(0,s.jsx)(n.h3,{id:"schema-consistent",children:"Schema consistent"}),"\n",(0,s.jsx)(n.p,{children:"Fields are serialized from parent type to leaf type. Fields are sorted using fory struct fields sort algorithms."}),"\n",(0,s.jsx)(n.h3,{id:"schema-evolution",children:"Schema Evolution"}),"\n",(0,s.jsx)(n.p,{children:"Meta layout for schema evolution mode:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"|    8 bytes header    | variable bytes | variable bytes |   variable bytes   |   variable bytes   |\n+----------------------+----------------+----------------+--------------------+--------------------+\n| global binary header |  meta header   |  fields meta   | parent meta header | parent fields meta |\n"})}),"\n",(0,s.jsx)(n.h4,{id:"meta-header-1",children:"Meta header"}),"\n",(0,s.jsx)(n.p,{children:"Meta header is a 64 bits number value encoded in little endian order."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Lowest 4 digits ",(0,s.jsx)(n.code,{children:"0b0000~0b1110"})," are used to record num classes. ",(0,s.jsx)(n.code,{children:"0b1111"})," is preserved to indicate that Fory need to\nread more bytes for length using Fory unsigned int encoding. If current type doesn't has parent type, or parent\ntype doesn't have fields to serialize, or we're in a context which serialize fields of current type\nonly, num classes will be 1."]}),"\n",(0,s.jsx)(n.li,{children:"The 5th bit is used to indicate whether this type needs schema evolution."}),"\n",(0,s.jsxs)(n.li,{children:["Other 56 bits are used to store the unique hash of ",(0,s.jsx)(n.code,{children:"flags + all layers type meta"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"single-layer-type-meta",children:"Single layer type meta"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| unsigned varint | var uint |  field info: variable bytes   | variable bytes  | ... |\n+-----------------+----------+-------------------------------+-----------------+-----+\n|   num_fields    | type id  | header + type id + field name | next field info | ... |\n"})}),"\n",(0,s.jsx)(n.h4,{id:"other-layers-type-meta",children:"Other layers type meta"}),"\n",(0,s.jsx)(n.p,{children:"Same encoding algorithm as the previous layer."}),"\n",(0,s.jsx)(n.h2,{id:"meta-string",children:"Meta String"}),"\n",(0,s.jsx)(n.p,{children:"Meta string is a compressed encoding for metadata strings such as field names, type names, and namespaces.\nThis compression significantly reduces the size of type metadata in serialized data."}),"\n",(0,s.jsx)(n.h3,{id:"encoding-type-ids",children:"Encoding Type IDs"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"ID"}),(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Bits/Char"}),(0,s.jsx)(n.th,{children:"Character Set"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"UTF8"}),(0,s.jsx)(n.td,{children:"8"}),(0,s.jsx)(n.td,{children:"Any UTF-8 character"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"LOWER_SPECIAL"}),(0,s.jsx)(n.td,{children:"5"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"a-z . _ $ |"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"LOWER_UPPER_DIGIT_SPECIAL"}),(0,s.jsx)(n.td,{children:"6"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"a-z A-Z 0-9 . _"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"FIRST_TO_LOWER_SPECIAL"}),(0,s.jsx)(n.td,{children:"5"}),(0,s.jsxs)(n.td,{children:["First char uppercase, rest ",(0,s.jsx)(n.code,{children:"a-z . _"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"4"}),(0,s.jsx)(n.td,{children:"ALL_TO_LOWER_SPECIAL"}),(0,s.jsx)(n.td,{children:"5"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"a-z A-Z . _"})," (uppercase escaped)"]})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"character-mapping-tables",children:"Character Mapping Tables"}),"\n",(0,s.jsx)(n.h4,{id:"lower_special-5-bits-per-character",children:"LOWER_SPECIAL (5 bits per character)"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Character"}),(0,s.jsx)(n.th,{children:"Code (binary)"}),(0,s.jsx)(n.th,{children:"Code (decimal)"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"a-z"}),(0,s.jsx)(n.td,{children:"00000-11001"}),(0,s.jsx)(n.td,{children:"0-25"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"."}),(0,s.jsx)(n.td,{children:"11010"}),(0,s.jsx)(n.td,{children:"26"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"_"}),(0,s.jsx)(n.td,{children:"11011"}),(0,s.jsx)(n.td,{children:"27"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"$"}),(0,s.jsx)(n.td,{children:"11100"}),(0,s.jsx)(n.td,{children:"28"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"|"}),(0,s.jsx)(n.td,{children:"11101"}),(0,s.jsx)(n.td,{children:"29"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," The ",(0,s.jsx)(n.code,{children:"|"})," character is used as an escape sequence in ALL_TO_LOWER_SPECIAL encoding."]}),"\n",(0,s.jsx)(n.h4,{id:"lower_upper_digit_special-6-bits-per-character",children:"LOWER_UPPER_DIGIT_SPECIAL (6 bits per character)"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Character"}),(0,s.jsx)(n.th,{children:"Code (binary)"}),(0,s.jsx)(n.th,{children:"Code (decimal)"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"a-z"}),(0,s.jsx)(n.td,{children:"000000-011001"}),(0,s.jsx)(n.td,{children:"0-25"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"A-Z"}),(0,s.jsx)(n.td,{children:"011010-110011"}),(0,s.jsx)(n.td,{children:"26-51"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0-9"}),(0,s.jsx)(n.td,{children:"110100-111101"}),(0,s.jsx)(n.td,{children:"52-61"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"."}),(0,s.jsx)(n.td,{children:"111110"}),(0,s.jsx)(n.td,{children:"62"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"_"}),(0,s.jsx)(n.td,{children:"111111"}),(0,s.jsx)(n.td,{children:"63"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"encoding-algorithms",children:"Encoding Algorithms"}),"\n",(0,s.jsx)(n.h4,{id:"lower_special-encoding",children:"LOWER_SPECIAL Encoding"}),"\n",(0,s.jsxs)(n.p,{children:["For strings containing only ",(0,s.jsx)(n.code,{children:"a-z"}),", ",(0,s.jsx)(n.code,{children:"."}),", ",(0,s.jsx)(n.code,{children:"_"}),", ",(0,s.jsx)(n.code,{children:"$"}),", ",(0,s.jsx)(n.code,{children:"|"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function encode_lower_special(str):\n    bits = []\n    for char in str:\n        bits.append(lookup_lower_special[char])  // 5 bits each\n\n    // Pad to byte boundary\n    total_bits = len(str) * 5\n    padding_bits = (8 - (total_bits % 8)) % 8\n\n    // First bit indicates if last char should be stripped (due to padding)\n    strip_last = (padding_bits >= 5)\n    if strip_last:\n        prepend bit 1\n    else:\n        prepend bit 0\n\n    return pack_bits_to_bytes(bits)\n"})}),"\n",(0,s.jsx)(n.h4,{id:"first_to_lower_special-encoding",children:"FIRST_TO_LOWER_SPECIAL Encoding"}),"\n",(0,s.jsxs)(n.p,{children:["For strings like ",(0,s.jsx)(n.code,{children:"MyFieldName"})," where only the first character is uppercase:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function encode_first_to_lower_special(str):\n    // Convert first char to lowercase\n    modified = str[0].lower() + str[1:]\n    // Then use LOWER_SPECIAL encoding\n    return encode_lower_special(modified)\n"})}),"\n",(0,s.jsx)(n.h4,{id:"all_to_lower_special-encoding",children:"ALL_TO_LOWER_SPECIAL Encoding"}),"\n",(0,s.jsxs)(n.p,{children:["For strings with multiple uppercase characters like ",(0,s.jsx)(n.code,{children:"MyTypeName"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'function encode_all_to_lower_special(str):\n    result = ""\n    for char in str:\n        if char.is_upper():\n            result += "|" + char.lower()  // Escape uppercase with |\n        else:\n            result += char\n    return encode_lower_special(result)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Example: ",(0,s.jsx)(n.code,{children:"MyType"})," \u2192 ",(0,s.jsx)(n.code,{children:"|my|type"})," \u2192 encoded with LOWER_SPECIAL"]}),"\n",(0,s.jsx)(n.h3,{id:"encoding-selection-algorithm",children:"Encoding Selection Algorithm"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function choose_encoding(str):\n    if all chars in str are in [a-z . _ $ |]:\n        return LOWER_SPECIAL\n\n    if first char is uppercase AND rest are in [a-z . _]:\n        return FIRST_TO_LOWER_SPECIAL\n\n    if all chars are in [a-z A-Z . _]:\n        lower_special_size = encode_all_to_lower_special(str).size\n        luds_size = encode_lower_upper_digit_special(str).size\n        if lower_special_size <= luds_size:\n            return ALL_TO_LOWER_SPECIAL\n        else:\n            return LOWER_UPPER_DIGIT_SPECIAL\n\n    if all chars are in [a-z A-Z 0-9 . _]:\n        return LOWER_UPPER_DIGIT_SPECIAL\n\n    return UTF8\n"})}),"\n",(0,s.jsx)(n.h3,{id:"meta-string-header-format",children:"Meta String Header Format"}),"\n",(0,s.jsx)(n.p,{children:"Meta strings are written with a header that includes the encoding type:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| 3 bits encoding | 5+ bits length | encoded bytes |\n"})}),"\n",(0,s.jsx)(n.p,{children:"Or for larger strings:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| varuint: (length << 3) | encoding | encoded bytes |\n"})}),"\n",(0,s.jsx)(n.h3,{id:"special-character-sets-by-context",children:"Special Character Sets by Context"}),"\n",(0,s.jsx)(n.p,{children:"Different contexts use different special characters:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Context"}),(0,s.jsx)(n.th,{children:"Special Chars"}),(0,s.jsx)(n.th,{children:"Notes"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Field Name"}),(0,s.jsx)(n.td,{children:". _ $ |"}),(0,s.jsx)(n.td,{children:"$ for inner classes, | for escape"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Namespace"}),(0,s.jsx)(n.td,{children:". _"}),(0,s.jsx)(n.td,{children:"Package/module separators"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Type Name"}),(0,s.jsx)(n.td,{children:"$ _"}),(0,s.jsx)(n.td,{children:"$ for inner classes in Java"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"deduplication",children:"Deduplication"}),"\n",(0,s.jsx)(n.p,{children:"Meta strings are deduplicated within a serialization session:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"First occurrence:  | (length << 1) | [hash if large] | encoding | bytes |\nReference:         | ((id + 1) << 1) | 1 |\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Bit 0 of the header indicates: 0 = new string, 1 = reference to previous"}),"\n",(0,s.jsx)(n.li,{children:"Large strings (> 16 bytes) include 64-bit hash for content-based deduplication"}),"\n",(0,s.jsx)(n.li,{children:"Small strings use exact byte comparison"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"value-format",children:"Value Format"}),"\n",(0,s.jsx)(n.h3,{id:"basic-types",children:"Basic types"}),"\n",(0,s.jsx)(n.h4,{id:"bool",children:"bool"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 1 byte"}),"\n",(0,s.jsxs)(n.li,{children:["format: 0 for ",(0,s.jsx)(n.code,{children:"false"}),", 1 for ",(0,s.jsx)(n.code,{children:"true"})]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"int8",children:"int8"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 1 byte"}),"\n",(0,s.jsx)(n.li,{children:"format: write as pure byte."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"int16",children:"int16"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 2 byte"}),"\n",(0,s.jsx)(n.li,{children:"byte order: raw bytes of little endian order"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"unsigned-int32",children:"unsigned int32"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 4 byte"}),"\n",(0,s.jsx)(n.li,{children:"byte order: raw bytes of little endian order"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"unsigned-varint32",children:"unsigned varint32"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 1~5 bytes"}),"\n",(0,s.jsxs)(n.li,{children:["Format: The most significant bit (MSB) in every byte indicates whether to have the next byte. If the continuation\nbit is set (i.e. ",(0,s.jsx)(n.code,{children:"b & 0x80 == 0x80"}),"), then the next byte should be read until a byte with unset continuation bit."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Encoding Algorithm:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function write_varuint32(value):\n    while value >= 0x80:\n        buffer.write_byte((value & 0x7F) | 0x80)  // 7 bits of data + continuation bit\n        value = value >> 7\n    buffer.write_byte(value)  // final byte without continuation bit\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Decoding Algorithm:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function read_varuint32():\n    result = 0\n    shift = 0\n    while true:\n        byte = buffer.read_byte()\n        result = result | ((byte & 0x7F) << shift)\n        if (byte & 0x80) == 0:\n            break\n        shift = shift + 7\n    return result\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Byte sizes by value range:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Value Range"}),(0,s.jsx)(n.th,{children:"Bytes"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0 ~ 127"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"128 ~ 16383"}),(0,s.jsx)(n.td,{children:"2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"16384 ~ 2097151"}),(0,s.jsx)(n.td,{children:"3"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2097152 ~ 268435455"}),(0,s.jsx)(n.td,{children:"4"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"268435456 ~ 4294967295"}),(0,s.jsx)(n.td,{children:"5"})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"signed-int32",children:"signed int32"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 4 bytes"}),"\n",(0,s.jsx)(n.li,{children:"byte order: raw bytes of little endian order"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"signed-varint32",children:"signed varint32"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 1~5 bytes"}),"\n",(0,s.jsx)(n.li,{children:"Format: First convert the number into positive unsigned int using ZigZag encoding, then encode as unsigned varint."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"ZigZag Encoding:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"// Encode: convert signed to unsigned\nzigzag_value = (value << 1) ^ (value >> 31)\n\n// Decode: convert unsigned back to signed\noriginal = (zigzag_value >> 1) ^ (-(zigzag_value & 1))\n// Or equivalently:\noriginal = (zigzag_value >> 1) ^ (~(zigzag_value & 1) + 1)\n"})}),"\n",(0,s.jsx)(n.p,{children:"ZigZag encoding maps signed integers to unsigned integers so that small absolute values (positive or negative)\nhave small encoded values:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Original"}),(0,s.jsx)(n.th,{children:"ZigZag Encoded"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"0"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"-1"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"-2"}),(0,s.jsx)(n.td,{children:"3"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"4"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"..."}),(0,s.jsx)(n.td,{children:"..."})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"unsigned-int64",children:"unsigned int64"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 8 bytes"}),"\n",(0,s.jsx)(n.li,{children:"byte order: raw bytes of little endian order"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"unsigned-varint64",children:"unsigned varint64"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 1~9 bytes"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Fory supports two encoding schemes for 64-bit integers:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Fory SLI (Small Long as Int) Encoding:"})}),"\n",(0,s.jsx)(n.p,{children:"Optimized for values that fit in 31 bits (common case for IDs, timestamps, etc.):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"if value in [0, 2147483647]:  // fits in 31 bits\n    write 4 bytes: ((int32) value) << 1  // bit 0 is 0, indicating 4-byte encoding\nelse:\n    write 1 byte:  0x01                  // bit 0 is 1, indicating 9-byte encoding\n    write 8 bytes: value as little-endian int64\n"})}),"\n",(0,s.jsx)(n.p,{children:"Reading:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"first_int32 = read_int32_le()\nif (first_int32 & 1) == 0:\n    return first_int32 >> 1  // 4-byte encoding\nelse:\n    return read_int64_le()   // read remaining 8 bytes\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Fory PVL (Progressive Variable-Length) Encoding:"})}),"\n",(0,s.jsx)(n.p,{children:"Standard varint encoding extended to 64 bits:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function write_varuint64(value):\n    while value >= 0x80:\n        buffer.write_byte((value & 0x7F) | 0x80)\n        value = value >> 7\n    buffer.write_byte(value)\n"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Value Range"}),(0,s.jsx)(n.th,{children:"Bytes"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0 ~ 127"}),(0,s.jsx)(n.td,{children:"1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"128 ~ 16383"}),(0,s.jsx)(n.td,{children:"2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"..."}),(0,s.jsx)(n.td,{children:"..."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2^56 ~ 2^63-1"}),(0,s.jsx)(n.td,{children:"9"})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"varuint36small",children:"VarUint36Small"}),"\n",(0,s.jsx)(n.p,{children:"A specialized encoding used for string headers that combines size (up to 36 bits) with encoding flags:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"// Write: encodes (size << 2) | encoding_flags\nfunction write_varuint36_small(value):\n    if value < 0x80:\n        buffer.write_byte(value)\n    else:\n        // Standard varint encoding for values >= 128\n        write_varuint64(value)\n"})}),"\n",(0,s.jsx)(n.p,{children:"This encoding is optimized for the common case where string length fits in 7 bits (strings < 32 characters)."}),"\n",(0,s.jsx)(n.h4,{id:"signed-int64",children:"signed int64"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 8 bytes"}),"\n",(0,s.jsx)(n.li,{children:"byte order: raw bytes of little endian order"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"signed-varint64",children:"signed varint64"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 1~9 bytes"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Fory SLI (Small Long as Int) Encoding for signed:"})}),"\n",(0,s.jsx)(n.p,{children:"Optimized for small signed values:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"if value in [-1073741824, 1073741823]:  // fits in 31 bits signed\n    write 4 bytes: ((int32) value) << 1  // bit 0 is 0\nelse:\n    write 1 byte:  0x01                  // bit 0 is 1\n    write 8 bytes: value as little-endian int64\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Fory PVL (Progressive Variable-Length) Encoding for signed:"})}),"\n",(0,s.jsx)(n.p,{children:"Uses ZigZag encoding first, then varint:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"// Encode\nzigzag_value = (value << 1) ^ (value >> 63)\nwrite_varuint64(zigzag_value)\n\n// Decode\nzigzag_value = read_varuint64()\nvalue = (zigzag_value >> 1) ^ (-(zigzag_value & 1))\n"})}),"\n",(0,s.jsx)(n.h4,{id:"float32",children:"float32"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 4 byte"}),"\n",(0,s.jsx)(n.li,{children:'format: encode the specified floating-point value according to the IEEE 754 floating-point "single format" bit layout,\npreserving Not-a-Number (NaN) values, then write as binary by little endian order.'}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"float64",children:"float64"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"size: 8 byte"}),"\n",(0,s.jsx)(n.li,{children:'format: encode the specified floating-point value according to the IEEE 754 floating-point "double format" bit layout,\npreserving Not-a-Number (NaN) values. then write as binary by little endian order.'}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"string",children:"string"}),"\n",(0,s.jsx)(n.p,{children:"Format:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| varuint36_small: (size << 2) | encoding | binary data |\n"})}),"\n",(0,s.jsx)(n.h4,{id:"string-header",children:"String Header"}),"\n",(0,s.jsxs)(n.p,{children:["The header is encoded using ",(0,s.jsx)(n.code,{children:"varuint36_small"})," format, which combines the byte length and encoding type:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"header = (byte_length << 2) | encoding_type\n"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Encoding Type"}),(0,s.jsx)(n.th,{children:"Value"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"LATIN1"}),(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"ISO-8859-1 single-byte encoding"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"UTF16"}),(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"UTF-16 encoding (2 bytes per code unit)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"UTF8"}),(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"UTF-8 variable-length encoding"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Reserved"}),(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"Reserved for future use"})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"encoding-algorithm",children:"Encoding Algorithm"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Writing:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function write_string(str):\n    bytes = encode_to_bytes(str, chosen_encoding)\n    header = (bytes.length << 2) | encoding_type\n    buffer.write_varuint36_small(header)\n    buffer.write_bytes(bytes)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Reading:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function read_string():\n    header = buffer.read_varuint36_small()\n    encoding = header & 0x03\n    byte_length = header >> 2\n    bytes = buffer.read_bytes(byte_length)\n    return decode_bytes(bytes, encoding)\n"})}),"\n",(0,s.jsx)(n.h4,{id:"encoding-selection-by-language",children:"Encoding Selection by Language"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Writing:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Language"}),(0,s.jsx)(n.th,{children:"Encoding Strategy"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Java (JDK8)"}),(0,s.jsx)(n.td,{children:"Detect at runtime: LATIN1 if all chars < 256, else UTF16"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Java (JDK9+)"}),(0,s.jsx)(n.td,{children:"Use String's internal coder: LATIN1 or UTF16"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Python"}),(0,s.jsx)(n.td,{children:"Can write LATIN1, UTF16, or UTF8 based on string content"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"C++"}),(0,s.jsxs)(n.td,{children:["UTF8 (",(0,s.jsx)(n.code,{children:"std::string"}),") or UTF16 (",(0,s.jsx)(n.code,{children:"std::u16string"}),")"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Rust"}),(0,s.jsxs)(n.td,{children:["UTF8 (",(0,s.jsx)(n.code,{children:"String"}),")"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Go"}),(0,s.jsxs)(n.td,{children:["UTF8 (",(0,s.jsx)(n.code,{children:"string"}),")"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"JavaScript"}),(0,s.jsx)(n.td,{children:"UTF8"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Reading:"})," All languages support decoding all three encodings (LATIN1, UTF16, UTF8)."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Recommendation:"})," Select encoding based on maximum performance - use the encoding that matches the language's native string representation to avoid conversion overhead."]}),"\n",(0,s.jsx)(n.h4,{id:"empty-string",children:"Empty String"}),"\n",(0,s.jsxs)(n.p,{children:["Empty strings are encoded with header ",(0,s.jsx)(n.code,{children:"0"})," (length 0, any encoding) followed by no data bytes."]}),"\n",(0,s.jsx)(n.h3,{id:"duration",children:"duration"}),"\n",(0,s.jsx)(n.p,{children:"Duration is an absolute length of time, independent of any calendar/timezone, as a count of seconds and nanoseconds."}),"\n",(0,s.jsx)(n.p,{children:"Format:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| signed varint64: seconds | signed int32: nanoseconds |\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"seconds"}),": Number of seconds in the duration, encoded as a signed varint64. Can be positive or negative."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"nanoseconds"}),": Nanosecond adjustment to the duration, encoded as a signed int32. Value range is [0, 999,999,999] for positive durations, and [-999,999,999, 0] for negative durations."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Notes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The duration is stored as two separate fields to maintain precision and avoid overflow issues."}),"\n",(0,s.jsx)(n.li,{children:"Seconds are encoded using varint64 for compact representation of common duration values."}),"\n",(0,s.jsx)(n.li,{children:"Nanoseconds are stored as a fixed int32 since the range is limited."}),"\n",(0,s.jsx)(n.li,{children:"The sign of the duration is determined by the seconds field. When seconds is 0, the sign is determined by nanoseconds."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"collectionlist",children:"collection/list"}),"\n",(0,s.jsx)(n.p,{children:"Format:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| varuint32: length | 1 byte elements header | [optional type info] | elements data |\n"})}),"\n",(0,s.jsx)(n.h4,{id:"elements-header",children:"Elements Header"}),"\n",(0,s.jsx)(n.p,{children:"The elements header is a single byte that encodes metadata about the collection elements to optimize serialization:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| bit 7-4 (reserved) |    bit 3    |      bit 2       |   bit 1  |   bit 0   |\n+--------------------+-------------+------------------+----------+-----------+\n|      reserved      | is_same_type| is_decl_elem_type| has_null | track_ref |\n"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Bit"}),(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Value"}),(0,s.jsx)(n.th,{children:"Meaning when SET (1)"}),(0,s.jsx)(n.th,{children:"Meaning when UNSET (0)"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"track_ref"}),(0,s.jsx)(n.td,{children:"0x01"}),(0,s.jsx)(n.td,{children:"Track references for elements"}),(0,s.jsx)(n.td,{children:"Don't track element references"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"has_null"}),(0,s.jsx)(n.td,{children:"0x02"}),(0,s.jsx)(n.td,{children:"Collection may contain null elements"}),(0,s.jsx)(n.td,{children:"No null elements (skip null checks)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"is_decl_elem_type"}),(0,s.jsx)(n.td,{children:"0x04"}),(0,s.jsx)(n.td,{children:"Elements are the declared generic type"}),(0,s.jsx)(n.td,{children:"Element types differ from declared type"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"is_same_type"}),(0,s.jsx)(n.td,{children:"0x08"}),(0,s.jsx)(n.td,{children:"All elements have the same runtime type"}),(0,s.jsx)(n.td,{children:"Elements have different runtime types"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Common header values:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Header"}),(0,s.jsx)(n.th,{children:"Hex"}),(0,s.jsx)(n.th,{children:"Meaning"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0x0C"}),(0,s.jsx)(n.td,{children:"12"}),(0,s.jsx)(n.td,{children:"Declared type + same type, non-null, no ref tracking (optimal)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0x0D"}),(0,s.jsx)(n.td,{children:"13"}),(0,s.jsx)(n.td,{children:"Declared type + same type, non-null, with ref tracking"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0x0E"}),(0,s.jsx)(n.td,{children:"14"}),(0,s.jsx)(n.td,{children:"Declared type + same type, may have nulls, no ref tracking"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0x08"}),(0,s.jsx)(n.td,{children:"8"}),(0,s.jsx)(n.td,{children:"Same type but not declared type (type info written once)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0x00"}),(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"Different types, non-null, no ref tracking (type per element)"})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"type-info-after-header",children:"Type Info After Header"}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"is_decl_elem_type"})," (bit 2) is NOT set, the element type info is written once after the header if ",(0,s.jsx)(n.code,{children:"is_same_type"})," (bit 3) is set:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| header (0x08) | type_id (varuint32) | elements... |\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When both ",(0,s.jsx)(n.code,{children:"is_decl_elem_type"})," and ",(0,s.jsx)(n.code,{children:"is_same_type"})," are NOT set, type info is written per element."]}),"\n",(0,s.jsx)(n.h4,{id:"element-serialization-based-on-header",children:"Element Serialization Based on Header"}),"\n",(0,s.jsx)(n.p,{children:"The header determines how each element is serialized:"}),"\n",(0,s.jsx)(n.h4,{id:"elements-data",children:"elements data"}),"\n",(0,s.jsxs)(n.p,{children:["Based on the elements header, the serialization of elements data may skip ",(0,s.jsx)(n.code,{children:"ref flag"}),"/",(0,s.jsx)(n.code,{children:"null flag"}),"/",(0,s.jsx)(n.code,{children:"element type info"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"fory = ...\nbuffer = ...\nelems = ...\nif element_type_is_same:\n    if not is_declared_type:\n        fory.write_type(buffer, elem_type)\n    elem_serializer = get_serializer(...)\n    if track_ref:\n        for elem in elems:\n            if not ref_resolver.write_ref_or_null(buffer, elem):\n                elem_serializer.write(buffer, elem)\n    elif has_null:\n        for elem in elems:\n            if elem is None:\n                buffer.write_byte(null_flag)\n            else:\n                buffer.write_byte(not_null_flag)\n                elem_serializer.write(buffer, elem)\n    else:\n        for elem in elems:\n            elem_serializer.write(buffer, elem)\nelse:\n    if track_ref:\n        for elem in elems:\n            fory.write_ref(buffer, elem)\n    elif has_null:\n        for elem in elems:\n            fory.write_nullable(buffer, elem)\n    else:\n        for elem in elems:\n            fory.write_value(buffer, elem)\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/apache/fory/blob/20a1a78b17a75a123a6f5b7094c06ff77defc0fe/java/fory-core/src/main/java/org/apache/fory/serializer/collection/CollectionLikeSerializer.java#L302",children:(0,s.jsx)(n.code,{children:"CollectionSerializer#writeElements"})}),"\ncan be taken as an example."]}),"\n",(0,s.jsx)(n.h3,{id:"array",children:"array"}),"\n",(0,s.jsx)(n.h4,{id:"primitive-array",children:"primitive array"}),"\n",(0,s.jsx)(n.p,{children:"Primitive array are taken as a binary buffer, serialization will just write the length of array size as an unsigned int,\nthen copy the whole buffer into the stream."}),"\n",(0,s.jsx)(n.p,{children:"Such serialization won't compress the array. If users want to compress primitive array, users need to register custom\nserializers for such types or mark it as list type."}),"\n",(0,s.jsx)(n.h4,{id:"tensor",children:"Tensor"}),"\n",(0,s.jsx)(n.p,{children:"Tensor is a special primitive multi-dimensional array which all dimensions have same size and type. The serialization\nformat is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| num_dims(unsigned varint) | shape[0](unsigned varint) | shape[...] | shape[N] | element type | data |\n"})}),"\n",(0,s.jsx)(n.p,{children:"The data is continuous to reduce copy and may zero-copy in some cases."}),"\n",(0,s.jsx)(n.h4,{id:"object-array",children:"object array"}),"\n",(0,s.jsx)(n.p,{children:"Object array is serialized using the list format. Object component type will be taken as list element\ngeneric type."}),"\n",(0,s.jsx)(n.h3,{id:"map",children:"map"}),"\n",(0,s.jsx)(n.p,{children:"Map uses a chunk-based format to handle heterogeneous key-value pairs efficiently:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| varuint32: total_size | chunk_1 | chunk_2 | ... | chunk_n |\n"})}),"\n",(0,s.jsx)(n.h4,{id:"map-chunk-format",children:"Map Chunk Format"}),"\n",(0,s.jsx)(n.p,{children:"Each chunk contains up to 255 key-value pairs with the same metadata characteristics:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"|    1 byte    |     1 byte     |        variable bytes        |\n+--------------+----------------+------------------------------+\n|  KV header   |  chunk size N  |  N key-value pairs (N*2 obj) |\n"})}),"\n",(0,s.jsx)(n.h4,{id:"kv-header-bits",children:"KV Header Bits"}),"\n",(0,s.jsx)(n.p,{children:"The KV header is a single byte encoding metadata for both keys and values:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"|  bit 7-6   |     bit 5     |     bit 4    |     bit 3     |     bit 2     |     bit 1    |     bit 0     |\n+------------+---------------+--------------+---------------+---------------+--------------+---------------+\n|  reserved  | val_decl_type | val_has_null | val_track_ref | key_decl_type | key_has_null | key_track_ref |\n"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Bit"}),(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Value"}),(0,s.jsx)(n.th,{children:"Meaning when SET (1)"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"key_track_ref"}),(0,s.jsx)(n.td,{children:"0x01"}),(0,s.jsx)(n.td,{children:"Track references for keys"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"key_has_null"}),(0,s.jsx)(n.td,{children:"0x02"}),(0,s.jsx)(n.td,{children:"Keys may be null (rare, usually invalid)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"key_decl_type"}),(0,s.jsx)(n.td,{children:"0x04"}),(0,s.jsx)(n.td,{children:"Key is the declared generic type"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"val_track_ref"}),(0,s.jsx)(n.td,{children:"0x08"}),(0,s.jsx)(n.td,{children:"Track references for values"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"4"}),(0,s.jsx)(n.td,{children:"val_has_null"}),(0,s.jsx)(n.td,{children:"0x10"}),(0,s.jsx)(n.td,{children:"Values may be null"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"5"}),(0,s.jsx)(n.td,{children:"val_decl_type"}),(0,s.jsx)(n.td,{children:"0x20"}),(0,s.jsx)(n.td,{children:"Value is the declared generic type"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Common KV header values:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Header"}),(0,s.jsx)(n.th,{children:"Hex"}),(0,s.jsx)(n.th,{children:"Meaning"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0x24"}),(0,s.jsx)(n.td,{children:"36"}),(0,s.jsx)(n.td,{children:"Key + value are declared types, non-null, no ref tracking (optimal)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0x2C"}),(0,s.jsx)(n.td,{children:"44"}),(0,s.jsx)(n.td,{children:"Key + value declared types, value tracks refs"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0x34"}),(0,s.jsx)(n.td,{children:"52"}),(0,s.jsx)(n.td,{children:"Key + value declared types, value may be null"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0x00"}),(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"Key + value not declared types, non-null, no ref tracking"})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"chunk-size",children:"Chunk Size"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Maximum chunk size: 255 pairs (fits in 1 byte)"}),"\n",(0,s.jsx)(n.li,{children:"When key or value is null, that entry is serialized as a separate chunk with implicit size 1 (chunk size byte is skipped)"}),"\n",(0,s.jsx)(n.li,{children:"Reader tracks accumulated count against total map size to know when to stop reading chunks"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"why-chunk-based-format",children:"Why Chunk-Based Format?"}),"\n",(0,s.jsx)(n.p,{children:"Map iteration is expensive. Computing a single header for all pairs would require two passes. The chunk-based\napproach allows:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Optimistic prediction"}),": Use first key-value pair to predict header"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Adaptive chunking"}),": Start new chunk if prediction fails for a pair"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Efficient reading"}),": Most maps fit in single chunk (< 255 pairs)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory efficiency"}),": Minimal overhead for common homogeneous maps"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"why-serialize-chunk-by-chunk",children:"Why serialize chunk by chunk?"}),"\n",(0,s.jsxs)(n.p,{children:["When fory will use first key-value pair to predict header optimistically, it can't know how many pairs have same\nmeta(tracking kef ref, key has null and so on). If we don't write chunk by chunk with max chunk size, we must write at\nleast ",(0,s.jsx)(n.code,{children:"X"})," bytes to take up a place for later to update the number which has same elements, ",(0,s.jsx)(n.code,{children:"X"})," is the num_bytes for\nencoding varint encoding of map size."]}),"\n",(0,s.jsx)(n.p,{children:"And most map size are smaller than 255, if all pairs have same data, the chunk will be 1. This is common in golang/rust,\nwhich object are not reference by default."}),"\n",(0,s.jsx)(n.p,{children:"Also, if only one or two keys have different meta, we can make it into a different chunk, so that most pairs can share\nmeta."}),"\n",(0,s.jsx)(n.p,{children:"The implementation can accumulate read count with map size to decide whether to read more chunks."}),"\n",(0,s.jsx)(n.h3,{id:"enum",children:"enum"}),"\n",(0,s.jsx)(n.p,{children:"Enums are serialized as an unsigned var int. If the order of enum values change, the deserialized enum value may not be\nthe value users expect. In such cases, users must register enum serializer by make it write enum value as an enumerated\nstring with unique hash disabled."}),"\n",(0,s.jsx)(n.h3,{id:"decimal",children:"decimal"}),"\n",(0,s.jsx)(n.p,{children:"Not supported for now."}),"\n",(0,s.jsx)(n.h3,{id:"struct",children:"struct"}),"\n",(0,s.jsxs)(n.p,{children:["Struct means object of ",(0,s.jsx)(n.code,{children:"class/pojo/struct/bean/record"})," type.\nStruct will be serialized by writing its fields data in fory order."]}),"\n",(0,s.jsx)(n.p,{children:"Depending on schema compatibility, structs will have different formats."}),"\n",(0,s.jsx)(n.h4,{id:"field-order-1",children:"field order"}),"\n",(0,s.jsx)(n.p,{children:"Field will be ordered as following, every group of fields will have its own order:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["primitive fields:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"larger size type first, smaller later, variable size type last."}),"\n",(0,s.jsx)(n.li,{children:"when same size, sort by type id"}),"\n",(0,s.jsx)(n.li,{children:"when same size and type id, sort by snake case field name"}),"\n",(0,s.jsx)(n.li,{children:"types: bool/int8/int16/int32/varint32/int64/varint64/sliint64/float16/float32/float64"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"nullable primitive fields: same order as primitive fields"}),"\n",(0,s.jsx)(n.li,{children:"other internal type fields: sort by type id then snake case field name"}),"\n",(0,s.jsx)(n.li,{children:"list fields: sort by snake case field name"}),"\n",(0,s.jsx)(n.li,{children:"set fields: sort by snake case field name"}),"\n",(0,s.jsx)(n.li,{children:"map fields: sort by snake case field name"}),"\n",(0,s.jsx)(n.li,{children:"other fields: sort by snake case field name"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If two fields have same type, then sort by snake_case styled field name."}),"\n",(0,s.jsx)(n.h4,{id:"schema-consistent-1",children:"schema consistent"}),"\n",(0,s.jsx)(n.p,{children:"Object will be written as:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"|    4 byte     |  variable bytes  |\n+---------------+------------------+\n|   type hash   |   field values   |\n"})}),"\n",(0,s.jsx)(n.p,{children:"Type hash is used to check the type schema consistency across languages. Type hash will be the first 32 bits of 56 bits\nvalue of the type meta."}),"\n",(0,s.jsx)(n.p,{children:"Object fields will be serialized one by one using following format:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"not null primitive field value:\n|   var bytes    |\n+----------------+\n|   value data   |\n+----------------+\nnullable primitive field value:\n| one byte  |   var bytes   |\n+-----------+---------------+\n| null flag |  field value  |\n+-----------+---------------+\nother interal types supported by fory\n| var bytes | var objects |\n+-----------+-------------+\n| null flag | value data  |\n+-----------+-------------+\nlist field type:\n| one byte  | var objects |\n+-----------+-------------+\n| ref meta  | value data  |\nset field type:\n| one byte  | var objects |\n+-----------+-------------+\n| ref meta  | value data  |\nmap field type:\n| one byte  | var objects |\n+-----------+-------------+\n| ref meta  | value data  |\n+-----------+-------------+-------------+\nother types such as enum/struct/ext\n| one byte  | var bytes | var objects |\n+-----------+------------+------------+\n| ref  flag | type meta | value data |\n+-----------+------------+------------+\n"})}),"\n",(0,s.jsx)(n.p,{children:"Type hash algorithm:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Sort fields by fields sort algorithm"}),"\n",(0,s.jsxs)(n.li,{children:["Start with string ",(0,s.jsx)(n.code,{children:'""'})]}),"\n",(0,s.jsxs)(n.li,{children:["Iterate every field, append string by:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"snow_case(field_name),"}),". For camelcase name, convert it to snow_case first."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"$type_id,"}),", for other fields, use type id ",(0,s.jsx)(n.code,{children:"TypeId::UNKNOWN"})," instead."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"$nullable;"}),", ",(0,s.jsx)(n.code,{children:"1"})," if nullable, ",(0,s.jsx)(n.code,{children:"0"})," otherwise."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Then convert string to utf8 bytes"}),"\n",(0,s.jsx)(n.li,{children:"Compute murmurhash3_x64_128, and use first 32 bits"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"schema-evolution-1",children:"Schema evolution"}),"\n",(0,s.jsx)(n.p,{children:"Schema evolution have similar format as schema consistent mode for object except:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["For the object type, ",(0,s.jsx)(n.code,{children:"schema consistent"})," mode will write type by id only, but ",(0,s.jsx)(n.code,{children:"schema evolution"})," mode will\nwrite type consisting of field names, types and other meta too, see ",(0,s.jsx)(n.a,{href:"#type-meta",children:"Type meta"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Type meta of ",(0,s.jsx)(n.code,{children:"final custom type"})," needs to be written too, because peers may not have this type defined."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"type",children:"Type"}),"\n",(0,s.jsx)(n.p,{children:"Type will be serialized using type meta format."}),"\n",(0,s.jsx)(n.h2,{id:"implementation-guidelines",children:"Implementation guidelines"}),"\n",(0,s.jsx)(n.h3,{id:"how-to-reduce-memory-readwrite-code",children:"How to reduce memory read/write code"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Try to merge multiple bytes into an int/long write before writing to reduce memory IO and bound check cost."}),"\n",(0,s.jsx)(n.li,{children:"Read multiple bytes as an int/long, then split into multiple bytes to reduce memory IO and bound check cost."}),"\n",(0,s.jsx)(n.li,{children:"Try to use one varint/long to write flags and length together to save one byte cost and reduce memory io."}),"\n",(0,s.jsx)(n.li,{children:"Condition branches are less expensive compared to memory IO cost unless there are too many branches."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"fast-deserialization-for-static-languages-without-runtime-codegen-support",children:"Fast deserialization for static languages without runtime codegen support"}),"\n",(0,s.jsx)(n.p,{children:"For type evolution, the serializer will encode the type meta into the serialized data. The deserializer will compare\nthis meta with class meta in the current process, and use the diff to determine how to deserialize the data."}),"\n",(0,s.jsx)(n.p,{children:"For java/javascript/python, we can use the diff to generate serializer code at runtime and load it as class/function for\ndeserialization. In this way, the type evolution will be as fast as type consist mode."}),"\n",(0,s.jsx)(n.p,{children:"For C++/Rust, we can't generate the serializer code at runtime. So we need to generate the code at compile-time using\nmeta programming. But at that time, we don't know the type schema in other processes, so we can't generate the\nserializer code for such inconsistent types. We may need to generate the code which has a loop and compare field name\none by one to decide whether to deserialize and assign the field or skip the field value."}),"\n",(0,s.jsxs)(n.p,{children:["One fast way is that we can optimize the string comparison into ",(0,s.jsx)(n.code,{children:"jump"})," instructions:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Assume the current type has ",(0,s.jsx)(n.code,{children:"n"})," fields, and the peer type has ",(0,s.jsx)(n.code,{children:"n1"})," fields."]}),"\n",(0,s.jsxs)(n.li,{children:["Generate an auto growing ",(0,s.jsx)(n.code,{children:"field id"})," from ",(0,s.jsx)(n.code,{children:"0"})," for every sorted field in the current type at the compile time."]}),"\n",(0,s.jsxs)(n.li,{children:["Compare the received type meta with current type, generate same id if the field name is same, otherwise generate an\nauto growing id starting from ",(0,s.jsx)(n.code,{children:"n"}),", cache this meta at runtime."]}),"\n",(0,s.jsxs)(n.li,{children:["Iterate the fields of received type meta, use a ",(0,s.jsx)(n.code,{children:"switch"})," to compare the ",(0,s.jsx)(n.code,{children:"field id"})," to deserialize data\nand ",(0,s.jsx)(n.code,{children:"assign/skip"})," field value. ",(0,s.jsx)(n.strong,{children:"Continuous"})," field id will be optimized into ",(0,s.jsx)(n.code,{children:"jump"})," in ",(0,s.jsx)(n.code,{children:"switch"})," block, so it will\nvery fast."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Here is an example, suppose process A has a class ",(0,s.jsx)(n.code,{children:"Foo"})," with version 1 defined as ",(0,s.jsx)(n.code,{children:"Foo1"}),", process B has a class ",(0,s.jsx)(n.code,{children:"Foo"}),"\nwith version 2 defined as ",(0,s.jsx)(n.code,{children:"Foo2"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c++",children:"// class Foo with version 1\nclass Foo1 {\n  int32_t v1; // id 0\n  std::string v2; // id 1\n};\n// class Foo with version 2\nclass Foo2 {\n  // id 0, but will have id 2 in process A\n  bool v0;\n  // id 1, but will have id 0 in process A\n  int32_t v1;\n  // id 2, but will have id 3 in process A\n  int64_t long_value;\n  // id 3, but will have id 1 in process A\n  std::string v2;\n  // id 4, but will have id 4 in process A\n  std::vector<std::string> list;\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When process A received serialized ",(0,s.jsx)(n.code,{children:"Foo2"})," from process B, here is how it deserialize the data:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c++",children:"Foo1 foo1 = ...;\nconst std::vector<fory::FieldInfo> &field_infos = type_meta.field_infos;\nfor (const auto &field_info : field_infos) {\n  switch (field_info.field_id) {\n    case 0:\n      foo1.v1 = buffer.read_varint32();\n      break;\n    case 1:\n      foo1.v2 = fory.read_string();\n      break;\n    default:\n      fory.skip_data(field_info);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"implementation-checklist-for-new-languages",children:"Implementation Checklist for New Languages"}),"\n",(0,s.jsx)(n.p,{children:"This section provides a step-by-step guide for implementing Fory xlang serialization in a new language."}),"\n",(0,s.jsx)(n.h3,{id:"phase-1-core-infrastructure",children:"Phase 1: Core Infrastructure"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Buffer Implementation"})}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Create a byte buffer with read/write cursor tracking"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement little-endian byte order for all multi-byte writes"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement ",(0,s.jsx)(n.code,{children:"write_int8"}),", ",(0,s.jsx)(n.code,{children:"write_int16"}),", ",(0,s.jsx)(n.code,{children:"write_int32"}),", ",(0,s.jsx)(n.code,{children:"write_int64"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement ",(0,s.jsx)(n.code,{children:"write_float32"}),", ",(0,s.jsx)(n.code,{children:"write_float64"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement ",(0,s.jsx)(n.code,{children:"read_*"})," counterparts for all write methods"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement buffer growth strategy (e.g., doubling)"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Varint Encoding"})}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement ",(0,s.jsx)(n.code,{children:"write_varuint32"})," / ",(0,s.jsx)(n.code,{children:"read_varuint32"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement ",(0,s.jsx)(n.code,{children:"write_varint32"})," / ",(0,s.jsx)(n.code,{children:"read_varint32"})," (with ZigZag)"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement ",(0,s.jsx)(n.code,{children:"write_varuint64"})," / ",(0,s.jsx)(n.code,{children:"read_varuint64"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement ",(0,s.jsx)(n.code,{children:"write_varint64"})," / ",(0,s.jsx)(n.code,{children:"read_varint64"})," (with ZigZag)"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement ",(0,s.jsx)(n.code,{children:"write_varuint36_small"})," / ",(0,s.jsx)(n.code,{children:"read_varuint36_small"})," (for strings)"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Optionally implement SLI encoding for int64"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Header Handling"})}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Write magic number ",(0,s.jsx)(n.code,{children:"0x62d4"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Write/read bitmap flags (null, endian, xlang, oob)"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Write/read language ID"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Handle meta start offset placeholder (for schema evolution)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"phase-2-basic-type-serializers",children:"Phase 2: Basic Type Serializers"}),"\n",(0,s.jsxs)(n.ol,{start:"4",children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Primitive Types"})}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","bool (1 byte: 0 or 1)"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","int8, int16, int32, int64 (little endian)"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","float32, float64 (IEEE 754, little endian)"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"String Serialization"})}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement string header: ",(0,s.jsx)(n.code,{children:"(byte_length << 2) | encoding"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Support UTF-8 encoding (required for xlang)"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Optionally support LATIN1 and UTF-16"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Temporal Types"})}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Duration (seconds + nanoseconds)"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Timestamp (nanoseconds since epoch)"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","LocalDate (days since epoch)"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Reference Tracking"})}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement write-side object tracking (object \u2192 ref_id map)"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement read-side object tracking (ref_id \u2192 object list)"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Handle all four reference flags: NULL(-3), REF(-2), NOT_NULL(-1), REF_VALUE(0)"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Support disabling reference tracking per-type or globally"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"phase-3-collection-types",children:"Phase 3: Collection Types"}),"\n",(0,s.jsxs)(n.ol,{start:"8",children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"List/Array Serialization"})}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Write length as varuint32"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Write elements header byte"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Handle homogeneous vs heterogeneous elements"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Handle null elements"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Map Serialization"})}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Write total size as varuint32"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement chunk-based format (max 255 pairs per chunk)"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Write KV header byte per chunk"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Handle key and value type variations"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Set Serialization"})}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Same format as List (reuse implementation)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"phase-4-meta-string-encoding",children:"Phase 4: Meta String Encoding"}),"\n",(0,s.jsx)(n.p,{children:"Meta strings are required for enum and struct serialization (encoding field names, type names, namespaces)."}),"\n",(0,s.jsxs)(n.ol,{start:"11",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Meta String Compression"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement LOWER_SPECIAL encoding (5 bits/char)"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement LOWER_UPPER_DIGIT_SPECIAL encoding (6 bits/char)"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement FIRST_TO_LOWER_SPECIAL encoding"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement ALL_TO_LOWER_SPECIAL encoding"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement encoding selection algorithm"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement meta string deduplication"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"phase-5-enum-serialization",children:"Phase 5: Enum Serialization"}),"\n",(0,s.jsxs)(n.ol,{start:"12",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Enum Serialization"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Write ordinal as varuint32"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Support named enum (namespace + type name)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"phase-6-struct-serialization",children:"Phase 6: Struct Serialization"}),"\n",(0,s.jsxs)(n.ol,{start:"13",children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Type Registration"})}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Support registration by numeric ID"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Support registration by namespace + type name"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Maintain type \u2192 serializer mapping"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Generate type IDs: ",(0,s.jsx)(n.code,{children:"(user_id << 8) | internal_type_id"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Field Ordering"})}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement Fory field ordering algorithm"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Sort primitives by size (larger first), then type ID, then name"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Handle nullable vs non-nullable fields"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Convert field names to snake_case for sorting"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Schema Consistent Mode"})}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Compute type hash (MurmurHash3 of field info string)"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Write 4-byte type hash before fields"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Serialize fields in Fory order"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Schema Evolution Mode"})," (Optional)"]}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement type meta writing"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Support field addition/removal"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Handle unknown fields (skip during read)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"phase-7-other-types",children:"Phase 7: Other types"}),"\n",(0,s.jsxs)(n.ol,{start:"17",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Binary/Array Types"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Primitive arrays (direct buffer copy)"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Tensor (multi-dimensional arrays)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"testing-strategy",children:"Testing Strategy"}),"\n",(0,s.jsxs)(n.ol,{start:"18",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cross-Language Compatibility Tests"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Serialize in new language, deserialize in Java/Python"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Serialize in Java/Python, deserialize in new language"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Test all primitive types"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Test strings with various encodings"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Test collections (empty, single, multiple elements)"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Test maps with various key/value types"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Test nested structs"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Test circular references (if supported)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"language-specific-implementation-notes",children:"Language-Specific Implementation Notes"}),"\n",(0,s.jsx)(n.h3,{id:"java",children:"Java"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Uses runtime code generation (JIT) for maximum performance"}),"\n",(0,s.jsx)(n.li,{children:"Supports all reference tracking modes"}),"\n",(0,s.jsx)(n.li,{children:"Uses internal String coder for encoding selection"}),"\n",(0,s.jsxs)(n.li,{children:["Thread-safe via ",(0,s.jsx)(n.code,{children:"ThreadSafeFory"})," wrapper"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"python",children:"Python"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Two modes: Pure Python (debugging) and Cython (performance)"}),"\n",(0,s.jsxs)(n.li,{children:["Uses ",(0,s.jsx)(n.code,{children:"id(obj)"})," for reference tracking"]}),"\n",(0,s.jsx)(n.li,{children:"Latin1/UTF-16/UTF-8 encoding for all strings in xlang mode"}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"dataclass"})," support via code generation"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"c",children:"C++"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Compile-time reflection via macros (",(0,s.jsx)(n.code,{children:"FORY_STRUCT"}),", ",(0,s.jsx)(n.code,{children:"FORY_FIELD_INFO"}),")"]}),"\n",(0,s.jsx)(n.li,{children:"Template meta programming for type dispatch and serializer selection"}),"\n",(0,s.jsxs)(n.li,{children:["Uses ",(0,s.jsx)(n.code,{children:"std::shared_ptr"})," for reference tracking"]}),"\n",(0,s.jsx)(n.li,{children:"Compile-time field ordering"}),"\n",(0,s.jsx)(n.li,{children:"No runtime code generation"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"rust",children:"Rust"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Derive macros for automatic serialization (",(0,s.jsx)(n.code,{children:"#[derive(ForyObject)]"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["Uses ",(0,s.jsx)(n.code,{children:"Rc<T>"})," / ",(0,s.jsx)(n.code,{children:"Arc<T>"})," for reference tracking"]}),"\n",(0,s.jsx)(n.li,{children:"Thread-local context caching for performance"}),"\n",(0,s.jsx)(n.li,{children:"Compile-time field ordering"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"go",children:"Go"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reflection-based and codegen-based modes"}),"\n",(0,s.jsx)(n.li,{children:"Struct tags for field annotations"}),"\n",(0,s.jsx)(n.li,{children:"Interface types for polymorphism"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Byte Order"}),": Always use little-endian for multi-byte values"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Varint Sign Extension"}),": Ensure proper handling of signed vs unsigned varints"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reference ID Ordering"}),": IDs must be assigned in serialization order"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Field Order Consistency"}),": Must match exactly across languages (schema consistent mode only; in evolution mode, deserialization follows serialization field order from type meta)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"String Encoding"}),": Use best encoding for current language"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Null Handling"}),": Different languages represent null differently"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Empty Collections"}),": Still write length (0) and header byte"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type Hash Calculation"}),": Must use exact same algorithm across languages"]}),"\n"]})]})}function o(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>d,a:()=>l});var s=i(67294);const t={},r=s.createContext(t);function l(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);